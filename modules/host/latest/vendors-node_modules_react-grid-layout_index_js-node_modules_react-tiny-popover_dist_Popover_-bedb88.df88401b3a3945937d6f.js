/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhost"] = self["webpackChunkhost"] || []).push([["vendors-node_modules_react-grid-layout_index_js-node_modules_react-tiny-popover_dist_Popover_-bedb88"],{

/***/ "../../node_modules/clsx/dist/clsx.js":
/*!********************************************!*\
  !*** ../../node_modules/clsx/dist/clsx.js ***!
  \********************************************/
/***/ ((module) => {

eval("function r(e){var o,t,f=\"\";if(\"string\"==typeof e||\"number\"==typeof e)f+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var n=e.length;for(o=0;o<n;o++)e[o]&&(t=r(e[o]))&&(f&&(f+=\" \"),f+=t)}else for(t in e)e[t]&&(f&&(f+=\" \"),f+=t);return f}function e(){for(var e,o,t=0,f=\"\",n=arguments.length;t<n;t++)(e=arguments[t])&&(o=r(e))&&(f&&(f+=\" \"),f+=o);return f}module.exports=e,module.exports.clsx=e;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4LmpzIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9zdC8uLi8uLi9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3guanM/NDNkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiByKGUpe3ZhciBvLHQsZj1cIlwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZSlmKz1lO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGUpaWYoQXJyYXkuaXNBcnJheShlKSl7dmFyIG49ZS5sZW5ndGg7Zm9yKG89MDtvPG47bysrKWVbb10mJih0PXIoZVtvXSkpJiYoZiYmKGYrPVwiIFwiKSxmKz10KX1lbHNlIGZvcih0IGluIGUpZVt0XSYmKGYmJihmKz1cIiBcIiksZis9dCk7cmV0dXJuIGZ9ZnVuY3Rpb24gZSgpe2Zvcih2YXIgZSxvLHQ9MCxmPVwiXCIsbj1hcmd1bWVudHMubGVuZ3RoO3Q8bjt0KyspKGU9YXJndW1lbnRzW3RdKSYmKG89cihlKSkmJihmJiYoZis9XCIgXCIpLGYrPW8pO3JldHVybiBmfW1vZHVsZS5leHBvcnRzPWUsbW9kdWxlLmV4cG9ydHMuY2xzeD1lOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/clsx/dist/clsx.js\n");

/***/ }),

/***/ "../../node_modules/css-loader/dist/cjs.js!../../node_modules/react-grid-layout/css/styles.css":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/css-loader/dist/cjs.js!../../node_modules/react-grid-layout/css/styles.css ***!
  \*****************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/sourceMaps.js */ \"../../node_modules/css-loader/dist/runtime/sourceMaps.js\");\n/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ \"../../node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.react-grid-layout {\n  position: relative;\n  transition: height 200ms ease;\n}\n.react-grid-item {\n  transition: all 200ms ease;\n  transition-property: left, top, width, height;\n}\n.react-grid-item img {\n  pointer-events: none;\n  user-select: none;\n}\n.react-grid-item.cssTransforms {\n  transition-property: transform, width, height;\n}\n.react-grid-item.resizing {\n  transition: none;\n  z-index: 1;\n  will-change: width, height;\n}\n\n.react-grid-item.react-draggable-dragging {\n  transition: none;\n  z-index: 3;\n  will-change: transform;\n}\n\n.react-grid-item.dropping {\n  visibility: hidden;\n}\n\n.react-grid-item.react-grid-placeholder {\n  background: red;\n  opacity: 0.2;\n  transition-duration: 100ms;\n  z-index: 2;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  -o-user-select: none;\n  user-select: none;\n}\n\n.react-grid-item.react-grid-placeholder.placeholder-resizing {\n  transition: none;\n}\n\n.react-grid-item > .react-resizable-handle {\n  position: absolute;\n  width: 20px;\n  height: 20px;\n}\n\n.react-grid-item > .react-resizable-handle::after {\n  content: \"\";\n  position: absolute;\n  right: 3px;\n  bottom: 3px;\n  width: 5px;\n  height: 5px;\n  border-right: 2px solid rgba(0, 0, 0, 0.4);\n  border-bottom: 2px solid rgba(0, 0, 0, 0.4);\n}\n\n.react-resizable-hide > .react-resizable-handle {\n  display: none;\n}\n\n.react-grid-item > .react-resizable-handle.react-resizable-handle-sw {\n  bottom: 0;\n  left: 0;\n  cursor: sw-resize;\n  transform: rotate(90deg);\n}\n.react-grid-item > .react-resizable-handle.react-resizable-handle-se {\n  bottom: 0;\n  right: 0;\n  cursor: se-resize;\n}\n.react-grid-item > .react-resizable-handle.react-resizable-handle-nw {\n  top: 0;\n  left: 0;\n  cursor: nw-resize;\n  transform: rotate(180deg);\n}\n.react-grid-item > .react-resizable-handle.react-resizable-handle-ne {\n  top: 0;\n  right: 0;\n  cursor: ne-resize;\n  transform: rotate(270deg);\n}\n.react-grid-item > .react-resizable-handle.react-resizable-handle-w,\n.react-grid-item > .react-resizable-handle.react-resizable-handle-e {\n  top: 50%;\n  margin-top: -10px;\n  cursor: ew-resize;\n}\n.react-grid-item > .react-resizable-handle.react-resizable-handle-w {\n  left: 0;\n  transform: rotate(135deg);\n}\n.react-grid-item > .react-resizable-handle.react-resizable-handle-e {\n  right: 0;\n  transform: rotate(315deg);\n}\n.react-grid-item > .react-resizable-handle.react-resizable-handle-n,\n.react-grid-item > .react-resizable-handle.react-resizable-handle-s {\n  left: 50%;\n  margin-left: -10px;\n  cursor: ns-resize;\n}\n.react-grid-item > .react-resizable-handle.react-resizable-handle-n {\n  top: 0;\n  transform: rotate(225deg);\n}\n.react-grid-item > .react-resizable-handle.react-resizable-handle-s {\n  bottom: 0;\n  transform: rotate(45deg);\n}\n`, \"\",{\"version\":3,\"sources\":[\"webpack://./../../node_modules/react-grid-layout/css/styles.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,kBAAkB;EAClB,6BAA6B;AAC/B;AACA;EACE,0BAA0B;EAC1B,6CAA6C;AAC/C;AACA;EACE,oBAAoB;EACpB,iBAAiB;AACnB;AACA;EACE,6CAA6C;AAC/C;AACA;EACE,gBAAgB;EAChB,UAAU;EACV,0BAA0B;AAC5B;;AAEA;EACE,gBAAgB;EAChB,UAAU;EACV,sBAAsB;AACxB;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,eAAe;EACf,YAAY;EACZ,0BAA0B;EAC1B,UAAU;EACV,yBAAyB;EACzB,sBAAsB;EACtB,qBAAqB;EACrB,oBAAoB;EACpB,iBAAiB;AACnB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;;AAEA;EACE,WAAW;EACX,kBAAkB;EAClB,UAAU;EACV,WAAW;EACX,UAAU;EACV,WAAW;EACX,0CAA0C;EAC1C,2CAA2C;AAC7C;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,SAAS;EACT,OAAO;EACP,iBAAiB;EACjB,wBAAwB;AAC1B;AACA;EACE,SAAS;EACT,QAAQ;EACR,iBAAiB;AACnB;AACA;EACE,MAAM;EACN,OAAO;EACP,iBAAiB;EACjB,yBAAyB;AAC3B;AACA;EACE,MAAM;EACN,QAAQ;EACR,iBAAiB;EACjB,yBAAyB;AAC3B;AACA;;EAEE,QAAQ;EACR,iBAAiB;EACjB,iBAAiB;AACnB;AACA;EACE,OAAO;EACP,yBAAyB;AAC3B;AACA;EACE,QAAQ;EACR,yBAAyB;AAC3B;AACA;;EAEE,SAAS;EACT,kBAAkB;EAClB,iBAAiB;AACnB;AACA;EACE,MAAM;EACN,yBAAyB;AAC3B;AACA;EACE,SAAS;EACT,wBAAwB;AAC1B\",\"sourcesContent\":[\".react-grid-layout {\\n  position: relative;\\n  transition: height 200ms ease;\\n}\\n.react-grid-item {\\n  transition: all 200ms ease;\\n  transition-property: left, top, width, height;\\n}\\n.react-grid-item img {\\n  pointer-events: none;\\n  user-select: none;\\n}\\n.react-grid-item.cssTransforms {\\n  transition-property: transform, width, height;\\n}\\n.react-grid-item.resizing {\\n  transition: none;\\n  z-index: 1;\\n  will-change: width, height;\\n}\\n\\n.react-grid-item.react-draggable-dragging {\\n  transition: none;\\n  z-index: 3;\\n  will-change: transform;\\n}\\n\\n.react-grid-item.dropping {\\n  visibility: hidden;\\n}\\n\\n.react-grid-item.react-grid-placeholder {\\n  background: red;\\n  opacity: 0.2;\\n  transition-duration: 100ms;\\n  z-index: 2;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  -o-user-select: none;\\n  user-select: none;\\n}\\n\\n.react-grid-item.react-grid-placeholder.placeholder-resizing {\\n  transition: none;\\n}\\n\\n.react-grid-item > .react-resizable-handle {\\n  position: absolute;\\n  width: 20px;\\n  height: 20px;\\n}\\n\\n.react-grid-item > .react-resizable-handle::after {\\n  content: \\\"\\\";\\n  position: absolute;\\n  right: 3px;\\n  bottom: 3px;\\n  width: 5px;\\n  height: 5px;\\n  border-right: 2px solid rgba(0, 0, 0, 0.4);\\n  border-bottom: 2px solid rgba(0, 0, 0, 0.4);\\n}\\n\\n.react-resizable-hide > .react-resizable-handle {\\n  display: none;\\n}\\n\\n.react-grid-item > .react-resizable-handle.react-resizable-handle-sw {\\n  bottom: 0;\\n  left: 0;\\n  cursor: sw-resize;\\n  transform: rotate(90deg);\\n}\\n.react-grid-item > .react-resizable-handle.react-resizable-handle-se {\\n  bottom: 0;\\n  right: 0;\\n  cursor: se-resize;\\n}\\n.react-grid-item > .react-resizable-handle.react-resizable-handle-nw {\\n  top: 0;\\n  left: 0;\\n  cursor: nw-resize;\\n  transform: rotate(180deg);\\n}\\n.react-grid-item > .react-resizable-handle.react-resizable-handle-ne {\\n  top: 0;\\n  right: 0;\\n  cursor: ne-resize;\\n  transform: rotate(270deg);\\n}\\n.react-grid-item > .react-resizable-handle.react-resizable-handle-w,\\n.react-grid-item > .react-resizable-handle.react-resizable-handle-e {\\n  top: 50%;\\n  margin-top: -10px;\\n  cursor: ew-resize;\\n}\\n.react-grid-item > .react-resizable-handle.react-resizable-handle-w {\\n  left: 0;\\n  transform: rotate(135deg);\\n}\\n.react-grid-item > .react-resizable-handle.react-resizable-handle-e {\\n  right: 0;\\n  transform: rotate(315deg);\\n}\\n.react-grid-item > .react-resizable-handle.react-resizable-handle-n,\\n.react-grid-item > .react-resizable-handle.react-resizable-handle-s {\\n  left: 50%;\\n  margin-left: -10px;\\n  cursor: ns-resize;\\n}\\n.react-grid-item > .react-resizable-handle.react-resizable-handle-n {\\n  top: 0;\\n  transform: rotate(225deg);\\n}\\n.react-grid-item > .react-resizable-handle.react-resizable-handle-s {\\n  bottom: 0;\\n  transform: rotate(45deg);\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2Nzcy9zdHlsZXMuY3NzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLWxheW91dC9jc3Mvc3R5bGVzLmNzcz9hZDZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgLnJlYWN0LWdyaWQtbGF5b3V0IHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB0cmFuc2l0aW9uOiBoZWlnaHQgMjAwbXMgZWFzZTtcbn1cbi5yZWFjdC1ncmlkLWl0ZW0ge1xuICB0cmFuc2l0aW9uOiBhbGwgMjAwbXMgZWFzZTtcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0O1xufVxuLnJlYWN0LWdyaWQtaXRlbSBpbWcge1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XG59XG4ucmVhY3QtZ3JpZC1pdGVtLmNzc1RyYW5zZm9ybXMge1xuICB0cmFuc2l0aW9uLXByb3BlcnR5OiB0cmFuc2Zvcm0sIHdpZHRoLCBoZWlnaHQ7XG59XG4ucmVhY3QtZ3JpZC1pdGVtLnJlc2l6aW5nIHtcbiAgdHJhbnNpdGlvbjogbm9uZTtcbiAgei1pbmRleDogMTtcbiAgd2lsbC1jaGFuZ2U6IHdpZHRoLCBoZWlnaHQ7XG59XG5cbi5yZWFjdC1ncmlkLWl0ZW0ucmVhY3QtZHJhZ2dhYmxlLWRyYWdnaW5nIHtcbiAgdHJhbnNpdGlvbjogbm9uZTtcbiAgei1pbmRleDogMztcbiAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcbn1cblxuLnJlYWN0LWdyaWQtaXRlbS5kcm9wcGluZyB7XG4gIHZpc2liaWxpdHk6IGhpZGRlbjtcbn1cblxuLnJlYWN0LWdyaWQtaXRlbS5yZWFjdC1ncmlkLXBsYWNlaG9sZGVyIHtcbiAgYmFja2dyb3VuZDogcmVkO1xuICBvcGFjaXR5OiAwLjI7XG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDEwMG1zO1xuICB6LWluZGV4OiAyO1xuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG4gIC1vLXVzZXItc2VsZWN0OiBub25lO1xuICB1c2VyLXNlbGVjdDogbm9uZTtcbn1cblxuLnJlYWN0LWdyaWQtaXRlbS5yZWFjdC1ncmlkLXBsYWNlaG9sZGVyLnBsYWNlaG9sZGVyLXJlc2l6aW5nIHtcbiAgdHJhbnNpdGlvbjogbm9uZTtcbn1cblxuLnJlYWN0LWdyaWQtaXRlbSA+IC5yZWFjdC1yZXNpemFibGUtaGFuZGxlIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB3aWR0aDogMjBweDtcbiAgaGVpZ2h0OiAyMHB4O1xufVxuXG4ucmVhY3QtZ3JpZC1pdGVtID4gLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGU6OmFmdGVyIHtcbiAgY29udGVudDogXCJcIjtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICByaWdodDogM3B4O1xuICBib3R0b206IDNweDtcbiAgd2lkdGg6IDVweDtcbiAgaGVpZ2h0OiA1cHg7XG4gIGJvcmRlci1yaWdodDogMnB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC40KTtcbiAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC40KTtcbn1cblxuLnJlYWN0LXJlc2l6YWJsZS1oaWRlID4gLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUge1xuICBkaXNwbGF5OiBub25lO1xufVxuXG4ucmVhY3QtZ3JpZC1pdGVtID4gLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUucmVhY3QtcmVzaXphYmxlLWhhbmRsZS1zdyB7XG4gIGJvdHRvbTogMDtcbiAgbGVmdDogMDtcbiAgY3Vyc29yOiBzdy1yZXNpemU7XG4gIHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcbn1cbi5yZWFjdC1ncmlkLWl0ZW0gPiAucmVhY3QtcmVzaXphYmxlLWhhbmRsZS5yZWFjdC1yZXNpemFibGUtaGFuZGxlLXNlIHtcbiAgYm90dG9tOiAwO1xuICByaWdodDogMDtcbiAgY3Vyc29yOiBzZS1yZXNpemU7XG59XG4ucmVhY3QtZ3JpZC1pdGVtID4gLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUucmVhY3QtcmVzaXphYmxlLWhhbmRsZS1udyB7XG4gIHRvcDogMDtcbiAgbGVmdDogMDtcbiAgY3Vyc29yOiBudy1yZXNpemU7XG4gIHRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XG59XG4ucmVhY3QtZ3JpZC1pdGVtID4gLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUucmVhY3QtcmVzaXphYmxlLWhhbmRsZS1uZSB7XG4gIHRvcDogMDtcbiAgcmlnaHQ6IDA7XG4gIGN1cnNvcjogbmUtcmVzaXplO1xuICB0cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpO1xufVxuLnJlYWN0LWdyaWQtaXRlbSA+IC5yZWFjdC1yZXNpemFibGUtaGFuZGxlLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtdyxcbi5yZWFjdC1ncmlkLWl0ZW0gPiAucmVhY3QtcmVzaXphYmxlLWhhbmRsZS5yZWFjdC1yZXNpemFibGUtaGFuZGxlLWUge1xuICB0b3A6IDUwJTtcbiAgbWFyZ2luLXRvcDogLTEwcHg7XG4gIGN1cnNvcjogZXctcmVzaXplO1xufVxuLnJlYWN0LWdyaWQtaXRlbSA+IC5yZWFjdC1yZXNpemFibGUtaGFuZGxlLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtdyB7XG4gIGxlZnQ6IDA7XG4gIHRyYW5zZm9ybTogcm90YXRlKDEzNWRlZyk7XG59XG4ucmVhY3QtZ3JpZC1pdGVtID4gLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUucmVhY3QtcmVzaXphYmxlLWhhbmRsZS1lIHtcbiAgcmlnaHQ6IDA7XG4gIHRyYW5zZm9ybTogcm90YXRlKDMxNWRlZyk7XG59XG4ucmVhY3QtZ3JpZC1pdGVtID4gLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUucmVhY3QtcmVzaXphYmxlLWhhbmRsZS1uLFxuLnJlYWN0LWdyaWQtaXRlbSA+IC5yZWFjdC1yZXNpemFibGUtaGFuZGxlLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtcyB7XG4gIGxlZnQ6IDUwJTtcbiAgbWFyZ2luLWxlZnQ6IC0xMHB4O1xuICBjdXJzb3I6IG5zLXJlc2l6ZTtcbn1cbi5yZWFjdC1ncmlkLWl0ZW0gPiAucmVhY3QtcmVzaXphYmxlLWhhbmRsZS5yZWFjdC1yZXNpemFibGUtaGFuZGxlLW4ge1xuICB0b3A6IDA7XG4gIHRyYW5zZm9ybTogcm90YXRlKDIyNWRlZyk7XG59XG4ucmVhY3QtZ3JpZC1pdGVtID4gLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUucmVhY3QtcmVzaXphYmxlLWhhbmRsZS1zIHtcbiAgYm90dG9tOiAwO1xuICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XG59XG5gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLWxheW91dC9jc3Mvc3R5bGVzLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLGtCQUFrQjtFQUNsQiw2QkFBNkI7QUFDL0I7QUFDQTtFQUNFLDBCQUEwQjtFQUMxQiw2Q0FBNkM7QUFDL0M7QUFDQTtFQUNFLG9CQUFvQjtFQUNwQixpQkFBaUI7QUFDbkI7QUFDQTtFQUNFLDZDQUE2QztBQUMvQztBQUNBO0VBQ0UsZ0JBQWdCO0VBQ2hCLFVBQVU7RUFDViwwQkFBMEI7QUFDNUI7O0FBRUE7RUFDRSxnQkFBZ0I7RUFDaEIsVUFBVTtFQUNWLHNCQUFzQjtBQUN4Qjs7QUFFQTtFQUNFLGtCQUFrQjtBQUNwQjs7QUFFQTtFQUNFLGVBQWU7RUFDZixZQUFZO0VBQ1osMEJBQTBCO0VBQzFCLFVBQVU7RUFDVix5QkFBeUI7RUFDekIsc0JBQXNCO0VBQ3RCLHFCQUFxQjtFQUNyQixvQkFBb0I7RUFDcEIsaUJBQWlCO0FBQ25COztBQUVBO0VBQ0UsZ0JBQWdCO0FBQ2xCOztBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLFdBQVc7RUFDWCxZQUFZO0FBQ2Q7O0FBRUE7RUFDRSxXQUFXO0VBQ1gsa0JBQWtCO0VBQ2xCLFVBQVU7RUFDVixXQUFXO0VBQ1gsVUFBVTtFQUNWLFdBQVc7RUFDWCwwQ0FBMEM7RUFDMUMsMkNBQTJDO0FBQzdDOztBQUVBO0VBQ0UsYUFBYTtBQUNmOztBQUVBO0VBQ0UsU0FBUztFQUNULE9BQU87RUFDUCxpQkFBaUI7RUFDakIsd0JBQXdCO0FBQzFCO0FBQ0E7RUFDRSxTQUFTO0VBQ1QsUUFBUTtFQUNSLGlCQUFpQjtBQUNuQjtBQUNBO0VBQ0UsTUFBTTtFQUNOLE9BQU87RUFDUCxpQkFBaUI7RUFDakIseUJBQXlCO0FBQzNCO0FBQ0E7RUFDRSxNQUFNO0VBQ04sUUFBUTtFQUNSLGlCQUFpQjtFQUNqQix5QkFBeUI7QUFDM0I7QUFDQTs7RUFFRSxRQUFRO0VBQ1IsaUJBQWlCO0VBQ2pCLGlCQUFpQjtBQUNuQjtBQUNBO0VBQ0UsT0FBTztFQUNQLHlCQUF5QjtBQUMzQjtBQUNBO0VBQ0UsUUFBUTtFQUNSLHlCQUF5QjtBQUMzQjtBQUNBOztFQUVFLFNBQVM7RUFDVCxrQkFBa0I7RUFDbEIsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSxNQUFNO0VBQ04seUJBQXlCO0FBQzNCO0FBQ0E7RUFDRSxTQUFTO0VBQ1Qsd0JBQXdCO0FBQzFCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5yZWFjdC1ncmlkLWxheW91dCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB0cmFuc2l0aW9uOiBoZWlnaHQgMjAwbXMgZWFzZTtcXG59XFxuLnJlYWN0LWdyaWQtaXRlbSB7XFxuICB0cmFuc2l0aW9uOiBhbGwgMjAwbXMgZWFzZTtcXG4gIHRyYW5zaXRpb24tcHJvcGVydHk6IGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodDtcXG59XFxuLnJlYWN0LWdyaWQtaXRlbSBpbWcge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuLnJlYWN0LWdyaWQtaXRlbS5jc3NUcmFuc2Zvcm1zIHtcXG4gIHRyYW5zaXRpb24tcHJvcGVydHk6IHRyYW5zZm9ybSwgd2lkdGgsIGhlaWdodDtcXG59XFxuLnJlYWN0LWdyaWQtaXRlbS5yZXNpemluZyB7XFxuICB0cmFuc2l0aW9uOiBub25lO1xcbiAgei1pbmRleDogMTtcXG4gIHdpbGwtY2hhbmdlOiB3aWR0aCwgaGVpZ2h0O1xcbn1cXG5cXG4ucmVhY3QtZ3JpZC1pdGVtLnJlYWN0LWRyYWdnYWJsZS1kcmFnZ2luZyB7XFxuICB0cmFuc2l0aW9uOiBub25lO1xcbiAgei1pbmRleDogMztcXG4gIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XFxufVxcblxcbi5yZWFjdC1ncmlkLWl0ZW0uZHJvcHBpbmcge1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbn1cXG5cXG4ucmVhY3QtZ3JpZC1pdGVtLnJlYWN0LWdyaWQtcGxhY2Vob2xkZXIge1xcbiAgYmFja2dyb3VuZDogcmVkO1xcbiAgb3BhY2l0eTogMC4yO1xcbiAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMTAwbXM7XFxuICB6LWluZGV4OiAyO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtby11c2VyLXNlbGVjdDogbm9uZTtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbn1cXG5cXG4ucmVhY3QtZ3JpZC1pdGVtLnJlYWN0LWdyaWQtcGxhY2Vob2xkZXIucGxhY2Vob2xkZXItcmVzaXppbmcge1xcbiAgdHJhbnNpdGlvbjogbm9uZTtcXG59XFxuXFxuLnJlYWN0LWdyaWQtaXRlbSA+IC5yZWFjdC1yZXNpemFibGUtaGFuZGxlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiAyMHB4O1xcbiAgaGVpZ2h0OiAyMHB4O1xcbn1cXG5cXG4ucmVhY3QtZ3JpZC1pdGVtID4gLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGU6OmFmdGVyIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgcmlnaHQ6IDNweDtcXG4gIGJvdHRvbTogM3B4O1xcbiAgd2lkdGg6IDVweDtcXG4gIGhlaWdodDogNXB4O1xcbiAgYm9yZGVyLXJpZ2h0OiAycHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjQpO1xcbiAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC40KTtcXG59XFxuXFxuLnJlYWN0LXJlc2l6YWJsZS1oaWRlID4gLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLnJlYWN0LWdyaWQtaXRlbSA+IC5yZWFjdC1yZXNpemFibGUtaGFuZGxlLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtc3cge1xcbiAgYm90dG9tOiAwO1xcbiAgbGVmdDogMDtcXG4gIGN1cnNvcjogc3ctcmVzaXplO1xcbiAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xcbn1cXG4ucmVhY3QtZ3JpZC1pdGVtID4gLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUucmVhY3QtcmVzaXphYmxlLWhhbmRsZS1zZSB7XFxuICBib3R0b206IDA7XFxuICByaWdodDogMDtcXG4gIGN1cnNvcjogc2UtcmVzaXplO1xcbn1cXG4ucmVhY3QtZ3JpZC1pdGVtID4gLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUucmVhY3QtcmVzaXphYmxlLWhhbmRsZS1udyB7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgY3Vyc29yOiBudy1yZXNpemU7XFxuICB0cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbn1cXG4ucmVhY3QtZ3JpZC1pdGVtID4gLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUucmVhY3QtcmVzaXphYmxlLWhhbmRsZS1uZSB7XFxuICB0b3A6IDA7XFxuICByaWdodDogMDtcXG4gIGN1cnNvcjogbmUtcmVzaXplO1xcbiAgdHJhbnNmb3JtOiByb3RhdGUoMjcwZGVnKTtcXG59XFxuLnJlYWN0LWdyaWQtaXRlbSA+IC5yZWFjdC1yZXNpemFibGUtaGFuZGxlLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtdyxcXG4ucmVhY3QtZ3JpZC1pdGVtID4gLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUucmVhY3QtcmVzaXphYmxlLWhhbmRsZS1lIHtcXG4gIHRvcDogNTAlO1xcbiAgbWFyZ2luLXRvcDogLTEwcHg7XFxuICBjdXJzb3I6IGV3LXJlc2l6ZTtcXG59XFxuLnJlYWN0LWdyaWQtaXRlbSA+IC5yZWFjdC1yZXNpemFibGUtaGFuZGxlLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtdyB7XFxuICBsZWZ0OiAwO1xcbiAgdHJhbnNmb3JtOiByb3RhdGUoMTM1ZGVnKTtcXG59XFxuLnJlYWN0LWdyaWQtaXRlbSA+IC5yZWFjdC1yZXNpemFibGUtaGFuZGxlLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtZSB7XFxuICByaWdodDogMDtcXG4gIHRyYW5zZm9ybTogcm90YXRlKDMxNWRlZyk7XFxufVxcbi5yZWFjdC1ncmlkLWl0ZW0gPiAucmVhY3QtcmVzaXphYmxlLWhhbmRsZS5yZWFjdC1yZXNpemFibGUtaGFuZGxlLW4sXFxuLnJlYWN0LWdyaWQtaXRlbSA+IC5yZWFjdC1yZXNpemFibGUtaGFuZGxlLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtcyB7XFxuICBsZWZ0OiA1MCU7XFxuICBtYXJnaW4tbGVmdDogLTEwcHg7XFxuICBjdXJzb3I6IG5zLXJlc2l6ZTtcXG59XFxuLnJlYWN0LWdyaWQtaXRlbSA+IC5yZWFjdC1yZXNpemFibGUtaGFuZGxlLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtbiB7XFxuICB0b3A6IDA7XFxuICB0cmFuc2Zvcm06IHJvdGF0ZSgyMjVkZWcpO1xcbn1cXG4ucmVhY3QtZ3JpZC1pdGVtID4gLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUucmVhY3QtcmVzaXphYmxlLWhhbmRsZS1zIHtcXG4gIGJvdHRvbTogMDtcXG4gIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/css-loader/dist/cjs.js!../../node_modules/react-grid-layout/css/styles.css\n");

/***/ }),

/***/ "../../node_modules/css-loader/dist/cjs.js!../../node_modules/react-resizable/css/styles.css":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/css-loader/dist/cjs.js!../../node_modules/react-resizable/css/styles.css ***!
  \***************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/sourceMaps.js */ \"../../node_modules/css-loader/dist/runtime/sourceMaps.js\");\n/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ \"../../node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../css-loader/dist/runtime/getUrl.js */ \"../../node_modules/css-loader/dist/runtime/getUrl.js\");\n/* harmony import */ var _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);\n// Imports\n\n\n\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2IDYiIHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOiNmZmZmZmYwMCIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSI2cHgiIGhlaWdodD0iNnB4Ij48ZyBvcGFjaXR5PSIwLjMwMiI+PHBhdGggZD0iTSA2IDYgTCAwIDYgTCAwIDQuMiBMIDQgNC4yIEwgNC4yIDQuMiBMIDQuMiAwIEwgNiAwIEwgNiA2IEwgNiA2IFoiIGZpbGw9IiMwMDAwMDAiLz48L2c+PC9zdmc+ */ \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2IDYiIHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOiNmZmZmZmYwMCIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSI2cHgiIGhlaWdodD0iNnB4Ij48ZyBvcGFjaXR5PSIwLjMwMiI+PHBhdGggZD0iTSA2IDYgTCAwIDYgTCAwIDQuMiBMIDQgNC4yIEwgNC4yIDQuMiBMIDQuMiAwIEwgNiAwIEwgNiA2IEwgNiA2IFoiIGZpbGw9IiMwMDAwMDAiLz48L2c+PC9zdmc+\"), __webpack_require__.b);\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.react-resizable {\n  position: relative;\n}\n.react-resizable-handle {\n  position: absolute;\n  width: 20px;\n  height: 20px;\n  background-repeat: no-repeat;\n  background-origin: content-box;\n  box-sizing: border-box;\n  background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});\n  background-position: bottom right;\n  padding: 0 3px 3px 0;\n}\n.react-resizable-handle-sw {\n  bottom: 0;\n  left: 0;\n  cursor: sw-resize;\n  transform: rotate(90deg);\n}\n.react-resizable-handle-se {\n  bottom: 0;\n  right: 0;\n  cursor: se-resize;\n}\n.react-resizable-handle-nw {\n  top: 0;\n  left: 0;\n  cursor: nw-resize;\n  transform: rotate(180deg);\n}\n.react-resizable-handle-ne {\n  top: 0;\n  right: 0;\n  cursor: ne-resize;\n  transform: rotate(270deg);\n}\n.react-resizable-handle-w,\n.react-resizable-handle-e {\n  top: 50%;\n  margin-top: -10px;\n  cursor: ew-resize;\n}\n.react-resizable-handle-w {\n  left: 0;\n  transform: rotate(135deg);\n}\n.react-resizable-handle-e {\n  right: 0;\n  transform: rotate(315deg);\n}\n.react-resizable-handle-n,\n.react-resizable-handle-s {\n  left: 50%;\n  margin-left: -10px;\n  cursor: ns-resize;\n}\n.react-resizable-handle-n {\n  top: 0;\n  transform: rotate(225deg);\n}\n.react-resizable-handle-s {\n  bottom: 0;\n  transform: rotate(45deg);\n}`, \"\",{\"version\":3,\"sources\":[\"webpack://./../../node_modules/react-resizable/css/styles.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,kBAAkB;AACpB;AACA;EACE,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,4BAA4B;EAC5B,8BAA8B;EAC9B,sBAAsB;EACtB,yDAAuY;EACvY,iCAAiC;EACjC,oBAAoB;AACtB;AACA;EACE,SAAS;EACT,OAAO;EACP,iBAAiB;EACjB,wBAAwB;AAC1B;AACA;EACE,SAAS;EACT,QAAQ;EACR,iBAAiB;AACnB;AACA;EACE,MAAM;EACN,OAAO;EACP,iBAAiB;EACjB,yBAAyB;AAC3B;AACA;EACE,MAAM;EACN,QAAQ;EACR,iBAAiB;EACjB,yBAAyB;AAC3B;AACA;;EAEE,QAAQ;EACR,iBAAiB;EACjB,iBAAiB;AACnB;AACA;EACE,OAAO;EACP,yBAAyB;AAC3B;AACA;EACE,QAAQ;EACR,yBAAyB;AAC3B;AACA;;EAEE,SAAS;EACT,kBAAkB;EAClB,iBAAiB;AACnB;AACA;EACE,MAAM;EACN,yBAAyB;AAC3B;AACA;EACE,SAAS;EACT,wBAAwB;AAC1B\",\"sourcesContent\":[\".react-resizable {\\n  position: relative;\\n}\\n.react-resizable-handle {\\n  position: absolute;\\n  width: 20px;\\n  height: 20px;\\n  background-repeat: no-repeat;\\n  background-origin: content-box;\\n  box-sizing: border-box;\\n  background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2IDYiIHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOiNmZmZmZmYwMCIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSI2cHgiIGhlaWdodD0iNnB4Ij48ZyBvcGFjaXR5PSIwLjMwMiI+PHBhdGggZD0iTSA2IDYgTCAwIDYgTCAwIDQuMiBMIDQgNC4yIEwgNC4yIDQuMiBMIDQuMiAwIEwgNiAwIEwgNiA2IEwgNiA2IFoiIGZpbGw9IiMwMDAwMDAiLz48L2c+PC9zdmc+');\\n  background-position: bottom right;\\n  padding: 0 3px 3px 0;\\n}\\n.react-resizable-handle-sw {\\n  bottom: 0;\\n  left: 0;\\n  cursor: sw-resize;\\n  transform: rotate(90deg);\\n}\\n.react-resizable-handle-se {\\n  bottom: 0;\\n  right: 0;\\n  cursor: se-resize;\\n}\\n.react-resizable-handle-nw {\\n  top: 0;\\n  left: 0;\\n  cursor: nw-resize;\\n  transform: rotate(180deg);\\n}\\n.react-resizable-handle-ne {\\n  top: 0;\\n  right: 0;\\n  cursor: ne-resize;\\n  transform: rotate(270deg);\\n}\\n.react-resizable-handle-w,\\n.react-resizable-handle-e {\\n  top: 50%;\\n  margin-top: -10px;\\n  cursor: ew-resize;\\n}\\n.react-resizable-handle-w {\\n  left: 0;\\n  transform: rotate(135deg);\\n}\\n.react-resizable-handle-e {\\n  right: 0;\\n  transform: rotate(315deg);\\n}\\n.react-resizable-handle-n,\\n.react-resizable-handle-s {\\n  left: 50%;\\n  margin-left: -10px;\\n  cursor: ns-resize;\\n}\\n.react-resizable-handle-n {\\n  top: 0;\\n  transform: rotate(225deg);\\n}\\n.react-resizable-handle-s {\\n  bottom: 0;\\n  transform: rotate(45deg);\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc2l6YWJsZS9jc3Mvc3R5bGVzLmNzcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9zdC8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzaXphYmxlL2Nzcy9zdHlsZXMuY3NzPzQ2N2YiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2dldFVybC5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fID0gbmV3IFVSTChcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIWnBaWGRDYjNnOUlqQWdNQ0EySURZaUlITjBlV3hsUFNKaVlXTnJaM0p2ZFc1a0xXTnZiRzl5T2lObVptWm1abVl3TUNJZ2VEMGlNSEI0SWlCNVBTSXdjSGdpSUhkcFpIUm9QU0kyY0hnaUlHaGxhV2RvZEQwaU5uQjRJajQ4WnlCdmNHRmphWFI1UFNJd0xqTXdNaUkrUEhCaGRHZ2daRDBpVFNBMklEWWdUQ0F3SURZZ1RDQXdJRFF1TWlCTUlEUWdOQzR5SUV3Z05DNHlJRFF1TWlCTUlEUXVNaUF3SUV3Z05pQXdJRXdnTmlBMklFd2dOaUEySUZvaUlHWnBiR3c5SWlNd01EQXdNREFpTHo0OEwyYytQQzl6ZG1jK1wiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgLnJlYWN0LXJlc2l6YWJsZSB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbn1cbi5yZWFjdC1yZXNpemFibGUtaGFuZGxlIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB3aWR0aDogMjBweDtcbiAgaGVpZ2h0OiAyMHB4O1xuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xuICBiYWNrZ3JvdW5kLW9yaWdpbjogY29udGVudC1ib3g7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgke19fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX199KTtcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogYm90dG9tIHJpZ2h0O1xuICBwYWRkaW5nOiAwIDNweCAzcHggMDtcbn1cbi5yZWFjdC1yZXNpemFibGUtaGFuZGxlLXN3IHtcbiAgYm90dG9tOiAwO1xuICBsZWZ0OiAwO1xuICBjdXJzb3I6IHN3LXJlc2l6ZTtcbiAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xufVxuLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtc2Uge1xuICBib3R0b206IDA7XG4gIHJpZ2h0OiAwO1xuICBjdXJzb3I6IHNlLXJlc2l6ZTtcbn1cbi5yZWFjdC1yZXNpemFibGUtaGFuZGxlLW53IHtcbiAgdG9wOiAwO1xuICBsZWZ0OiAwO1xuICBjdXJzb3I6IG53LXJlc2l6ZTtcbiAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcbn1cbi5yZWFjdC1yZXNpemFibGUtaGFuZGxlLW5lIHtcbiAgdG9wOiAwO1xuICByaWdodDogMDtcbiAgY3Vyc29yOiBuZS1yZXNpemU7XG4gIHRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7XG59XG4ucmVhY3QtcmVzaXphYmxlLWhhbmRsZS13LFxuLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtZSB7XG4gIHRvcDogNTAlO1xuICBtYXJnaW4tdG9wOiAtMTBweDtcbiAgY3Vyc29yOiBldy1yZXNpemU7XG59XG4ucmVhY3QtcmVzaXphYmxlLWhhbmRsZS13IHtcbiAgbGVmdDogMDtcbiAgdHJhbnNmb3JtOiByb3RhdGUoMTM1ZGVnKTtcbn1cbi5yZWFjdC1yZXNpemFibGUtaGFuZGxlLWUge1xuICByaWdodDogMDtcbiAgdHJhbnNmb3JtOiByb3RhdGUoMzE1ZGVnKTtcbn1cbi5yZWFjdC1yZXNpemFibGUtaGFuZGxlLW4sXG4ucmVhY3QtcmVzaXphYmxlLWhhbmRsZS1zIHtcbiAgbGVmdDogNTAlO1xuICBtYXJnaW4tbGVmdDogLTEwcHg7XG4gIGN1cnNvcjogbnMtcmVzaXplO1xufVxuLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtbiB7XG4gIHRvcDogMDtcbiAgdHJhbnNmb3JtOiByb3RhdGUoMjI1ZGVnKTtcbn1cbi5yZWFjdC1yZXNpemFibGUtaGFuZGxlLXMge1xuICBib3R0b206IDA7XG4gIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcbn1gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNpemFibGUvY3NzL3N0eWxlcy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxrQkFBa0I7QUFDcEI7QUFDQTtFQUNFLGtCQUFrQjtFQUNsQixXQUFXO0VBQ1gsWUFBWTtFQUNaLDRCQUE0QjtFQUM1Qiw4QkFBOEI7RUFDOUIsc0JBQXNCO0VBQ3RCLHlEQUF1WTtFQUN2WSxpQ0FBaUM7RUFDakMsb0JBQW9CO0FBQ3RCO0FBQ0E7RUFDRSxTQUFTO0VBQ1QsT0FBTztFQUNQLGlCQUFpQjtFQUNqQix3QkFBd0I7QUFDMUI7QUFDQTtFQUNFLFNBQVM7RUFDVCxRQUFRO0VBQ1IsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSxNQUFNO0VBQ04sT0FBTztFQUNQLGlCQUFpQjtFQUNqQix5QkFBeUI7QUFDM0I7QUFDQTtFQUNFLE1BQU07RUFDTixRQUFRO0VBQ1IsaUJBQWlCO0VBQ2pCLHlCQUF5QjtBQUMzQjtBQUNBOztFQUVFLFFBQVE7RUFDUixpQkFBaUI7RUFDakIsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSxPQUFPO0VBQ1AseUJBQXlCO0FBQzNCO0FBQ0E7RUFDRSxRQUFRO0VBQ1IseUJBQXlCO0FBQzNCO0FBQ0E7O0VBRUUsU0FBUztFQUNULGtCQUFrQjtFQUNsQixpQkFBaUI7QUFDbkI7QUFDQTtFQUNFLE1BQU07RUFDTix5QkFBeUI7QUFDM0I7QUFDQTtFQUNFLFNBQVM7RUFDVCx3QkFBd0I7QUFDMUJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnJlYWN0LXJlc2l6YWJsZSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbi5yZWFjdC1yZXNpemFibGUtaGFuZGxlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiAyMHB4O1xcbiAgaGVpZ2h0OiAyMHB4O1xcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gIGJhY2tncm91bmQtb3JpZ2luOiBjb250ZW50LWJveDtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIWnBaWGRDYjNnOUlqQWdNQ0EySURZaUlITjBlV3hsUFNKaVlXTnJaM0p2ZFc1a0xXTnZiRzl5T2lObVptWm1abVl3TUNJZ2VEMGlNSEI0SWlCNVBTSXdjSGdpSUhkcFpIUm9QU0kyY0hnaUlHaGxhV2RvZEQwaU5uQjRJajQ4WnlCdmNHRmphWFI1UFNJd0xqTXdNaUkrUEhCaGRHZ2daRDBpVFNBMklEWWdUQ0F3SURZZ1RDQXdJRFF1TWlCTUlEUWdOQzR5SUV3Z05DNHlJRFF1TWlCTUlEUXVNaUF3SUV3Z05pQXdJRXdnTmlBMklFd2dOaUEySUZvaUlHWnBiR3c5SWlNd01EQXdNREFpTHo0OEwyYytQQzl6ZG1jKycpO1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogYm90dG9tIHJpZ2h0O1xcbiAgcGFkZGluZzogMCAzcHggM3B4IDA7XFxufVxcbi5yZWFjdC1yZXNpemFibGUtaGFuZGxlLXN3IHtcXG4gIGJvdHRvbTogMDtcXG4gIGxlZnQ6IDA7XFxuICBjdXJzb3I6IHN3LXJlc2l6ZTtcXG4gIHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcXG59XFxuLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtc2Uge1xcbiAgYm90dG9tOiAwO1xcbiAgcmlnaHQ6IDA7XFxuICBjdXJzb3I6IHNlLXJlc2l6ZTtcXG59XFxuLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtbncge1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIGN1cnNvcjogbnctcmVzaXplO1xcbiAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcXG59XFxuLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtbmUge1xcbiAgdG9wOiAwO1xcbiAgcmlnaHQ6IDA7XFxuICBjdXJzb3I6IG5lLXJlc2l6ZTtcXG4gIHRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7XFxufVxcbi5yZWFjdC1yZXNpemFibGUtaGFuZGxlLXcsXFxuLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtZSB7XFxuICB0b3A6IDUwJTtcXG4gIG1hcmdpbi10b3A6IC0xMHB4O1xcbiAgY3Vyc29yOiBldy1yZXNpemU7XFxufVxcbi5yZWFjdC1yZXNpemFibGUtaGFuZGxlLXcge1xcbiAgbGVmdDogMDtcXG4gIHRyYW5zZm9ybTogcm90YXRlKDEzNWRlZyk7XFxufVxcbi5yZWFjdC1yZXNpemFibGUtaGFuZGxlLWUge1xcbiAgcmlnaHQ6IDA7XFxuICB0cmFuc2Zvcm06IHJvdGF0ZSgzMTVkZWcpO1xcbn1cXG4ucmVhY3QtcmVzaXphYmxlLWhhbmRsZS1uLFxcbi5yZWFjdC1yZXNpemFibGUtaGFuZGxlLXMge1xcbiAgbGVmdDogNTAlO1xcbiAgbWFyZ2luLWxlZnQ6IC0xMHB4O1xcbiAgY3Vyc29yOiBucy1yZXNpemU7XFxufVxcbi5yZWFjdC1yZXNpemFibGUtaGFuZGxlLW4ge1xcbiAgdG9wOiAwO1xcbiAgdHJhbnNmb3JtOiByb3RhdGUoMjI1ZGVnKTtcXG59XFxuLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtcyB7XFxuICBib3R0b206IDA7XFxuICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/css-loader/dist/cjs.js!../../node_modules/react-resizable/css/styles.css\n");

/***/ }),

/***/ "../../node_modules/css-loader/dist/runtime/getUrl.js":
/*!************************************************************!*\
  !*** ../../node_modules/css-loader/dist/runtime/getUrl.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    options = {};\n  }\n  if (!url) {\n    return url;\n  }\n  url = String(url.__esModule ? url.default : url);\n\n  // If url is already wrapped in quotes, remove them\n  if (/^['\"].*['\"]$/.test(url)) {\n    url = url.slice(1, -1);\n  }\n  if (options.hash) {\n    url += options.hash;\n  }\n\n  // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n  if (/[\"'() \\t\\n]|(%20)/.test(url) || options.needQuotes) {\n    return \"\\\"\".concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\"), \"\\\"\");\n  }\n  return url;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2dldFVybC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9zdC8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzP2E2YzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIHVybCA9IFN0cmluZyh1cmwuX19lc01vZHVsZSA/IHVybC5kZWZhdWx0IDogdXJsKTtcblxuICAvLyBJZiB1cmwgaXMgYWxyZWFkeSB3cmFwcGVkIGluIHF1b3RlcywgcmVtb3ZlIHRoZW1cbiAgaWYgKC9eWydcIl0uKlsnXCJdJC8udGVzdCh1cmwpKSB7XG4gICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgfVxuICBpZiAob3B0aW9ucy5oYXNoKSB7XG4gICAgdXJsICs9IG9wdGlvbnMuaGFzaDtcbiAgfVxuXG4gIC8vIFNob3VsZCB1cmwgYmUgd3JhcHBlZD9cbiAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcbiAgaWYgKC9bXCInKCkgXFx0XFxuXXwoJTIwKS8udGVzdCh1cmwpIHx8IG9wdGlvbnMubmVlZFF1b3Rlcykge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQodXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKSwgXCJcXFwiXCIpO1xuICB9XG4gIHJldHVybiB1cmw7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/css-loader/dist/runtime/getUrl.js\n");

/***/ }),

/***/ "../../node_modules/fast-equals/dist/fast-equals.js":
/*!**********************************************************!*\
  !*** ../../node_modules/fast-equals/dist/fast-equals.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function (global, factory) {\n   true ? factory(exports) :\n  0;\n})(this, (function (exports) { 'use strict';\n\n  /**\r\n   * Default equality comparator pass-through, used as the standard `isEqual` creator for\r\n   * use inside the built comparator.\r\n   */\r\n  function createDefaultIsNestedEqual(comparator) {\r\n      return function isEqual(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, meta) {\r\n          return comparator(a, b, meta);\r\n      };\r\n  }\r\n  /**\r\n   * Wrap the provided `areItemsEqual` method to manage the circular cache, allowing\r\n   * for circular references to be safely included in the comparison without creating\r\n   * stack overflows.\r\n   */\r\n  function createIsCircular(areItemsEqual) {\r\n      return function isCircular(a, b, isEqual, cache) {\r\n          if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\r\n              return areItemsEqual(a, b, isEqual, cache);\r\n          }\r\n          var cachedA = cache.get(a);\r\n          var cachedB = cache.get(b);\r\n          if (cachedA && cachedB) {\r\n              return cachedA === b && cachedB === a;\r\n          }\r\n          cache.set(a, b);\r\n          cache.set(b, a);\r\n          var result = areItemsEqual(a, b, isEqual, cache);\r\n          cache.delete(a);\r\n          cache.delete(b);\r\n          return result;\r\n      };\r\n  }\r\n  /**\r\n   * Targeted shallow merge of two objects.\r\n   *\r\n   * @NOTE\r\n   * This exists as a tinier compiled version of the `__assign` helper that\r\n   * `tsc` injects in case of `Object.assign` not being present.\r\n   */\r\n  function merge(a, b) {\r\n      var merged = {};\r\n      for (var key in a) {\r\n          merged[key] = a[key];\r\n      }\r\n      for (var key in b) {\r\n          merged[key] = b[key];\r\n      }\r\n      return merged;\r\n  }\r\n  /**\r\n   * Whether the value is a plain object.\r\n   *\r\n   * @NOTE\r\n   * This is a same-realm compariosn only.\r\n   */\r\n  function isPlainObject(value) {\r\n      return value.constructor === Object || value.constructor == null;\r\n  }\r\n  /**\r\n   * When the value is `Promise`-like, aka \"then-able\".\r\n   */\r\n  function isPromiseLike(value) {\r\n      return typeof value.then === 'function';\r\n  }\r\n  /**\r\n   * Whether the values passed are strictly equal or both NaN.\r\n   */\r\n  function sameValueZeroEqual(a, b) {\r\n      return a === b || (a !== a && b !== b);\r\n  }\n\n  var ARGUMENTS_TAG = '[object Arguments]';\r\n  var BOOLEAN_TAG = '[object Boolean]';\r\n  var DATE_TAG = '[object Date]';\r\n  var REG_EXP_TAG = '[object RegExp]';\r\n  var MAP_TAG = '[object Map]';\r\n  var NUMBER_TAG = '[object Number]';\r\n  var OBJECT_TAG = '[object Object]';\r\n  var SET_TAG = '[object Set]';\r\n  var STRING_TAG = '[object String]';\r\n  var toString = Object.prototype.toString;\r\n  function createComparator(_a) {\r\n      var areArraysEqual = _a.areArraysEqual, areDatesEqual = _a.areDatesEqual, areMapsEqual = _a.areMapsEqual, areObjectsEqual = _a.areObjectsEqual, areRegExpsEqual = _a.areRegExpsEqual, areSetsEqual = _a.areSetsEqual, createIsNestedEqual = _a.createIsNestedEqual;\r\n      var isEqual = createIsNestedEqual(comparator);\r\n      /**\r\n       * compare the value of the two objects and return true if they are equivalent in values\r\n       */\r\n      function comparator(a, b, meta) {\r\n          // If the items are strictly equal, no need to do a value comparison.\r\n          if (a === b) {\r\n              return true;\r\n          }\r\n          // If the items are not non-nullish objects, then the only possibility\r\n          // of them being equal but not strictly is if they are both `NaN`. Since\r\n          // `NaN` is uniquely not equal to itself, we can use self-comparison of\r\n          // both objects, which is faster than `isNaN()`.\r\n          if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\r\n              return a !== a && b !== b;\r\n          }\r\n          // Checks are listed in order of commonality of use-case:\r\n          //   1. Common complex object types (plain object, array)\r\n          //   2. Common data values (date, regexp)\r\n          //   3. Less-common complex object types (map, set)\r\n          //   4. Less-common data values (promise, primitive wrappers)\r\n          // Inherently this is both subjective and assumptive, however\r\n          // when reviewing comparable libraries in the wild this order\r\n          // appears to be generally consistent.\r\n          // `isPlainObject` only checks against the object's own realm. Cross-realm\r\n          // comparisons are rare, and will be handled in the ultimate fallback, so\r\n          // we can avoid the `toString.call()` cost unless necessary.\r\n          if (isPlainObject(a) && isPlainObject(b)) {\r\n              return areObjectsEqual(a, b, isEqual, meta);\r\n          }\r\n          // `isArray()` works on subclasses and is cross-realm, so we can again avoid\r\n          // the `toString.call()` cost unless necessary by just checking if either\r\n          // and then both are arrays.\r\n          var aArray = Array.isArray(a);\r\n          var bArray = Array.isArray(b);\r\n          if (aArray || bArray) {\r\n              return aArray === bArray && areArraysEqual(a, b, isEqual, meta);\r\n          }\r\n          // Since this is a custom object, use the classic `toString.call()` to get its\r\n          // type. This is reasonably performant in modern environments like v8 and\r\n          // SpiderMonkey, and allows for cross-realm comparison when other checks like\r\n          // `instanceof` do not.\r\n          var aTag = toString.call(a);\r\n          if (aTag !== toString.call(b)) {\r\n              return false;\r\n          }\r\n          if (aTag === DATE_TAG) {\r\n              // `getTime()` showed better results compared to alternatives like `valueOf()`\r\n              // or the unary `+` operator.\r\n              return areDatesEqual(a, b, isEqual, meta);\r\n          }\r\n          if (aTag === REG_EXP_TAG) {\r\n              return areRegExpsEqual(a, b, isEqual, meta);\r\n          }\r\n          if (aTag === MAP_TAG) {\r\n              return areMapsEqual(a, b, isEqual, meta);\r\n          }\r\n          if (aTag === SET_TAG) {\r\n              return areSetsEqual(a, b, isEqual, meta);\r\n          }\r\n          // If a simple object tag, then we can prioritize a simple object comparison because\r\n          // it is likely a custom class. If an arguments tag, it should be treated as a standard\r\n          // object.\r\n          if (aTag === OBJECT_TAG || aTag === ARGUMENTS_TAG) {\r\n              // The exception for value comparison is `Promise`-like contracts. These should be\r\n              // treated the same as standard `Promise` objects, which means strict equality.\r\n              return isPromiseLike(a) || isPromiseLike(b)\r\n                  ? false\r\n                  : areObjectsEqual(a, b, isEqual, meta);\r\n          }\r\n          // As the penultimate fallback, check if the values passed are primitive wrappers. This\r\n          // is very rare in modern JS, which is why it is deprioritized compared to all other object\r\n          // types.\r\n          if (aTag === BOOLEAN_TAG || aTag === NUMBER_TAG || aTag === STRING_TAG) {\r\n              return sameValueZeroEqual(a.valueOf(), b.valueOf());\r\n          }\r\n          // If not matching any tags that require a specific type of comparison, then we hard-code false because\r\n          // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\r\n          //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\r\n          //     comparison that can be made.\r\n          //   - For types that can be introspected, but rarely have requirements to be compared\r\n          //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\r\n          //     use-cases (may be included in a future release, if requested enough).\r\n          //   - For types that can be introspected but do not have an objective definition of what\r\n          //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\r\n          // In all cases, these decisions should be reevaluated based on changes to the language and\r\n          // common development practices.\r\n          return false;\r\n      }\r\n      return comparator;\r\n  }\n\n  /**\r\n   * Whether the arrays are equal in value.\r\n   */\r\n  function areArraysEqual(a, b, isEqual, meta) {\r\n      var index = a.length;\r\n      if (b.length !== index) {\r\n          return false;\r\n      }\r\n      // Decrementing `while` showed faster results than either incrementing or\r\n      // decrementing `for` loop and than an incrementing `while` loop. Declarative\r\n      // methods like `some` / `every` were not used to avoid incurring the garbage\r\n      // cost of anonymous callbacks.\r\n      while (index-- > 0) {\r\n          if (!isEqual(a[index], b[index], index, index, a, b, meta)) {\r\n              return false;\r\n          }\r\n      }\r\n      return true;\r\n  }\r\n  /**\r\n   * Whether the arrays are equal in value, including circular references.\r\n   */\r\n  var areArraysEqualCircular = createIsCircular(areArraysEqual);\n\n  /**\r\n   * Whether the dates passed are equal in value.\r\n   *\r\n   * @NOTE\r\n   * This is a standalone function instead of done inline in the comparator\r\n   * to allow for overrides.\r\n   */\r\n  function areDatesEqual(a, b) {\r\n      return sameValueZeroEqual(a.valueOf(), b.valueOf());\r\n  }\n\n  /**\r\n   * Whether the `Map`s are equal in value.\r\n   */\r\n  function areMapsEqual(a, b, isEqual, meta) {\r\n      var isValueEqual = a.size === b.size;\r\n      if (!isValueEqual) {\r\n          return false;\r\n      }\r\n      if (!a.size) {\r\n          return true;\r\n      }\r\n      // The use of `forEach()` is to avoid the transpilation cost of `for...of` comparisons, and\r\n      // the inability to control the performance of the resulting code. It also avoids excessive\r\n      // iteration compared to doing comparisons of `keys()` and `values()`. As a result, though,\r\n      // we cannot short-circuit the iterations; bookkeeping must be done to short-circuit the\r\n      // equality checks themselves.\r\n      var matchedIndices = {};\r\n      var indexA = 0;\r\n      a.forEach(function (aValue, aKey) {\r\n          if (!isValueEqual) {\r\n              return;\r\n          }\r\n          var hasMatch = false;\r\n          var matchIndexB = 0;\r\n          b.forEach(function (bValue, bKey) {\r\n              if (!hasMatch &&\r\n                  !matchedIndices[matchIndexB] &&\r\n                  (hasMatch =\r\n                      isEqual(aKey, bKey, indexA, matchIndexB, a, b, meta) &&\r\n                          isEqual(aValue, bValue, aKey, bKey, a, b, meta))) {\r\n                  matchedIndices[matchIndexB] = true;\r\n              }\r\n              matchIndexB++;\r\n          });\r\n          indexA++;\r\n          isValueEqual = hasMatch;\r\n      });\r\n      return isValueEqual;\r\n  }\r\n  /**\r\n   * Whether the `Map`s are equal in value, including circular references.\r\n   */\r\n  var areMapsEqualCircular = createIsCircular(areMapsEqual);\n\n  var OWNER = '_owner';\r\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n  /**\r\n   * Whether the objects are equal in value.\r\n   */\r\n  function areObjectsEqual(a, b, isEqual, meta) {\r\n      var keysA = Object.keys(a);\r\n      var index = keysA.length;\r\n      if (Object.keys(b).length !== index) {\r\n          return false;\r\n      }\r\n      var key;\r\n      // Decrementing `while` showed faster results than either incrementing or\r\n      // decrementing `for` loop and than an incrementing `while` loop. Declarative\r\n      // methods like `some` / `every` were not used to avoid incurring the garbage\r\n      // cost of anonymous callbacks.\r\n      while (index-- > 0) {\r\n          key = keysA[index];\r\n          if (key === OWNER) {\r\n              var reactElementA = !!a.$$typeof;\r\n              var reactElementB = !!b.$$typeof;\r\n              if ((reactElementA || reactElementB) && reactElementA !== reactElementB) {\r\n                  return false;\r\n              }\r\n          }\r\n          if (!hasOwnProperty.call(b, key) ||\r\n              !isEqual(a[key], b[key], key, key, a, b, meta)) {\r\n              return false;\r\n          }\r\n      }\r\n      return true;\r\n  }\r\n  /**\r\n   * Whether the objects are equal in value, including circular references.\r\n   */\r\n  var areObjectsEqualCircular = createIsCircular(areObjectsEqual);\n\n  /**\r\n   * Whether the regexps passed are equal in value.\r\n   *\r\n   * @NOTE\r\n   * This is a standalone function instead of done inline in the comparator\r\n   * to allow for overrides. An example of this would be supporting a\r\n   * pre-ES2015 environment where the `flags` property is not available.\r\n   */\r\n  function areRegExpsEqual(a, b) {\r\n      return a.source === b.source && a.flags === b.flags;\r\n  }\n\n  /**\r\n   * Whether the `Set`s are equal in value.\r\n   */\r\n  function areSetsEqual(a, b, isEqual, meta) {\r\n      var isValueEqual = a.size === b.size;\r\n      if (!isValueEqual) {\r\n          return false;\r\n      }\r\n      if (!a.size) {\r\n          return true;\r\n      }\r\n      // The use of `forEach()` is to avoid the transpilation cost of `for...of` comparisons, and\r\n      // the inability to control the performance of the resulting code. It also avoids excessive\r\n      // iteration compared to doing comparisons of `keys()` and `values()`. As a result, though,\r\n      // we cannot short-circuit the iterations; bookkeeping must be done to short-circuit the\r\n      // equality checks themselves.\r\n      var matchedIndices = {};\r\n      a.forEach(function (aValue, aKey) {\r\n          if (!isValueEqual) {\r\n              return;\r\n          }\r\n          var hasMatch = false;\r\n          var matchIndex = 0;\r\n          b.forEach(function (bValue, bKey) {\r\n              if (!hasMatch &&\r\n                  !matchedIndices[matchIndex] &&\r\n                  (hasMatch = isEqual(aValue, bValue, aKey, bKey, a, b, meta))) {\r\n                  matchedIndices[matchIndex] = true;\r\n              }\r\n              matchIndex++;\r\n          });\r\n          isValueEqual = hasMatch;\r\n      });\r\n      return isValueEqual;\r\n  }\r\n  /**\r\n   * Whether the `Set`s are equal in value, including circular references.\r\n   */\r\n  var areSetsEqualCircular = createIsCircular(areSetsEqual);\n\n  var DEFAULT_CONFIG = Object.freeze({\r\n      areArraysEqual: areArraysEqual,\r\n      areDatesEqual: areDatesEqual,\r\n      areMapsEqual: areMapsEqual,\r\n      areObjectsEqual: areObjectsEqual,\r\n      areRegExpsEqual: areRegExpsEqual,\r\n      areSetsEqual: areSetsEqual,\r\n      createIsNestedEqual: createDefaultIsNestedEqual,\r\n  });\r\n  var DEFAULT_CIRCULAR_CONFIG = Object.freeze({\r\n      areArraysEqual: areArraysEqualCircular,\r\n      areDatesEqual: areDatesEqual,\r\n      areMapsEqual: areMapsEqualCircular,\r\n      areObjectsEqual: areObjectsEqualCircular,\r\n      areRegExpsEqual: areRegExpsEqual,\r\n      areSetsEqual: areSetsEqualCircular,\r\n      createIsNestedEqual: createDefaultIsNestedEqual,\r\n  });\r\n  var isDeepEqual = createComparator(DEFAULT_CONFIG);\r\n  /**\r\n   * Whether the items passed are deeply-equal in value.\r\n   */\r\n  function deepEqual(a, b) {\r\n      return isDeepEqual(a, b, undefined);\r\n  }\r\n  var isShallowEqual = createComparator(merge(DEFAULT_CONFIG, { createIsNestedEqual: function () { return sameValueZeroEqual; } }));\r\n  /**\r\n   * Whether the items passed are shallowly-equal in value.\r\n   */\r\n  function shallowEqual(a, b) {\r\n      return isShallowEqual(a, b, undefined);\r\n  }\r\n  var isCircularDeepEqual = createComparator(DEFAULT_CIRCULAR_CONFIG);\r\n  /**\r\n   * Whether the items passed are deeply-equal in value, including circular references.\r\n   */\r\n  function circularDeepEqual(a, b) {\r\n      return isCircularDeepEqual(a, b, new WeakMap());\r\n  }\r\n  var isCircularShallowEqual = createComparator(merge(DEFAULT_CIRCULAR_CONFIG, {\r\n      createIsNestedEqual: function () { return sameValueZeroEqual; },\r\n  }));\r\n  /**\r\n   * Whether the items passed are shallowly-equal in value, including circular references.\r\n   */\r\n  function circularShallowEqual(a, b) {\r\n      return isCircularShallowEqual(a, b, new WeakMap());\r\n  }\r\n  /**\r\n   * Create a custom equality comparison method.\r\n   *\r\n   * This can be done to create very targeted comparisons in extreme hot-path scenarios\r\n   * where the standard methods are not performant enough, but can also be used to provide\r\n   * support for legacy environments that do not support expected features like\r\n   * `RegExp.prototype.flags` out of the box.\r\n   */\r\n  function createCustomEqual(getComparatorOptions) {\r\n      return createComparator(merge(DEFAULT_CONFIG, getComparatorOptions(DEFAULT_CONFIG)));\r\n  }\r\n  /**\r\n   * Create a custom equality comparison method that handles circular references. This is very\r\n   * similar to `createCustomEqual`, with the only difference being that `meta` expects to be\r\n   * populated with a `WeakMap`-like contract.\r\n   *\r\n   * This can be done to create very targeted comparisons in extreme hot-path scenarios\r\n   * where the standard methods are not performant enough, but can also be used to provide\r\n   * support for legacy environments that do not support expected features like\r\n   * `WeakMap` out of the box.\r\n   */\r\n  function createCustomCircularEqual(getComparatorOptions) {\r\n      var comparator = createComparator(merge(DEFAULT_CIRCULAR_CONFIG, getComparatorOptions(DEFAULT_CIRCULAR_CONFIG)));\r\n      return (function (a, b, meta) {\r\n          if (meta === void 0) { meta = new WeakMap(); }\r\n          return comparator(a, b, meta);\r\n      });\r\n  }\n\n  exports.circularDeepEqual = circularDeepEqual;\n  exports.circularShallowEqual = circularShallowEqual;\n  exports.createCustomCircularEqual = createCustomCircularEqual;\n  exports.createCustomEqual = createCustomEqual;\n  exports.deepEqual = deepEqual;\n  exports.sameValueZeroEqual = sameValueZeroEqual;\n  exports.shallowEqual = shallowEqual;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=fast-equals.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2Zhc3QtZXF1YWxzL2Rpc3QvZmFzdC1lcXVhbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL2Zhc3QtZXF1YWxzL2Rpc3QvZmFzdC1lcXVhbHMuanM/NjhhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsW1wiZmFzdC1lcXVhbHNcIl0gPSB7fSkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvKipcclxuICAgKiBEZWZhdWx0IGVxdWFsaXR5IGNvbXBhcmF0b3IgcGFzcy10aHJvdWdoLCB1c2VkIGFzIHRoZSBzdGFuZGFyZCBgaXNFcXVhbGAgY3JlYXRvciBmb3JcclxuICAgKiB1c2UgaW5zaWRlIHRoZSBidWlsdCBjb21wYXJhdG9yLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRJc05lc3RlZEVxdWFsKGNvbXBhcmF0b3IpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYiwgX2luZGV4T3JLZXlBLCBfaW5kZXhPcktleUIsIF9wYXJlbnRBLCBfcGFyZW50QiwgbWV0YSkge1xyXG4gICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3IoYSwgYiwgbWV0YSk7XHJcbiAgICAgIH07XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFdyYXAgdGhlIHByb3ZpZGVkIGBhcmVJdGVtc0VxdWFsYCBtZXRob2QgdG8gbWFuYWdlIHRoZSBjaXJjdWxhciBjYWNoZSwgYWxsb3dpbmdcclxuICAgKiBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyB0byBiZSBzYWZlbHkgaW5jbHVkZWQgaW4gdGhlIGNvbXBhcmlzb24gd2l0aG91dCBjcmVhdGluZ1xyXG4gICAqIHN0YWNrIG92ZXJmbG93cy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjcmVhdGVJc0NpcmN1bGFyKGFyZUl0ZW1zRXF1YWwpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzQ2lyY3VsYXIoYSwgYiwgaXNFcXVhbCwgY2FjaGUpIHtcclxuICAgICAgICAgIGlmICghYSB8fCAhYiB8fCB0eXBlb2YgYSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGFyZUl0ZW1zRXF1YWwoYSwgYiwgaXNFcXVhbCwgY2FjaGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFyIGNhY2hlZEEgPSBjYWNoZS5nZXQoYSk7XHJcbiAgICAgICAgICB2YXIgY2FjaGVkQiA9IGNhY2hlLmdldChiKTtcclxuICAgICAgICAgIGlmIChjYWNoZWRBICYmIGNhY2hlZEIpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkQSA9PT0gYiAmJiBjYWNoZWRCID09PSBhO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY2FjaGUuc2V0KGEsIGIpO1xyXG4gICAgICAgICAgY2FjaGUuc2V0KGIsIGEpO1xyXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGFyZUl0ZW1zRXF1YWwoYSwgYiwgaXNFcXVhbCwgY2FjaGUpO1xyXG4gICAgICAgICAgY2FjaGUuZGVsZXRlKGEpO1xyXG4gICAgICAgICAgY2FjaGUuZGVsZXRlKGIpO1xyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogVGFyZ2V0ZWQgc2hhbGxvdyBtZXJnZSBvZiB0d28gb2JqZWN0cy5cclxuICAgKlxyXG4gICAqIEBOT1RFXHJcbiAgICogVGhpcyBleGlzdHMgYXMgYSB0aW5pZXIgY29tcGlsZWQgdmVyc2lvbiBvZiB0aGUgYF9fYXNzaWduYCBoZWxwZXIgdGhhdFxyXG4gICAqIGB0c2NgIGluamVjdHMgaW4gY2FzZSBvZiBgT2JqZWN0LmFzc2lnbmAgbm90IGJlaW5nIHByZXNlbnQuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xyXG4gICAgICB2YXIgbWVyZ2VkID0ge307XHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBhKSB7XHJcbiAgICAgICAgICBtZXJnZWRba2V5XSA9IGFba2V5XTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKHZhciBrZXkgaW4gYikge1xyXG4gICAgICAgICAgbWVyZ2VkW2tleV0gPSBiW2tleV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG1lcmdlZDtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXHJcbiAgICpcclxuICAgKiBATk9URVxyXG4gICAqIFRoaXMgaXMgYSBzYW1lLXJlYWxtIGNvbXBhcmlvc24gb25seS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0IHx8IHZhbHVlLmNvbnN0cnVjdG9yID09IG51bGw7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFdoZW4gdGhlIHZhbHVlIGlzIGBQcm9taXNlYC1saWtlLCBha2EgXCJ0aGVuLWFibGVcIi5cclxuICAgKi9cclxuICBmdW5jdGlvbiBpc1Byb21pc2VMaWtlKHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcclxuICB9XHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgdmFsdWVzIHBhc3NlZCBhcmUgc3RyaWN0bHkgZXF1YWwgb3IgYm90aCBOYU4uXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gc2FtZVZhbHVlWmVyb0VxdWFsKGEsIGIpIHtcclxuICAgICAgcmV0dXJuIGEgPT09IGIgfHwgKGEgIT09IGEgJiYgYiAhPT0gYik7XHJcbiAgfVxuXG4gIHZhciBBUkdVTUVOVFNfVEFHID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XHJcbiAgdmFyIEJPT0xFQU5fVEFHID0gJ1tvYmplY3QgQm9vbGVhbl0nO1xyXG4gIHZhciBEQVRFX1RBRyA9ICdbb2JqZWN0IERhdGVdJztcclxuICB2YXIgUkVHX0VYUF9UQUcgPSAnW29iamVjdCBSZWdFeHBdJztcclxuICB2YXIgTUFQX1RBRyA9ICdbb2JqZWN0IE1hcF0nO1xyXG4gIHZhciBOVU1CRVJfVEFHID0gJ1tvYmplY3QgTnVtYmVyXSc7XHJcbiAgdmFyIE9CSkVDVF9UQUcgPSAnW29iamVjdCBPYmplY3RdJztcclxuICB2YXIgU0VUX1RBRyA9ICdbb2JqZWN0IFNldF0nO1xyXG4gIHZhciBTVFJJTkdfVEFHID0gJ1tvYmplY3QgU3RyaW5nXSc7XHJcbiAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuICBmdW5jdGlvbiBjcmVhdGVDb21wYXJhdG9yKF9hKSB7XHJcbiAgICAgIHZhciBhcmVBcnJheXNFcXVhbCA9IF9hLmFyZUFycmF5c0VxdWFsLCBhcmVEYXRlc0VxdWFsID0gX2EuYXJlRGF0ZXNFcXVhbCwgYXJlTWFwc0VxdWFsID0gX2EuYXJlTWFwc0VxdWFsLCBhcmVPYmplY3RzRXF1YWwgPSBfYS5hcmVPYmplY3RzRXF1YWwsIGFyZVJlZ0V4cHNFcXVhbCA9IF9hLmFyZVJlZ0V4cHNFcXVhbCwgYXJlU2V0c0VxdWFsID0gX2EuYXJlU2V0c0VxdWFsLCBjcmVhdGVJc05lc3RlZEVxdWFsID0gX2EuY3JlYXRlSXNOZXN0ZWRFcXVhbDtcclxuICAgICAgdmFyIGlzRXF1YWwgPSBjcmVhdGVJc05lc3RlZEVxdWFsKGNvbXBhcmF0b3IpO1xyXG4gICAgICAvKipcclxuICAgICAgICogY29tcGFyZSB0aGUgdmFsdWUgb2YgdGhlIHR3byBvYmplY3RzIGFuZCByZXR1cm4gdHJ1ZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50IGluIHZhbHVlc1xyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gY29tcGFyYXRvcihhLCBiLCBtZXRhKSB7XHJcbiAgICAgICAgICAvLyBJZiB0aGUgaXRlbXMgYXJlIHN0cmljdGx5IGVxdWFsLCBubyBuZWVkIHRvIGRvIGEgdmFsdWUgY29tcGFyaXNvbi5cclxuICAgICAgICAgIGlmIChhID09PSBiKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBJZiB0aGUgaXRlbXMgYXJlIG5vdCBub24tbnVsbGlzaCBvYmplY3RzLCB0aGVuIHRoZSBvbmx5IHBvc3NpYmlsaXR5XHJcbiAgICAgICAgICAvLyBvZiB0aGVtIGJlaW5nIGVxdWFsIGJ1dCBub3Qgc3RyaWN0bHkgaXMgaWYgdGhleSBhcmUgYm90aCBgTmFOYC4gU2luY2VcclxuICAgICAgICAgIC8vIGBOYU5gIGlzIHVuaXF1ZWx5IG5vdCBlcXVhbCB0byBpdHNlbGYsIHdlIGNhbiB1c2Ugc2VsZi1jb21wYXJpc29uIG9mXHJcbiAgICAgICAgICAvLyBib3RoIG9iamVjdHMsIHdoaWNoIGlzIGZhc3RlciB0aGFuIGBpc05hTigpYC5cclxuICAgICAgICAgIGlmICghYSB8fCAhYiB8fCB0eXBlb2YgYSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIENoZWNrcyBhcmUgbGlzdGVkIGluIG9yZGVyIG9mIGNvbW1vbmFsaXR5IG9mIHVzZS1jYXNlOlxyXG4gICAgICAgICAgLy8gICAxLiBDb21tb24gY29tcGxleCBvYmplY3QgdHlwZXMgKHBsYWluIG9iamVjdCwgYXJyYXkpXHJcbiAgICAgICAgICAvLyAgIDIuIENvbW1vbiBkYXRhIHZhbHVlcyAoZGF0ZSwgcmVnZXhwKVxyXG4gICAgICAgICAgLy8gICAzLiBMZXNzLWNvbW1vbiBjb21wbGV4IG9iamVjdCB0eXBlcyAobWFwLCBzZXQpXHJcbiAgICAgICAgICAvLyAgIDQuIExlc3MtY29tbW9uIGRhdGEgdmFsdWVzIChwcm9taXNlLCBwcmltaXRpdmUgd3JhcHBlcnMpXHJcbiAgICAgICAgICAvLyBJbmhlcmVudGx5IHRoaXMgaXMgYm90aCBzdWJqZWN0aXZlIGFuZCBhc3N1bXB0aXZlLCBob3dldmVyXHJcbiAgICAgICAgICAvLyB3aGVuIHJldmlld2luZyBjb21wYXJhYmxlIGxpYnJhcmllcyBpbiB0aGUgd2lsZCB0aGlzIG9yZGVyXHJcbiAgICAgICAgICAvLyBhcHBlYXJzIHRvIGJlIGdlbmVyYWxseSBjb25zaXN0ZW50LlxyXG4gICAgICAgICAgLy8gYGlzUGxhaW5PYmplY3RgIG9ubHkgY2hlY2tzIGFnYWluc3QgdGhlIG9iamVjdCdzIG93biByZWFsbS4gQ3Jvc3MtcmVhbG1cclxuICAgICAgICAgIC8vIGNvbXBhcmlzb25zIGFyZSByYXJlLCBhbmQgd2lsbCBiZSBoYW5kbGVkIGluIHRoZSB1bHRpbWF0ZSBmYWxsYmFjaywgc29cclxuICAgICAgICAgIC8vIHdlIGNhbiBhdm9pZCB0aGUgYHRvU3RyaW5nLmNhbGwoKWAgY29zdCB1bmxlc3MgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QoYSkgJiYgaXNQbGFpbk9iamVjdChiKSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgaXNFcXVhbCwgbWV0YSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBgaXNBcnJheSgpYCB3b3JrcyBvbiBzdWJjbGFzc2VzIGFuZCBpcyBjcm9zcy1yZWFsbSwgc28gd2UgY2FuIGFnYWluIGF2b2lkXHJcbiAgICAgICAgICAvLyB0aGUgYHRvU3RyaW5nLmNhbGwoKWAgY29zdCB1bmxlc3MgbmVjZXNzYXJ5IGJ5IGp1c3QgY2hlY2tpbmcgaWYgZWl0aGVyXHJcbiAgICAgICAgICAvLyBhbmQgdGhlbiBib3RoIGFyZSBhcnJheXMuXHJcbiAgICAgICAgICB2YXIgYUFycmF5ID0gQXJyYXkuaXNBcnJheShhKTtcclxuICAgICAgICAgIHZhciBiQXJyYXkgPSBBcnJheS5pc0FycmF5KGIpO1xyXG4gICAgICAgICAgaWYgKGFBcnJheSB8fCBiQXJyYXkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gYUFycmF5ID09PSBiQXJyYXkgJiYgYXJlQXJyYXlzRXF1YWwoYSwgYiwgaXNFcXVhbCwgbWV0YSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIGEgY3VzdG9tIG9iamVjdCwgdXNlIHRoZSBjbGFzc2ljIGB0b1N0cmluZy5jYWxsKClgIHRvIGdldCBpdHNcclxuICAgICAgICAgIC8vIHR5cGUuIFRoaXMgaXMgcmVhc29uYWJseSBwZXJmb3JtYW50IGluIG1vZGVybiBlbnZpcm9ubWVudHMgbGlrZSB2OCBhbmRcclxuICAgICAgICAgIC8vIFNwaWRlck1vbmtleSwgYW5kIGFsbG93cyBmb3IgY3Jvc3MtcmVhbG0gY29tcGFyaXNvbiB3aGVuIG90aGVyIGNoZWNrcyBsaWtlXHJcbiAgICAgICAgICAvLyBgaW5zdGFuY2VvZmAgZG8gbm90LlxyXG4gICAgICAgICAgdmFyIGFUYWcgPSB0b1N0cmluZy5jYWxsKGEpO1xyXG4gICAgICAgICAgaWYgKGFUYWcgIT09IHRvU3RyaW5nLmNhbGwoYikpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoYVRhZyA9PT0gREFURV9UQUcpIHtcclxuICAgICAgICAgICAgICAvLyBgZ2V0VGltZSgpYCBzaG93ZWQgYmV0dGVyIHJlc3VsdHMgY29tcGFyZWQgdG8gYWx0ZXJuYXRpdmVzIGxpa2UgYHZhbHVlT2YoKWBcclxuICAgICAgICAgICAgICAvLyBvciB0aGUgdW5hcnkgYCtgIG9wZXJhdG9yLlxyXG4gICAgICAgICAgICAgIHJldHVybiBhcmVEYXRlc0VxdWFsKGEsIGIsIGlzRXF1YWwsIG1ldGEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGFUYWcgPT09IFJFR19FWFBfVEFHKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGFyZVJlZ0V4cHNFcXVhbChhLCBiLCBpc0VxdWFsLCBtZXRhKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChhVGFnID09PSBNQVBfVEFHKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGFyZU1hcHNFcXVhbChhLCBiLCBpc0VxdWFsLCBtZXRhKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChhVGFnID09PSBTRVRfVEFHKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGFyZVNldHNFcXVhbChhLCBiLCBpc0VxdWFsLCBtZXRhKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIElmIGEgc2ltcGxlIG9iamVjdCB0YWcsIHRoZW4gd2UgY2FuIHByaW9yaXRpemUgYSBzaW1wbGUgb2JqZWN0IGNvbXBhcmlzb24gYmVjYXVzZVxyXG4gICAgICAgICAgLy8gaXQgaXMgbGlrZWx5IGEgY3VzdG9tIGNsYXNzLiBJZiBhbiBhcmd1bWVudHMgdGFnLCBpdCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHN0YW5kYXJkXHJcbiAgICAgICAgICAvLyBvYmplY3QuXHJcbiAgICAgICAgICBpZiAoYVRhZyA9PT0gT0JKRUNUX1RBRyB8fCBhVGFnID09PSBBUkdVTUVOVFNfVEFHKSB7XHJcbiAgICAgICAgICAgICAgLy8gVGhlIGV4Y2VwdGlvbiBmb3IgdmFsdWUgY29tcGFyaXNvbiBpcyBgUHJvbWlzZWAtbGlrZSBjb250cmFjdHMuIFRoZXNlIHNob3VsZCBiZVxyXG4gICAgICAgICAgICAgIC8vIHRyZWF0ZWQgdGhlIHNhbWUgYXMgc3RhbmRhcmQgYFByb21pc2VgIG9iamVjdHMsIHdoaWNoIG1lYW5zIHN0cmljdCBlcXVhbGl0eS5cclxuICAgICAgICAgICAgICByZXR1cm4gaXNQcm9taXNlTGlrZShhKSB8fCBpc1Byb21pc2VMaWtlKGIpXHJcbiAgICAgICAgICAgICAgICAgID8gZmFsc2VcclxuICAgICAgICAgICAgICAgICAgOiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgaXNFcXVhbCwgbWV0YSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBBcyB0aGUgcGVudWx0aW1hdGUgZmFsbGJhY2ssIGNoZWNrIGlmIHRoZSB2YWx1ZXMgcGFzc2VkIGFyZSBwcmltaXRpdmUgd3JhcHBlcnMuIFRoaXNcclxuICAgICAgICAgIC8vIGlzIHZlcnkgcmFyZSBpbiBtb2Rlcm4gSlMsIHdoaWNoIGlzIHdoeSBpdCBpcyBkZXByaW9yaXRpemVkIGNvbXBhcmVkIHRvIGFsbCBvdGhlciBvYmplY3RcclxuICAgICAgICAgIC8vIHR5cGVzLlxyXG4gICAgICAgICAgaWYgKGFUYWcgPT09IEJPT0xFQU5fVEFHIHx8IGFUYWcgPT09IE5VTUJFUl9UQUcgfHwgYVRhZyA9PT0gU1RSSU5HX1RBRykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBzYW1lVmFsdWVaZXJvRXF1YWwoYS52YWx1ZU9mKCksIGIudmFsdWVPZigpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIElmIG5vdCBtYXRjaGluZyBhbnkgdGFncyB0aGF0IHJlcXVpcmUgYSBzcGVjaWZpYyB0eXBlIG9mIGNvbXBhcmlzb24sIHRoZW4gd2UgaGFyZC1jb2RlIGZhbHNlIGJlY2F1c2VcclxuICAgICAgICAgIC8vIHRoZSBvbmx5IHRoaW5nIHJlbWFpbmluZyBpcyBzdHJpY3QgZXF1YWxpdHksIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gY29tcGFyZWQuIFRoaXMgaXMgZm9yIGEgZmV3IHJlYXNvbnM6XHJcbiAgICAgICAgICAvLyAgIC0gQ2VydGFpbiB0eXBlcyB0aGF0IGNhbm5vdCBiZSBpbnRyb3NwZWN0ZWQgKGUuZy4sIGBXZWFrTWFwYCkuIEZvciB0aGVzZSB0eXBlcywgdGhpcyBpcyB0aGUgb25seVxyXG4gICAgICAgICAgLy8gICAgIGNvbXBhcmlzb24gdGhhdCBjYW4gYmUgbWFkZS5cclxuICAgICAgICAgIC8vICAgLSBGb3IgdHlwZXMgdGhhdCBjYW4gYmUgaW50cm9zcGVjdGVkLCBidXQgcmFyZWx5IGhhdmUgcmVxdWlyZW1lbnRzIHRvIGJlIGNvbXBhcmVkXHJcbiAgICAgICAgICAvLyAgICAgKGBBcnJheUJ1ZmZlcmAsIGBEYXRhVmlld2AsIGV0Yy4pLCB0aGUgY29zdCBpcyBhdm9pZGVkIHRvIHByaW9yaXRpemUgdGhlIGNvbW1vblxyXG4gICAgICAgICAgLy8gICAgIHVzZS1jYXNlcyAobWF5IGJlIGluY2x1ZGVkIGluIGEgZnV0dXJlIHJlbGVhc2UsIGlmIHJlcXVlc3RlZCBlbm91Z2gpLlxyXG4gICAgICAgICAgLy8gICAtIEZvciB0eXBlcyB0aGF0IGNhbiBiZSBpbnRyb3NwZWN0ZWQgYnV0IGRvIG5vdCBoYXZlIGFuIG9iamVjdGl2ZSBkZWZpbml0aW9uIG9mIHdoYXRcclxuICAgICAgICAgIC8vICAgICBlcXVhbGl0eSBpcyAoYEVycm9yYCwgZXRjLiksIHRoZSBzdWJqZWN0aXZlIGRlY2lzaW9uIGlzIHRvIGJlIGNvbnNlcnZhdGl2ZSBhbmQgc3RyaWN0bHkgY29tcGFyZS5cclxuICAgICAgICAgIC8vIEluIGFsbCBjYXNlcywgdGhlc2UgZGVjaXNpb25zIHNob3VsZCBiZSByZWV2YWx1YXRlZCBiYXNlZCBvbiBjaGFuZ2VzIHRvIHRoZSBsYW5ndWFnZSBhbmRcclxuICAgICAgICAgIC8vIGNvbW1vbiBkZXZlbG9wbWVudCBwcmFjdGljZXMuXHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNvbXBhcmF0b3I7XHJcbiAgfVxuXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIGFycmF5cyBhcmUgZXF1YWwgaW4gdmFsdWUuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYSwgYiwgaXNFcXVhbCwgbWV0YSkge1xyXG4gICAgICB2YXIgaW5kZXggPSBhLmxlbmd0aDtcclxuICAgICAgaWYgKGIubGVuZ3RoICE9PSBpbmRleCkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIERlY3JlbWVudGluZyBgd2hpbGVgIHNob3dlZCBmYXN0ZXIgcmVzdWx0cyB0aGFuIGVpdGhlciBpbmNyZW1lbnRpbmcgb3JcclxuICAgICAgLy8gZGVjcmVtZW50aW5nIGBmb3JgIGxvb3AgYW5kIHRoYW4gYW4gaW5jcmVtZW50aW5nIGB3aGlsZWAgbG9vcC4gRGVjbGFyYXRpdmVcclxuICAgICAgLy8gbWV0aG9kcyBsaWtlIGBzb21lYCAvIGBldmVyeWAgd2VyZSBub3QgdXNlZCB0byBhdm9pZCBpbmN1cnJpbmcgdGhlIGdhcmJhZ2VcclxuICAgICAgLy8gY29zdCBvZiBhbm9ueW1vdXMgY2FsbGJhY2tzLlxyXG4gICAgICB3aGlsZSAoaW5kZXgtLSA+IDApIHtcclxuICAgICAgICAgIGlmICghaXNFcXVhbChhW2luZGV4XSwgYltpbmRleF0sIGluZGV4LCBpbmRleCwgYSwgYiwgbWV0YSkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIGFycmF5cyBhcmUgZXF1YWwgaW4gdmFsdWUsIGluY2x1ZGluZyBjaXJjdWxhciByZWZlcmVuY2VzLlxyXG4gICAqL1xyXG4gIHZhciBhcmVBcnJheXNFcXVhbENpcmN1bGFyID0gY3JlYXRlSXNDaXJjdWxhcihhcmVBcnJheXNFcXVhbCk7XG5cbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgZGF0ZXMgcGFzc2VkIGFyZSBlcXVhbCBpbiB2YWx1ZS5cclxuICAgKlxyXG4gICAqIEBOT1RFXHJcbiAgICogVGhpcyBpcyBhIHN0YW5kYWxvbmUgZnVuY3Rpb24gaW5zdGVhZCBvZiBkb25lIGlubGluZSBpbiB0aGUgY29tcGFyYXRvclxyXG4gICAqIHRvIGFsbG93IGZvciBvdmVycmlkZXMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYXJlRGF0ZXNFcXVhbChhLCBiKSB7XHJcbiAgICAgIHJldHVybiBzYW1lVmFsdWVaZXJvRXF1YWwoYS52YWx1ZU9mKCksIGIudmFsdWVPZigpKTtcclxuICB9XG5cbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgYE1hcGBzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBhcmVNYXBzRXF1YWwoYSwgYiwgaXNFcXVhbCwgbWV0YSkge1xyXG4gICAgICB2YXIgaXNWYWx1ZUVxdWFsID0gYS5zaXplID09PSBiLnNpemU7XHJcbiAgICAgIGlmICghaXNWYWx1ZUVxdWFsKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFhLnNpemUpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFRoZSB1c2Ugb2YgYGZvckVhY2goKWAgaXMgdG8gYXZvaWQgdGhlIHRyYW5zcGlsYXRpb24gY29zdCBvZiBgZm9yLi4ub2ZgIGNvbXBhcmlzb25zLCBhbmRcclxuICAgICAgLy8gdGhlIGluYWJpbGl0eSB0byBjb250cm9sIHRoZSBwZXJmb3JtYW5jZSBvZiB0aGUgcmVzdWx0aW5nIGNvZGUuIEl0IGFsc28gYXZvaWRzIGV4Y2Vzc2l2ZVxyXG4gICAgICAvLyBpdGVyYXRpb24gY29tcGFyZWQgdG8gZG9pbmcgY29tcGFyaXNvbnMgb2YgYGtleXMoKWAgYW5kIGB2YWx1ZXMoKWAuIEFzIGEgcmVzdWx0LCB0aG91Z2gsXHJcbiAgICAgIC8vIHdlIGNhbm5vdCBzaG9ydC1jaXJjdWl0IHRoZSBpdGVyYXRpb25zOyBib29ra2VlcGluZyBtdXN0IGJlIGRvbmUgdG8gc2hvcnQtY2lyY3VpdCB0aGVcclxuICAgICAgLy8gZXF1YWxpdHkgY2hlY2tzIHRoZW1zZWx2ZXMuXHJcbiAgICAgIHZhciBtYXRjaGVkSW5kaWNlcyA9IHt9O1xyXG4gICAgICB2YXIgaW5kZXhBID0gMDtcclxuICAgICAgYS5mb3JFYWNoKGZ1bmN0aW9uIChhVmFsdWUsIGFLZXkpIHtcclxuICAgICAgICAgIGlmICghaXNWYWx1ZUVxdWFsKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdmFyIGhhc01hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICB2YXIgbWF0Y2hJbmRleEIgPSAwO1xyXG4gICAgICAgICAgYi5mb3JFYWNoKGZ1bmN0aW9uIChiVmFsdWUsIGJLZXkpIHtcclxuICAgICAgICAgICAgICBpZiAoIWhhc01hdGNoICYmXHJcbiAgICAgICAgICAgICAgICAgICFtYXRjaGVkSW5kaWNlc1ttYXRjaEluZGV4Ql0gJiZcclxuICAgICAgICAgICAgICAgICAgKGhhc01hdGNoID1cclxuICAgICAgICAgICAgICAgICAgICAgIGlzRXF1YWwoYUtleSwgYktleSwgaW5kZXhBLCBtYXRjaEluZGV4QiwgYSwgYiwgbWV0YSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpc0VxdWFsKGFWYWx1ZSwgYlZhbHVlLCBhS2V5LCBiS2V5LCBhLCBiLCBtZXRhKSkpIHtcclxuICAgICAgICAgICAgICAgICAgbWF0Y2hlZEluZGljZXNbbWF0Y2hJbmRleEJdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgbWF0Y2hJbmRleEIrKztcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgaW5kZXhBKys7XHJcbiAgICAgICAgICBpc1ZhbHVlRXF1YWwgPSBoYXNNYXRjaDtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBpc1ZhbHVlRXF1YWw7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIGBNYXBgcyBhcmUgZXF1YWwgaW4gdmFsdWUsIGluY2x1ZGluZyBjaXJjdWxhciByZWZlcmVuY2VzLlxyXG4gICAqL1xyXG4gIHZhciBhcmVNYXBzRXF1YWxDaXJjdWxhciA9IGNyZWF0ZUlzQ2lyY3VsYXIoYXJlTWFwc0VxdWFsKTtcblxuICB2YXIgT1dORVIgPSAnX293bmVyJztcclxuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIG9iamVjdHMgYXJlIGVxdWFsIGluIHZhbHVlLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGFyZU9iamVjdHNFcXVhbChhLCBiLCBpc0VxdWFsLCBtZXRhKSB7XHJcbiAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xyXG4gICAgICB2YXIgaW5kZXggPSBrZXlzQS5sZW5ndGg7XHJcbiAgICAgIGlmIChPYmplY3Qua2V5cyhiKS5sZW5ndGggIT09IGluZGV4KSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGtleTtcclxuICAgICAgLy8gRGVjcmVtZW50aW5nIGB3aGlsZWAgc2hvd2VkIGZhc3RlciByZXN1bHRzIHRoYW4gZWl0aGVyIGluY3JlbWVudGluZyBvclxyXG4gICAgICAvLyBkZWNyZW1lbnRpbmcgYGZvcmAgbG9vcCBhbmQgdGhhbiBhbiBpbmNyZW1lbnRpbmcgYHdoaWxlYCBsb29wLiBEZWNsYXJhdGl2ZVxyXG4gICAgICAvLyBtZXRob2RzIGxpa2UgYHNvbWVgIC8gYGV2ZXJ5YCB3ZXJlIG5vdCB1c2VkIHRvIGF2b2lkIGluY3VycmluZyB0aGUgZ2FyYmFnZVxyXG4gICAgICAvLyBjb3N0IG9mIGFub255bW91cyBjYWxsYmFja3MuXHJcbiAgICAgIHdoaWxlIChpbmRleC0tID4gMCkge1xyXG4gICAgICAgICAga2V5ID0ga2V5c0FbaW5kZXhdO1xyXG4gICAgICAgICAgaWYgKGtleSA9PT0gT1dORVIpIHtcclxuICAgICAgICAgICAgICB2YXIgcmVhY3RFbGVtZW50QSA9ICEhYS4kJHR5cGVvZjtcclxuICAgICAgICAgICAgICB2YXIgcmVhY3RFbGVtZW50QiA9ICEhYi4kJHR5cGVvZjtcclxuICAgICAgICAgICAgICBpZiAoKHJlYWN0RWxlbWVudEEgfHwgcmVhY3RFbGVtZW50QikgJiYgcmVhY3RFbGVtZW50QSAhPT0gcmVhY3RFbGVtZW50Qikge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleSkgfHxcclxuICAgICAgICAgICAgICAhaXNFcXVhbChhW2tleV0sIGJba2V5XSwga2V5LCBrZXksIGEsIGIsIG1ldGEpKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBvYmplY3RzIGFyZSBlcXVhbCBpbiB2YWx1ZSwgaW5jbHVkaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMuXHJcbiAgICovXHJcbiAgdmFyIGFyZU9iamVjdHNFcXVhbENpcmN1bGFyID0gY3JlYXRlSXNDaXJjdWxhcihhcmVPYmplY3RzRXF1YWwpO1xuXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIHJlZ2V4cHMgcGFzc2VkIGFyZSBlcXVhbCBpbiB2YWx1ZS5cclxuICAgKlxyXG4gICAqIEBOT1RFXHJcbiAgICogVGhpcyBpcyBhIHN0YW5kYWxvbmUgZnVuY3Rpb24gaW5zdGVhZCBvZiBkb25lIGlubGluZSBpbiB0aGUgY29tcGFyYXRvclxyXG4gICAqIHRvIGFsbG93IGZvciBvdmVycmlkZXMuIEFuIGV4YW1wbGUgb2YgdGhpcyB3b3VsZCBiZSBzdXBwb3J0aW5nIGFcclxuICAgKiBwcmUtRVMyMDE1IGVudmlyb25tZW50IHdoZXJlIHRoZSBgZmxhZ3NgIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYXJlUmVnRXhwc0VxdWFsKGEsIGIpIHtcclxuICAgICAgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xyXG4gIH1cblxuICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBgU2V0YHMgYXJlIGVxdWFsIGluIHZhbHVlLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGFyZVNldHNFcXVhbChhLCBiLCBpc0VxdWFsLCBtZXRhKSB7XHJcbiAgICAgIHZhciBpc1ZhbHVlRXF1YWwgPSBhLnNpemUgPT09IGIuc2l6ZTtcclxuICAgICAgaWYgKCFpc1ZhbHVlRXF1YWwpIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWEuc2l6ZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgLy8gVGhlIHVzZSBvZiBgZm9yRWFjaCgpYCBpcyB0byBhdm9pZCB0aGUgdHJhbnNwaWxhdGlvbiBjb3N0IG9mIGBmb3IuLi5vZmAgY29tcGFyaXNvbnMsIGFuZFxyXG4gICAgICAvLyB0aGUgaW5hYmlsaXR5IHRvIGNvbnRyb2wgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSByZXN1bHRpbmcgY29kZS4gSXQgYWxzbyBhdm9pZHMgZXhjZXNzaXZlXHJcbiAgICAgIC8vIGl0ZXJhdGlvbiBjb21wYXJlZCB0byBkb2luZyBjb21wYXJpc29ucyBvZiBga2V5cygpYCBhbmQgYHZhbHVlcygpYC4gQXMgYSByZXN1bHQsIHRob3VnaCxcclxuICAgICAgLy8gd2UgY2Fubm90IHNob3J0LWNpcmN1aXQgdGhlIGl0ZXJhdGlvbnM7IGJvb2trZWVwaW5nIG11c3QgYmUgZG9uZSB0byBzaG9ydC1jaXJjdWl0IHRoZVxyXG4gICAgICAvLyBlcXVhbGl0eSBjaGVja3MgdGhlbXNlbHZlcy5cclxuICAgICAgdmFyIG1hdGNoZWRJbmRpY2VzID0ge307XHJcbiAgICAgIGEuZm9yRWFjaChmdW5jdGlvbiAoYVZhbHVlLCBhS2V5KSB7XHJcbiAgICAgICAgICBpZiAoIWlzVmFsdWVFcXVhbCkge1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhciBoYXNNYXRjaCA9IGZhbHNlO1xyXG4gICAgICAgICAgdmFyIG1hdGNoSW5kZXggPSAwO1xyXG4gICAgICAgICAgYi5mb3JFYWNoKGZ1bmN0aW9uIChiVmFsdWUsIGJLZXkpIHtcclxuICAgICAgICAgICAgICBpZiAoIWhhc01hdGNoICYmXHJcbiAgICAgICAgICAgICAgICAgICFtYXRjaGVkSW5kaWNlc1ttYXRjaEluZGV4XSAmJlxyXG4gICAgICAgICAgICAgICAgICAoaGFzTWF0Y2ggPSBpc0VxdWFsKGFWYWx1ZSwgYlZhbHVlLCBhS2V5LCBiS2V5LCBhLCBiLCBtZXRhKSkpIHtcclxuICAgICAgICAgICAgICAgICAgbWF0Y2hlZEluZGljZXNbbWF0Y2hJbmRleF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBtYXRjaEluZGV4Kys7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGlzVmFsdWVFcXVhbCA9IGhhc01hdGNoO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGlzVmFsdWVFcXVhbDtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgYFNldGBzIGFyZSBlcXVhbCBpbiB2YWx1ZSwgaW5jbHVkaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMuXHJcbiAgICovXHJcbiAgdmFyIGFyZVNldHNFcXVhbENpcmN1bGFyID0gY3JlYXRlSXNDaXJjdWxhcihhcmVTZXRzRXF1YWwpO1xuXG4gIHZhciBERUZBVUxUX0NPTkZJRyA9IE9iamVjdC5mcmVlemUoe1xyXG4gICAgICBhcmVBcnJheXNFcXVhbDogYXJlQXJyYXlzRXF1YWwsXHJcbiAgICAgIGFyZURhdGVzRXF1YWw6IGFyZURhdGVzRXF1YWwsXHJcbiAgICAgIGFyZU1hcHNFcXVhbDogYXJlTWFwc0VxdWFsLFxyXG4gICAgICBhcmVPYmplY3RzRXF1YWw6IGFyZU9iamVjdHNFcXVhbCxcclxuICAgICAgYXJlUmVnRXhwc0VxdWFsOiBhcmVSZWdFeHBzRXF1YWwsXHJcbiAgICAgIGFyZVNldHNFcXVhbDogYXJlU2V0c0VxdWFsLFxyXG4gICAgICBjcmVhdGVJc05lc3RlZEVxdWFsOiBjcmVhdGVEZWZhdWx0SXNOZXN0ZWRFcXVhbCxcclxuICB9KTtcclxuICB2YXIgREVGQVVMVF9DSVJDVUxBUl9DT05GSUcgPSBPYmplY3QuZnJlZXplKHtcclxuICAgICAgYXJlQXJyYXlzRXF1YWw6IGFyZUFycmF5c0VxdWFsQ2lyY3VsYXIsXHJcbiAgICAgIGFyZURhdGVzRXF1YWw6IGFyZURhdGVzRXF1YWwsXHJcbiAgICAgIGFyZU1hcHNFcXVhbDogYXJlTWFwc0VxdWFsQ2lyY3VsYXIsXHJcbiAgICAgIGFyZU9iamVjdHNFcXVhbDogYXJlT2JqZWN0c0VxdWFsQ2lyY3VsYXIsXHJcbiAgICAgIGFyZVJlZ0V4cHNFcXVhbDogYXJlUmVnRXhwc0VxdWFsLFxyXG4gICAgICBhcmVTZXRzRXF1YWw6IGFyZVNldHNFcXVhbENpcmN1bGFyLFxyXG4gICAgICBjcmVhdGVJc05lc3RlZEVxdWFsOiBjcmVhdGVEZWZhdWx0SXNOZXN0ZWRFcXVhbCxcclxuICB9KTtcclxuICB2YXIgaXNEZWVwRXF1YWwgPSBjcmVhdGVDb21wYXJhdG9yKERFRkFVTFRfQ09ORklHKTtcclxuICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIGRlZXBseS1lcXVhbCBpbiB2YWx1ZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xyXG4gICAgICByZXR1cm4gaXNEZWVwRXF1YWwoYSwgYiwgdW5kZWZpbmVkKTtcclxuICB9XHJcbiAgdmFyIGlzU2hhbGxvd0VxdWFsID0gY3JlYXRlQ29tcGFyYXRvcihtZXJnZShERUZBVUxUX0NPTkZJRywgeyBjcmVhdGVJc05lc3RlZEVxdWFsOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzYW1lVmFsdWVaZXJvRXF1YWw7IH0gfSkpO1xyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgc2hhbGxvd2x5LWVxdWFsIGluIHZhbHVlLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChhLCBiKSB7XHJcbiAgICAgIHJldHVybiBpc1NoYWxsb3dFcXVhbChhLCBiLCB1bmRlZmluZWQpO1xyXG4gIH1cclxuICB2YXIgaXNDaXJjdWxhckRlZXBFcXVhbCA9IGNyZWF0ZUNvbXBhcmF0b3IoREVGQVVMVF9DSVJDVUxBUl9DT05GSUcpO1xyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgZGVlcGx5LWVxdWFsIGluIHZhbHVlLCBpbmNsdWRpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjaXJjdWxhckRlZXBFcXVhbChhLCBiKSB7XHJcbiAgICAgIHJldHVybiBpc0NpcmN1bGFyRGVlcEVxdWFsKGEsIGIsIG5ldyBXZWFrTWFwKCkpO1xyXG4gIH1cclxuICB2YXIgaXNDaXJjdWxhclNoYWxsb3dFcXVhbCA9IGNyZWF0ZUNvbXBhcmF0b3IobWVyZ2UoREVGQVVMVF9DSVJDVUxBUl9DT05GSUcsIHtcclxuICAgICAgY3JlYXRlSXNOZXN0ZWRFcXVhbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2FtZVZhbHVlWmVyb0VxdWFsOyB9LFxyXG4gIH0pKTtcclxuICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIHNoYWxsb3dseS1lcXVhbCBpbiB2YWx1ZSwgaW5jbHVkaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2lyY3VsYXJTaGFsbG93RXF1YWwoYSwgYikge1xyXG4gICAgICByZXR1cm4gaXNDaXJjdWxhclNoYWxsb3dFcXVhbChhLCBiLCBuZXcgV2Vha01hcCgpKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgY3VzdG9tIGVxdWFsaXR5IGNvbXBhcmlzb24gbWV0aG9kLlxyXG4gICAqXHJcbiAgICogVGhpcyBjYW4gYmUgZG9uZSB0byBjcmVhdGUgdmVyeSB0YXJnZXRlZCBjb21wYXJpc29ucyBpbiBleHRyZW1lIGhvdC1wYXRoIHNjZW5hcmlvc1xyXG4gICAqIHdoZXJlIHRoZSBzdGFuZGFyZCBtZXRob2RzIGFyZSBub3QgcGVyZm9ybWFudCBlbm91Z2gsIGJ1dCBjYW4gYWxzbyBiZSB1c2VkIHRvIHByb3ZpZGVcclxuICAgKiBzdXBwb3J0IGZvciBsZWdhY3kgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgZXhwZWN0ZWQgZmVhdHVyZXMgbGlrZVxyXG4gICAqIGBSZWdFeHAucHJvdG90eXBlLmZsYWdzYCBvdXQgb2YgdGhlIGJveC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjcmVhdGVDdXN0b21FcXVhbChnZXRDb21wYXJhdG9yT3B0aW9ucykge1xyXG4gICAgICByZXR1cm4gY3JlYXRlQ29tcGFyYXRvcihtZXJnZShERUZBVUxUX0NPTkZJRywgZ2V0Q29tcGFyYXRvck9wdGlvbnMoREVGQVVMVF9DT05GSUcpKSk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIGN1c3RvbSBlcXVhbGl0eSBjb21wYXJpc29uIG1ldGhvZCB0aGF0IGhhbmRsZXMgY2lyY3VsYXIgcmVmZXJlbmNlcy4gVGhpcyBpcyB2ZXJ5XHJcbiAgICogc2ltaWxhciB0byBgY3JlYXRlQ3VzdG9tRXF1YWxgLCB3aXRoIHRoZSBvbmx5IGRpZmZlcmVuY2UgYmVpbmcgdGhhdCBgbWV0YWAgZXhwZWN0cyB0byBiZVxyXG4gICAqIHBvcHVsYXRlZCB3aXRoIGEgYFdlYWtNYXBgLWxpa2UgY29udHJhY3QuXHJcbiAgICpcclxuICAgKiBUaGlzIGNhbiBiZSBkb25lIHRvIGNyZWF0ZSB2ZXJ5IHRhcmdldGVkIGNvbXBhcmlzb25zIGluIGV4dHJlbWUgaG90LXBhdGggc2NlbmFyaW9zXHJcbiAgICogd2hlcmUgdGhlIHN0YW5kYXJkIG1ldGhvZHMgYXJlIG5vdCBwZXJmb3JtYW50IGVub3VnaCwgYnV0IGNhbiBhbHNvIGJlIHVzZWQgdG8gcHJvdmlkZVxyXG4gICAqIHN1cHBvcnQgZm9yIGxlZ2FjeSBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBleHBlY3RlZCBmZWF0dXJlcyBsaWtlXHJcbiAgICogYFdlYWtNYXBgIG91dCBvZiB0aGUgYm94LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZUN1c3RvbUNpcmN1bGFyRXF1YWwoZ2V0Q29tcGFyYXRvck9wdGlvbnMpIHtcclxuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBjcmVhdGVDb21wYXJhdG9yKG1lcmdlKERFRkFVTFRfQ0lSQ1VMQVJfQ09ORklHLCBnZXRDb21wYXJhdG9yT3B0aW9ucyhERUZBVUxUX0NJUkNVTEFSX0NPTkZJRykpKTtcclxuICAgICAgcmV0dXJuIChmdW5jdGlvbiAoYSwgYiwgbWV0YSkge1xyXG4gICAgICAgICAgaWYgKG1ldGEgPT09IHZvaWQgMCkgeyBtZXRhID0gbmV3IFdlYWtNYXAoKTsgfVxyXG4gICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3IoYSwgYiwgbWV0YSk7XHJcbiAgICAgIH0pO1xyXG4gIH1cblxuICBleHBvcnRzLmNpcmN1bGFyRGVlcEVxdWFsID0gY2lyY3VsYXJEZWVwRXF1YWw7XG4gIGV4cG9ydHMuY2lyY3VsYXJTaGFsbG93RXF1YWwgPSBjaXJjdWxhclNoYWxsb3dFcXVhbDtcbiAgZXhwb3J0cy5jcmVhdGVDdXN0b21DaXJjdWxhckVxdWFsID0gY3JlYXRlQ3VzdG9tQ2lyY3VsYXJFcXVhbDtcbiAgZXhwb3J0cy5jcmVhdGVDdXN0b21FcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsO1xuICBleHBvcnRzLmRlZXBFcXVhbCA9IGRlZXBFcXVhbDtcbiAgZXhwb3J0cy5zYW1lVmFsdWVaZXJvRXF1YWwgPSBzYW1lVmFsdWVaZXJvRXF1YWw7XG4gIGV4cG9ydHMuc2hhbGxvd0VxdWFsID0gc2hhbGxvd0VxdWFsO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZhc3QtZXF1YWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/fast-equals/dist/fast-equals.js\n");

/***/ }),

/***/ "../../node_modules/object-assign/index.js":
/*!*************************************************!*\
  !*** ../../node_modules/object-assign/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9zdC8uLi8uLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcz85OWE4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/object-assign/index.js\n");

/***/ }),

/***/ "../../node_modules/prop-types/checkPropTypes.js":
/*!*******************************************************!*\
  !*** ../../node_modules/prop-types/checkPropTypes.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"../../node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n  var has = __webpack_require__(/*! ./lib/has */ \"../../node_modules/prop-types/lib/has.js\");\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) { /**/ }\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +\n              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          );\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * Resets warning cache when testing.\n *\n * @private\n */\ncheckPropTypes.resetWarningCache = function() {\n  if (true) {\n    loggedTypeFailures = {};\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzPzBjNDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIHZhciBoYXMgPSByZXF1aXJlKCcuL2xpYi9oYXMnKTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkgeyAvKiovIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgK1xuICAgICAgICAgICAgICAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAnICtcbiAgICAgICAgICAgIGxvY2F0aW9uICsgJyBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJyArIHR5cGVvZiBlcnJvciArICcuICcgK1xuICAgICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArXG4gICAgICAgICAgICAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnRmFpbGVkICcgKyBsb2NhdGlvbiArICcgdHlwZTogJyArIGVycm9yLm1lc3NhZ2UgKyAoc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlc2V0cyB3YXJuaW5nIGNhY2hlIHdoZW4gdGVzdGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/prop-types/checkPropTypes.js\n");

/***/ }),

/***/ "../../node_modules/prop-types/factoryWithTypeCheckers.js":
/*!****************************************************************!*\
  !*** ../../node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactIs = __webpack_require__(/*! react-is */ \"../../node_modules/react-is/index.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"../../node_modules/object-assign/index.js\");\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"../../node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar has = __webpack_require__(/*! ./lib/has */ \"../../node_modules/prop-types/lib/has.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"../../node_modules/prop-types/checkPropTypes.js\");\n\nvar printWarning = function() {};\n\nif (true) {\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nfunction emptyFunctionThatReturnsNull() {\n  return null;\n}\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bigint: createPrimitiveTypeChecker('bigint'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    elementType: createElementTypeTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message, data) {\n    this.message = message;\n    this.data = data && typeof data === 'object' ? data: {};\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          var err = new Error(\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n          err.name = 'Invariant Violation';\n          throw err;\n        } else if ( true && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            printWarning(\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError(\n          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),\n          {expectedType: expectedType}\n        );\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!ReactIs.isValidElementType(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      if (true) {\n        if (arguments.length > 1) {\n          printWarning(\n            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +\n            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'\n          );\n        } else {\n          printWarning('Invalid argument supplied to oneOf, expected an array.');\n        }\n      }\n      return emptyFunctionThatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n        var type = getPreciseType(value);\n        if (type === 'symbol') {\n          return String(value);\n        }\n        return value;\n      });\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (has(propValue, key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        printWarning(\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'\n        );\n        return emptyFunctionThatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var expectedTypes = [];\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n        if (checkerResult == null) {\n          return null;\n        }\n        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {\n          expectedTypes.push(checkerResult.data.expectedType);\n        }\n      }\n      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function invalidValidatorError(componentName, location, propFullName, key, type) {\n    return new PropTypeError(\n      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +\n      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'\n    );\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (has(shapeTypes, key) && typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // falsy value can't be a Symbol\n    if (!propValue) {\n      return false;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzP2MwY2IiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9saWIvaGFzJyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBiaWdpbnQ6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdiaWdpbnQnKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSwgZGF0YSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5kYXRhID0gZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgPyBkYXRhOiB7fTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSxcbiAgICAgICAgICB7ZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGV9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIHZhciBjaGVja2VyUmVzdWx0ID0gY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja2VyUmVzdWx0LmRhdGEgJiYgaGFzKGNoZWNrZXJSZXN1bHQuZGF0YSwgJ2V4cGVjdGVkVHlwZScpKSB7XG4gICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGNoZWNrZXJSZXN1bHQuZGF0YS5leHBlY3RlZFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgPSAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPiAwKSA/ICcsIGV4cGVjdGVkIG9uZSBvZiB0eXBlIFsnICsgZXhwZWN0ZWRUeXBlcy5qb2luKCcsICcpICsgJ10nOiAnJztcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AnICsgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHByb3BGdWxsTmFtZSArICcuJyArIGtleSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZSArICdgLidcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb20gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoaGFzKHNoYXBlVHlwZXMsIGtleSkgJiYgdHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgZ2V0UHJlY2lzZVR5cGUoY2hlY2tlcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZhbHN5IHZhbHVlIGNhbid0IGJlIGEgU3ltYm9sXG4gICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/prop-types/factoryWithTypeCheckers.js\n");

/***/ }),

/***/ "../../node_modules/prop-types/index.js":
/*!**********************************************!*\
  !*** ../../node_modules/prop-types/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var ReactIs = __webpack_require__(/*! react-is */ \"../../node_modules/react-is/index.js\");\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"../../node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9zdC8uLi8uLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcz82OTZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/prop-types/index.js\n");

/***/ }),

/***/ "../../node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzPzYyMzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/prop-types/lib/ReactPropTypesSecret.js\n");

/***/ }),

/***/ "../../node_modules/prop-types/lib/has.js":
/*!************************************************!*\
  !*** ../../node_modules/prop-types/lib/has.js ***!
  \************************************************/
/***/ ((module) => {

eval("module.exports = Function.call.bind(Object.prototype.hasOwnProperty);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL2hhcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL2hhcy5qcz9iN2Q5Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/prop-types/lib/has.js\n");

/***/ }),

/***/ "../../node_modules/property-expr/index.js":
/*!*************************************************!*\
  !*** ../../node_modules/property-expr/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("/**\n * Based on Kendo UI Core expression code <https://github.com/telerik/kendo-ui-core#license-information>\n */\n\n\nfunction Cache(maxSize) {\n  this._maxSize = maxSize\n  this.clear()\n}\nCache.prototype.clear = function () {\n  this._size = 0\n  this._values = Object.create(null)\n}\nCache.prototype.get = function (key) {\n  return this._values[key]\n}\nCache.prototype.set = function (key, value) {\n  this._size >= this._maxSize && this.clear()\n  if (!(key in this._values)) this._size++\n\n  return (this._values[key] = value)\n}\n\nvar SPLIT_REGEX = /[^.^\\]^[]+|(?=\\[\\]|\\.\\.)/g,\n  DIGIT_REGEX = /^\\d+$/,\n  LEAD_DIGIT_REGEX = /^\\d/,\n  SPEC_CHAR_REGEX = /[~`!#$%\\^&*+=\\-\\[\\]\\\\';,/{}|\\\\\":<>\\?]/g,\n  CLEAN_QUOTES_REGEX = /^\\s*(['\"]?)(.*?)(\\1)\\s*$/,\n  MAX_CACHE_SIZE = 512\n\nvar pathCache = new Cache(MAX_CACHE_SIZE),\n  setCache = new Cache(MAX_CACHE_SIZE),\n  getCache = new Cache(MAX_CACHE_SIZE)\n\nvar config\n\nmodule.exports = {\n  Cache: Cache,\n\n  split: split,\n\n  normalizePath: normalizePath,\n\n  setter: function (path) {\n    var parts = normalizePath(path)\n\n    return (\n      setCache.get(path) ||\n      setCache.set(path, function setter(obj, value) {\n        var index = 0\n        var len = parts.length\n        var data = obj\n\n        while (index < len - 1) {\n          var part = parts[index]\n          if (\n            part === '__proto__' ||\n            part === 'constructor' ||\n            part === 'prototype'\n          ) {\n            return obj\n          }\n\n          data = data[parts[index++]]\n        }\n        data[parts[index]] = value\n      })\n    )\n  },\n\n  getter: function (path, safe) {\n    var parts = normalizePath(path)\n    return (\n      getCache.get(path) ||\n      getCache.set(path, function getter(data) {\n        var index = 0,\n          len = parts.length\n        while (index < len) {\n          if (data != null || !safe) data = data[parts[index++]]\n          else return\n        }\n        return data\n      })\n    )\n  },\n\n  join: function (segments) {\n    return segments.reduce(function (path, part) {\n      return (\n        path +\n        (isQuoted(part) || DIGIT_REGEX.test(part)\n          ? '[' + part + ']'\n          : (path ? '.' : '') + part)\n      )\n    }, '')\n  },\n\n  forEach: function (path, cb, thisArg) {\n    forEach(Array.isArray(path) ? path : split(path), cb, thisArg)\n  },\n}\n\nfunction normalizePath(path) {\n  return (\n    pathCache.get(path) ||\n    pathCache.set(\n      path,\n      split(path).map(function (part) {\n        return part.replace(CLEAN_QUOTES_REGEX, '$2')\n      })\n    )\n  )\n}\n\nfunction split(path) {\n  return path.match(SPLIT_REGEX) || ['']\n}\n\nfunction forEach(parts, iter, thisArg) {\n  var len = parts.length,\n    part,\n    idx,\n    isArray,\n    isBracket\n\n  for (idx = 0; idx < len; idx++) {\n    part = parts[idx]\n\n    if (part) {\n      if (shouldBeQuoted(part)) {\n        part = '\"' + part + '\"'\n      }\n\n      isBracket = isQuoted(part)\n      isArray = !isBracket && /^\\d+$/.test(part)\n\n      iter.call(thisArg, part, isBracket, isArray, idx, parts)\n    }\n  }\n}\n\nfunction isQuoted(str) {\n  return (\n    typeof str === 'string' && str && [\"'\", '\"'].indexOf(str.charAt(0)) !== -1\n  )\n}\n\nfunction hasLeadingNumber(part) {\n  return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX)\n}\n\nfunction hasSpecialChars(part) {\n  return SPEC_CHAR_REGEX.test(part)\n}\n\nfunction shouldBeQuoted(part) {\n  return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3BlcnR5LWV4cHIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3BlcnR5LWV4cHIvaW5kZXguanM/NzQ1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJhc2VkIG9uIEtlbmRvIFVJIENvcmUgZXhwcmVzc2lvbiBjb2RlIDxodHRwczovL2dpdGh1Yi5jb20vdGVsZXJpay9rZW5kby11aS1jb3JlI2xpY2Vuc2UtaW5mb3JtYXRpb24+XG4gKi9cbid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBDYWNoZShtYXhTaXplKSB7XG4gIHRoaXMuX21heFNpemUgPSBtYXhTaXplXG4gIHRoaXMuY2xlYXIoKVxufVxuQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9zaXplID0gMFxuICB0aGlzLl92YWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG59XG5DYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gdGhpcy5fdmFsdWVzW2tleV1cbn1cbkNhY2hlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0aGlzLl9zaXplID49IHRoaXMuX21heFNpemUgJiYgdGhpcy5jbGVhcigpXG4gIGlmICghKGtleSBpbiB0aGlzLl92YWx1ZXMpKSB0aGlzLl9zaXplKytcblxuICByZXR1cm4gKHRoaXMuX3ZhbHVlc1trZXldID0gdmFsdWUpXG59XG5cbnZhciBTUExJVF9SRUdFWCA9IC9bXi5eXFxdXltdK3woPz1cXFtcXF18XFwuXFwuKS9nLFxuICBESUdJVF9SRUdFWCA9IC9eXFxkKyQvLFxuICBMRUFEX0RJR0lUX1JFR0VYID0gL15cXGQvLFxuICBTUEVDX0NIQVJfUkVHRVggPSAvW35gISMkJVxcXiYqKz1cXC1cXFtcXF1cXFxcJzssL3t9fFxcXFxcIjo8PlxcP10vZyxcbiAgQ0xFQU5fUVVPVEVTX1JFR0VYID0gL15cXHMqKFsnXCJdPykoLio/KShcXDEpXFxzKiQvLFxuICBNQVhfQ0FDSEVfU0laRSA9IDUxMlxuXG52YXIgcGF0aENhY2hlID0gbmV3IENhY2hlKE1BWF9DQUNIRV9TSVpFKSxcbiAgc2V0Q2FjaGUgPSBuZXcgQ2FjaGUoTUFYX0NBQ0hFX1NJWkUpLFxuICBnZXRDYWNoZSA9IG5ldyBDYWNoZShNQVhfQ0FDSEVfU0laRSlcblxudmFyIGNvbmZpZ1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2FjaGU6IENhY2hlLFxuXG4gIHNwbGl0OiBzcGxpdCxcblxuICBub3JtYWxpemVQYXRoOiBub3JtYWxpemVQYXRoLFxuXG4gIHNldHRlcjogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgcGFydHMgPSBub3JtYWxpemVQYXRoKHBhdGgpXG5cbiAgICByZXR1cm4gKFxuICAgICAgc2V0Q2FjaGUuZ2V0KHBhdGgpIHx8XG4gICAgICBzZXRDYWNoZS5zZXQocGF0aCwgZnVuY3Rpb24gc2V0dGVyKG9iaiwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMFxuICAgICAgICB2YXIgbGVuID0gcGFydHMubGVuZ3RoXG4gICAgICAgIHZhciBkYXRhID0gb2JqXG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuIC0gMSkge1xuICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaW5kZXhdXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcGFydCA9PT0gJ19fcHJvdG9fXycgfHxcbiAgICAgICAgICAgIHBhcnQgPT09ICdjb25zdHJ1Y3RvcicgfHxcbiAgICAgICAgICAgIHBhcnQgPT09ICdwcm90b3R5cGUnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YSA9IGRhdGFbcGFydHNbaW5kZXgrK11dXG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtwYXJ0c1tpbmRleF1dID0gdmFsdWVcbiAgICAgIH0pXG4gICAgKVxuICB9LFxuXG4gIGdldHRlcjogZnVuY3Rpb24gKHBhdGgsIHNhZmUpIHtcbiAgICB2YXIgcGFydHMgPSBub3JtYWxpemVQYXRoKHBhdGgpXG4gICAgcmV0dXJuIChcbiAgICAgIGdldENhY2hlLmdldChwYXRoKSB8fFxuICAgICAgZ2V0Q2FjaGUuc2V0KHBhdGgsIGZ1bmN0aW9uIGdldHRlcihkYXRhKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgbGVuID0gcGFydHMubGVuZ3RoXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbikge1xuICAgICAgICAgIGlmIChkYXRhICE9IG51bGwgfHwgIXNhZmUpIGRhdGEgPSBkYXRhW3BhcnRzW2luZGV4KytdXVxuICAgICAgICAgIGVsc2UgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgIH0pXG4gICAgKVxuICB9LFxuXG4gIGpvaW46IGZ1bmN0aW9uIChzZWdtZW50cykge1xuICAgIHJldHVybiBzZWdtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHBhdGgsIHBhcnQpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBhdGggK1xuICAgICAgICAoaXNRdW90ZWQocGFydCkgfHwgRElHSVRfUkVHRVgudGVzdChwYXJ0KVxuICAgICAgICAgID8gJ1snICsgcGFydCArICddJ1xuICAgICAgICAgIDogKHBhdGggPyAnLicgOiAnJykgKyBwYXJ0KVxuICAgICAgKVxuICAgIH0sICcnKVxuICB9LFxuXG4gIGZvckVhY2g6IGZ1bmN0aW9uIChwYXRoLCBjYiwgdGhpc0FyZykge1xuICAgIGZvckVhY2goQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBzcGxpdChwYXRoKSwgY2IsIHRoaXNBcmcpXG4gIH0sXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGgocGF0aCkge1xuICByZXR1cm4gKFxuICAgIHBhdGhDYWNoZS5nZXQocGF0aCkgfHxcbiAgICBwYXRoQ2FjaGUuc2V0KFxuICAgICAgcGF0aCxcbiAgICAgIHNwbGl0KHBhdGgpLm1hcChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICByZXR1cm4gcGFydC5yZXBsYWNlKENMRUFOX1FVT1RFU19SRUdFWCwgJyQyJylcbiAgICAgIH0pXG4gICAgKVxuICApXG59XG5cbmZ1bmN0aW9uIHNwbGl0KHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubWF0Y2goU1BMSVRfUkVHRVgpIHx8IFsnJ11cbn1cblxuZnVuY3Rpb24gZm9yRWFjaChwYXJ0cywgaXRlciwgdGhpc0FyZykge1xuICB2YXIgbGVuID0gcGFydHMubGVuZ3RoLFxuICAgIHBhcnQsXG4gICAgaWR4LFxuICAgIGlzQXJyYXksXG4gICAgaXNCcmFja2V0XG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBsZW47IGlkeCsrKSB7XG4gICAgcGFydCA9IHBhcnRzW2lkeF1cblxuICAgIGlmIChwYXJ0KSB7XG4gICAgICBpZiAoc2hvdWxkQmVRdW90ZWQocGFydCkpIHtcbiAgICAgICAgcGFydCA9ICdcIicgKyBwYXJ0ICsgJ1wiJ1xuICAgICAgfVxuXG4gICAgICBpc0JyYWNrZXQgPSBpc1F1b3RlZChwYXJ0KVxuICAgICAgaXNBcnJheSA9ICFpc0JyYWNrZXQgJiYgL15cXGQrJC8udGVzdChwYXJ0KVxuXG4gICAgICBpdGVyLmNhbGwodGhpc0FyZywgcGFydCwgaXNCcmFja2V0LCBpc0FycmF5LCBpZHgsIHBhcnRzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1F1b3RlZChzdHIpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyAmJiBzdHIgJiYgW1wiJ1wiLCAnXCInXS5pbmRleE9mKHN0ci5jaGFyQXQoMCkpICE9PSAtMVxuICApXG59XG5cbmZ1bmN0aW9uIGhhc0xlYWRpbmdOdW1iZXIocGFydCkge1xuICByZXR1cm4gcGFydC5tYXRjaChMRUFEX0RJR0lUX1JFR0VYKSAmJiAhcGFydC5tYXRjaChESUdJVF9SRUdFWClcbn1cblxuZnVuY3Rpb24gaGFzU3BlY2lhbENoYXJzKHBhcnQpIHtcbiAgcmV0dXJuIFNQRUNfQ0hBUl9SRUdFWC50ZXN0KHBhcnQpXG59XG5cbmZ1bmN0aW9uIHNob3VsZEJlUXVvdGVkKHBhcnQpIHtcbiAgcmV0dXJuICFpc1F1b3RlZChwYXJ0KSAmJiAoaGFzTGVhZGluZ051bWJlcihwYXJ0KSB8fCBoYXNTcGVjaWFsQ2hhcnMocGFydCkpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/property-expr/index.js\n");

/***/ }),

/***/ "../../node_modules/react-draggable/build/cjs/Draggable.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/react-draggable/build/cjs/Draggable.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"DraggableCore\", ({\n  enumerable: true,\n  get: function () {\n    return _DraggableCore.default;\n  }\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"../../node_modules/prop-types/index.js\"));\nvar _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ \"webpack/sharing/consume/default/react-dom/react-dom\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"../../node_modules/react-draggable/node_modules/clsx/dist/clsx.m.js\"));\nvar _domFns = __webpack_require__(/*! ./utils/domFns */ \"../../node_modules/react-draggable/build/cjs/utils/domFns.js\");\nvar _positionFns = __webpack_require__(/*! ./utils/positionFns */ \"../../node_modules/react-draggable/build/cjs/utils/positionFns.js\");\nvar _shims = __webpack_require__(/*! ./utils/shims */ \"../../node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _DraggableCore = _interopRequireDefault(__webpack_require__(/*! ./DraggableCore */ \"../../node_modules/react-draggable/build/cjs/DraggableCore.js\"));\nvar _log = _interopRequireDefault(__webpack_require__(/*! ./utils/log */ \"../../node_modules/react-draggable/build/cjs/utils/log.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); } /*:: import type {ControlPosition, PositionOffsetControlPosition, DraggableCoreProps, DraggableCoreDefaultProps} from './DraggableCore';*/\n/*:: import type {Bounds, DraggableEventHandler} from './utils/types';*/\n/*:: import type {Element as ReactElement} from 'react';*/\n/*:: type DraggableState = {\n  dragging: boolean,\n  dragged: boolean,\n  x: number, y: number,\n  slackX: number, slackY: number,\n  isElementSVG: boolean,\n  prevPropsPosition: ?ControlPosition,\n};*/\n/*:: export type DraggableDefaultProps = {\n  ...DraggableCoreDefaultProps,\n  axis: 'both' | 'x' | 'y' | 'none',\n  bounds: Bounds | string | false,\n  defaultClassName: string,\n  defaultClassNameDragging: string,\n  defaultClassNameDragged: string,\n  defaultPosition: ControlPosition,\n  scale: number,\n};*/\n/*:: export type DraggableProps = {\n  ...DraggableCoreProps,\n  ...DraggableDefaultProps,\n  positionOffset: PositionOffsetControlPosition,\n  position: ControlPosition,\n};*/\n//\n// Define <Draggable>\n//\nclass Draggable extends React.Component /*:: <DraggableProps, DraggableState>*/{\n  // React 16.3+\n  // Arity (props, state)\n  static getDerivedStateFromProps(_ref /*:: */, _ref2 /*:: */) /*: ?Partial<DraggableState>*/{\n    let {\n      position\n    } /*: DraggableProps*/ = _ref /*: DraggableProps*/;\n    let {\n      prevPropsPosition\n    } /*: DraggableState*/ = _ref2 /*: DraggableState*/;\n    // Set x/y if a new position is provided in props that is different than the previous.\n    if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {\n      (0, _log.default)('Draggable: getDerivedStateFromProps %j', {\n        position,\n        prevPropsPosition\n      });\n      return {\n        x: position.x,\n        y: position.y,\n        prevPropsPosition: {\n          ...position\n        }\n      };\n    }\n    return null;\n  }\n  constructor(props /*: DraggableProps*/) {\n    super(props);\n    _defineProperty(this, \"onDragStart\", (e, coreData) => {\n      (0, _log.default)('Draggable: onDragStart: %j', coreData);\n\n      // Short-circuit if user's callback killed it.\n      const shouldStart = this.props.onStart(e, (0, _positionFns.createDraggableData)(this, coreData));\n      // Kills start event on core as well, so move handlers are never bound.\n      if (shouldStart === false) return false;\n      this.setState({\n        dragging: true,\n        dragged: true\n      });\n    });\n    _defineProperty(this, \"onDrag\", (e, coreData) => {\n      if (!this.state.dragging) return false;\n      (0, _log.default)('Draggable: onDrag: %j', coreData);\n      const uiData = (0, _positionFns.createDraggableData)(this, coreData);\n      const newState = {\n        x: uiData.x,\n        y: uiData.y,\n        slackX: 0,\n        slackY: 0\n      };\n\n      // Keep within bounds.\n      if (this.props.bounds) {\n        // Save original x and y.\n        const {\n          x,\n          y\n        } = newState;\n\n        // Add slack to the values used to calculate bound position. This will ensure that if\n        // we start removing slack, the element won't react to it right away until it's been\n        // completely removed.\n        newState.x += this.state.slackX;\n        newState.y += this.state.slackY;\n\n        // Get bound position. This will ceil/floor the x and y within the boundaries.\n        const [newStateX, newStateY] = (0, _positionFns.getBoundPosition)(this, newState.x, newState.y);\n        newState.x = newStateX;\n        newState.y = newStateY;\n\n        // Recalculate slack by noting how much was shaved by the boundPosition handler.\n        newState.slackX = this.state.slackX + (x - newState.x);\n        newState.slackY = this.state.slackY + (y - newState.y);\n\n        // Update the event we fire to reflect what really happened after bounds took effect.\n        uiData.x = newState.x;\n        uiData.y = newState.y;\n        uiData.deltaX = newState.x - this.state.x;\n        uiData.deltaY = newState.y - this.state.y;\n      }\n\n      // Short-circuit if user's callback killed it.\n      const shouldUpdate = this.props.onDrag(e, uiData);\n      if (shouldUpdate === false) return false;\n      this.setState(newState);\n    });\n    _defineProperty(this, \"onDragStop\", (e, coreData) => {\n      if (!this.state.dragging) return false;\n\n      // Short-circuit if user's callback killed it.\n      const shouldContinue = this.props.onStop(e, (0, _positionFns.createDraggableData)(this, coreData));\n      if (shouldContinue === false) return false;\n      (0, _log.default)('Draggable: onDragStop: %j', coreData);\n      const newState /*: Partial<DraggableState>*/ = {\n        dragging: false,\n        slackX: 0,\n        slackY: 0\n      };\n\n      // If this is a controlled component, the result of this operation will be to\n      // revert back to the old position. We expect a handler on `onDragStop`, at the least.\n      const controlled = Boolean(this.props.position);\n      if (controlled) {\n        const {\n          x,\n          y\n        } = this.props.position;\n        newState.x = x;\n        newState.y = y;\n      }\n      this.setState(newState);\n    });\n    this.state = {\n      // Whether or not we are currently dragging.\n      dragging: false,\n      // Whether or not we have been dragged before.\n      dragged: false,\n      // Current transform x and y.\n      x: props.position ? props.position.x : props.defaultPosition.x,\n      y: props.position ? props.position.y : props.defaultPosition.y,\n      prevPropsPosition: {\n        ...props.position\n      },\n      // Used for compensating for out-of-bounds drags\n      slackX: 0,\n      slackY: 0,\n      // Can only determine if SVG after mounting\n      isElementSVG: false\n    };\n    if (props.position && !(props.onDrag || props.onStop)) {\n      // eslint-disable-next-line no-console\n      console.warn('A `position` was applied to this <Draggable>, without drag handlers. This will make this ' + 'component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the ' + '`position` of this element.');\n    }\n  }\n  componentDidMount() {\n    // Check to see if the element passed is an instanceof SVGElement\n    if (typeof window.SVGElement !== 'undefined' && this.findDOMNode() instanceof window.SVGElement) {\n      this.setState({\n        isElementSVG: true\n      });\n    }\n  }\n  componentWillUnmount() {\n    this.setState({\n      dragging: false\n    }); // prevents invariant if unmounted while dragging\n  }\n\n  // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find\n  // the underlying DOM node ourselves. See the README for more information.\n  findDOMNode() /*: ?HTMLElement*/{\n    var _this$props$nodeRef$c, _this$props;\n    return (_this$props$nodeRef$c = (_this$props = this.props) === null || _this$props === void 0 || (_this$props = _this$props.nodeRef) === null || _this$props === void 0 ? void 0 : _this$props.current) !== null && _this$props$nodeRef$c !== void 0 ? _this$props$nodeRef$c : _reactDom.default.findDOMNode(this);\n  }\n  render() /*: ReactElement<any>*/{\n    const {\n      axis,\n      bounds,\n      children,\n      defaultPosition,\n      defaultClassName,\n      defaultClassNameDragging,\n      defaultClassNameDragged,\n      position,\n      positionOffset,\n      scale,\n      ...draggableCoreProps\n    } = this.props;\n    let style = {};\n    let svgTransform = null;\n\n    // If this is controlled, we don't want to move it - unless it's dragging.\n    const controlled = Boolean(position);\n    const draggable = !controlled || this.state.dragging;\n    const validPosition = position || defaultPosition;\n    const transformOpts = {\n      // Set left if horizontal drag is enabled\n      x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,\n      // Set top if vertical drag is enabled\n      y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y\n    };\n\n    // If this element was SVG, we use the `transform` attribute.\n    if (this.state.isElementSVG) {\n      svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);\n    } else {\n      // Add a CSS transform to move the element around. This allows us to move the element around\n      // without worrying about whether or not it is relatively or absolutely positioned.\n      // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>\n      // has a clean slate.\n      style = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);\n    }\n\n    // Mark with class while dragging\n    const className = (0, _clsx.default)(children.props.className || '', defaultClassName, {\n      [defaultClassNameDragging]: this.state.dragging,\n      [defaultClassNameDragged]: this.state.dragged\n    });\n\n    // Reuse the child provided\n    // This makes it flexible to use whatever element is wanted (div, ul, etc)\n    return /*#__PURE__*/React.createElement(_DraggableCore.default, _extends({}, draggableCoreProps, {\n      onStart: this.onDragStart,\n      onDrag: this.onDrag,\n      onStop: this.onDragStop\n    }), /*#__PURE__*/React.cloneElement(React.Children.only(children), {\n      className: className,\n      style: {\n        ...children.props.style,\n        ...style\n      },\n      transform: svgTransform\n    }));\n  }\n}\nexports[\"default\"] = Draggable;\n_defineProperty(Draggable, \"displayName\", 'Draggable');\n_defineProperty(Draggable, \"propTypes\", {\n  // Accepts all props <DraggableCore> accepts.\n  ..._DraggableCore.default.propTypes,\n  /**\n   * `axis` determines which axis the draggable can move.\n   *\n   *  Note that all callbacks will still return data as normal. This only\n   *  controls flushing to the DOM.\n   *\n   * 'both' allows movement horizontally and vertically.\n   * 'x' limits movement to horizontal axis.\n   * 'y' limits movement to vertical axis.\n   * 'none' limits all movement.\n   *\n   * Defaults to 'both'.\n   */\n  axis: _propTypes.default.oneOf(['both', 'x', 'y', 'none']),\n  /**\n   * `bounds` determines the range of movement available to the element.\n   * Available values are:\n   *\n   * 'parent' restricts movement within the Draggable's parent node.\n   *\n   * Alternatively, pass an object with the following properties, all of which are optional:\n   *\n   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}\n   *\n   * All values are in px.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *         return (\n   *            <Draggable bounds={{right: 300, bottom: 300}}>\n   *              <div>Content</div>\n   *           </Draggable>\n   *         );\n   *       }\n   *   });\n   * ```\n   */\n  bounds: _propTypes.default.oneOfType([_propTypes.default.shape({\n    left: _propTypes.default.number,\n    right: _propTypes.default.number,\n    top: _propTypes.default.number,\n    bottom: _propTypes.default.number\n  }), _propTypes.default.string, _propTypes.default.oneOf([false])]),\n  defaultClassName: _propTypes.default.string,\n  defaultClassNameDragging: _propTypes.default.string,\n  defaultClassNameDragged: _propTypes.default.string,\n  /**\n   * `defaultPosition` specifies the x and y that the dragged item should start at\n   *\n   * Example:\n   *\n   * ```jsx\n   *      let App = React.createClass({\n   *          render: function () {\n   *              return (\n   *                  <Draggable defaultPosition={{x: 25, y: 25}}>\n   *                      <div>I start with transformX: 25px and transformY: 25px;</div>\n   *                  </Draggable>\n   *              );\n   *          }\n   *      });\n   * ```\n   */\n  defaultPosition: _propTypes.default.shape({\n    x: _propTypes.default.number,\n    y: _propTypes.default.number\n  }),\n  positionOffset: _propTypes.default.shape({\n    x: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),\n    y: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])\n  }),\n  /**\n   * `position`, if present, defines the current position of the element.\n   *\n   *  This is similar to how form elements in React work - if no `position` is supplied, the component\n   *  is uncontrolled.\n   *\n   * Example:\n   *\n   * ```jsx\n   *      let App = React.createClass({\n   *          render: function () {\n   *              return (\n   *                  <Draggable position={{x: 25, y: 25}}>\n   *                      <div>I start with transformX: 25px and transformY: 25px;</div>\n   *                  </Draggable>\n   *              );\n   *          }\n   *      });\n   * ```\n   */\n  position: _propTypes.default.shape({\n    x: _propTypes.default.number,\n    y: _propTypes.default.number\n  }),\n  /**\n   * These properties should be defined on the child, not here.\n   */\n  className: _shims.dontSetMe,\n  style: _shims.dontSetMe,\n  transform: _shims.dontSetMe\n});\n_defineProperty(Draggable, \"defaultProps\", {\n  ..._DraggableCore.default.defaultProps,\n  axis: 'both',\n  bounds: false,\n  defaultClassName: 'react-draggable',\n  defaultClassNameDragging: 'react-draggable-dragging',\n  defaultClassNameDragged: 'react-draggable-dragged',\n  defaultPosition: {\n    x: 0,\n    y: 0\n  },\n  scale: 1\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWdnYWJsZS9idWlsZC9janMvRHJhZ2dhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL0RyYWdnYWJsZS5qcz83NDFkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRHJhZ2dhYmxlQ29yZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfRHJhZ2dhYmxlQ29yZS5kZWZhdWx0O1xuICB9XG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBSZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xudmFyIF9yZWFjdERvbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0LWRvbVwiKSk7XG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbnZhciBfZG9tRm5zID0gcmVxdWlyZShcIi4vdXRpbHMvZG9tRm5zXCIpO1xudmFyIF9wb3NpdGlvbkZucyA9IHJlcXVpcmUoXCIuL3V0aWxzL3Bvc2l0aW9uRm5zXCIpO1xudmFyIF9zaGltcyA9IHJlcXVpcmUoXCIuL3V0aWxzL3NoaW1zXCIpO1xudmFyIF9EcmFnZ2FibGVDb3JlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9EcmFnZ2FibGVDb3JlXCIpKTtcbnZhciBfbG9nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9sb2dcIikpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiAobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9IC8qOjogaW1wb3J0IHR5cGUge0NvbnRyb2xQb3NpdGlvbiwgUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24sIERyYWdnYWJsZUNvcmVQcm9wcywgRHJhZ2dhYmxlQ29yZURlZmF1bHRQcm9wc30gZnJvbSAnLi9EcmFnZ2FibGVDb3JlJzsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7Qm91bmRzLCBEcmFnZ2FibGVFdmVudEhhbmRsZXJ9IGZyb20gJy4vdXRpbHMvdHlwZXMnOyovXG4vKjo6IGltcG9ydCB0eXBlIHtFbGVtZW50IGFzIFJlYWN0RWxlbWVudH0gZnJvbSAncmVhY3QnOyovXG4vKjo6IHR5cGUgRHJhZ2dhYmxlU3RhdGUgPSB7XG4gIGRyYWdnaW5nOiBib29sZWFuLFxuICBkcmFnZ2VkOiBib29sZWFuLFxuICB4OiBudW1iZXIsIHk6IG51bWJlcixcbiAgc2xhY2tYOiBudW1iZXIsIHNsYWNrWTogbnVtYmVyLFxuICBpc0VsZW1lbnRTVkc6IGJvb2xlYW4sXG4gIHByZXZQcm9wc1Bvc2l0aW9uOiA/Q29udHJvbFBvc2l0aW9uLFxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVEZWZhdWx0UHJvcHMgPSB7XG4gIC4uLkRyYWdnYWJsZUNvcmVEZWZhdWx0UHJvcHMsXG4gIGF4aXM6ICdib3RoJyB8ICd4JyB8ICd5JyB8ICdub25lJyxcbiAgYm91bmRzOiBCb3VuZHMgfCBzdHJpbmcgfCBmYWxzZSxcbiAgZGVmYXVsdENsYXNzTmFtZTogc3RyaW5nLFxuICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dpbmc6IHN0cmluZyxcbiAgZGVmYXVsdENsYXNzTmFtZURyYWdnZWQ6IHN0cmluZyxcbiAgZGVmYXVsdFBvc2l0aW9uOiBDb250cm9sUG9zaXRpb24sXG4gIHNjYWxlOiBudW1iZXIsXG59OyovXG4vKjo6IGV4cG9ydCB0eXBlIERyYWdnYWJsZVByb3BzID0ge1xuICAuLi5EcmFnZ2FibGVDb3JlUHJvcHMsXG4gIC4uLkRyYWdnYWJsZURlZmF1bHRQcm9wcyxcbiAgcG9zaXRpb25PZmZzZXQ6IFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uLFxuICBwb3NpdGlvbjogQ29udHJvbFBvc2l0aW9uLFxufTsqL1xuLy9cbi8vIERlZmluZSA8RHJhZ2dhYmxlPlxuLy9cbmNsYXNzIERyYWdnYWJsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCAvKjo6IDxEcmFnZ2FibGVQcm9wcywgRHJhZ2dhYmxlU3RhdGU+Ki97XG4gIC8vIFJlYWN0IDE2LjMrXG4gIC8vIEFyaXR5IChwcm9wcywgc3RhdGUpXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoX3JlZiAvKjo6ICovLCBfcmVmMiAvKjo6ICovKSAvKjogP1BhcnRpYWw8RHJhZ2dhYmxlU3RhdGU+Ki97XG4gICAgbGV0IHtcbiAgICAgIHBvc2l0aW9uXG4gICAgfSAvKjogRHJhZ2dhYmxlUHJvcHMqLyA9IF9yZWYgLyo6IERyYWdnYWJsZVByb3BzKi87XG4gICAgbGV0IHtcbiAgICAgIHByZXZQcm9wc1Bvc2l0aW9uXG4gICAgfSAvKjogRHJhZ2dhYmxlU3RhdGUqLyA9IF9yZWYyIC8qOiBEcmFnZ2FibGVTdGF0ZSovO1xuICAgIC8vIFNldCB4L3kgaWYgYSBuZXcgcG9zaXRpb24gaXMgcHJvdmlkZWQgaW4gcHJvcHMgdGhhdCBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgcHJldmlvdXMuXG4gICAgaWYgKHBvc2l0aW9uICYmICghcHJldlByb3BzUG9zaXRpb24gfHwgcG9zaXRpb24ueCAhPT0gcHJldlByb3BzUG9zaXRpb24ueCB8fCBwb3NpdGlvbi55ICE9PSBwcmV2UHJvcHNQb3NpdGlvbi55KSkge1xuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZTogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICVqJywge1xuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgcHJldlByb3BzUG9zaXRpb25cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcG9zaXRpb24ueCxcbiAgICAgICAgeTogcG9zaXRpb24ueSxcbiAgICAgICAgcHJldlByb3BzUG9zaXRpb246IHtcbiAgICAgICAgICAuLi5wb3NpdGlvblxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdHJ1Y3Rvcihwcm9wcyAvKjogRHJhZ2dhYmxlUHJvcHMqLykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdTdGFydFwiLCAoZSwgY29yZURhdGEpID0+IHtcbiAgICAgICgwLCBfbG9nLmRlZmF1bHQpKCdEcmFnZ2FibGU6IG9uRHJhZ1N0YXJ0OiAlaicsIGNvcmVEYXRhKTtcblxuICAgICAgLy8gU2hvcnQtY2lyY3VpdCBpZiB1c2VyJ3MgY2FsbGJhY2sga2lsbGVkIGl0LlxuICAgICAgY29uc3Qgc2hvdWxkU3RhcnQgPSB0aGlzLnByb3BzLm9uU3RhcnQoZSwgKDAsIF9wb3NpdGlvbkZucy5jcmVhdGVEcmFnZ2FibGVEYXRhKSh0aGlzLCBjb3JlRGF0YSkpO1xuICAgICAgLy8gS2lsbHMgc3RhcnQgZXZlbnQgb24gY29yZSBhcyB3ZWxsLCBzbyBtb3ZlIGhhbmRsZXJzIGFyZSBuZXZlciBib3VuZC5cbiAgICAgIGlmIChzaG91bGRTdGFydCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBkcmFnZ2luZzogdHJ1ZSxcbiAgICAgICAgZHJhZ2dlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25EcmFnXCIsIChlLCBjb3JlRGF0YSkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnN0YXRlLmRyYWdnaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnRHJhZ2dhYmxlOiBvbkRyYWc6ICVqJywgY29yZURhdGEpO1xuICAgICAgY29uc3QgdWlEYXRhID0gKDAsIF9wb3NpdGlvbkZucy5jcmVhdGVEcmFnZ2FibGVEYXRhKSh0aGlzLCBjb3JlRGF0YSk7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgICAgeDogdWlEYXRhLngsXG4gICAgICAgIHk6IHVpRGF0YS55LFxuICAgICAgICBzbGFja1g6IDAsXG4gICAgICAgIHNsYWNrWTogMFxuICAgICAgfTtcblxuICAgICAgLy8gS2VlcCB3aXRoaW4gYm91bmRzLlxuICAgICAgaWYgKHRoaXMucHJvcHMuYm91bmRzKSB7XG4gICAgICAgIC8vIFNhdmUgb3JpZ2luYWwgeCBhbmQgeS5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9ID0gbmV3U3RhdGU7XG5cbiAgICAgICAgLy8gQWRkIHNsYWNrIHRvIHRoZSB2YWx1ZXMgdXNlZCB0byBjYWxjdWxhdGUgYm91bmQgcG9zaXRpb24uIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCBpZlxuICAgICAgICAvLyB3ZSBzdGFydCByZW1vdmluZyBzbGFjaywgdGhlIGVsZW1lbnQgd29uJ3QgcmVhY3QgdG8gaXQgcmlnaHQgYXdheSB1bnRpbCBpdCdzIGJlZW5cbiAgICAgICAgLy8gY29tcGxldGVseSByZW1vdmVkLlxuICAgICAgICBuZXdTdGF0ZS54ICs9IHRoaXMuc3RhdGUuc2xhY2tYO1xuICAgICAgICBuZXdTdGF0ZS55ICs9IHRoaXMuc3RhdGUuc2xhY2tZO1xuXG4gICAgICAgIC8vIEdldCBib3VuZCBwb3NpdGlvbi4gVGhpcyB3aWxsIGNlaWwvZmxvb3IgdGhlIHggYW5kIHkgd2l0aGluIHRoZSBib3VuZGFyaWVzLlxuICAgICAgICBjb25zdCBbbmV3U3RhdGVYLCBuZXdTdGF0ZVldID0gKDAsIF9wb3NpdGlvbkZucy5nZXRCb3VuZFBvc2l0aW9uKSh0aGlzLCBuZXdTdGF0ZS54LCBuZXdTdGF0ZS55KTtcbiAgICAgICAgbmV3U3RhdGUueCA9IG5ld1N0YXRlWDtcbiAgICAgICAgbmV3U3RhdGUueSA9IG5ld1N0YXRlWTtcblxuICAgICAgICAvLyBSZWNhbGN1bGF0ZSBzbGFjayBieSBub3RpbmcgaG93IG11Y2ggd2FzIHNoYXZlZCBieSB0aGUgYm91bmRQb3NpdGlvbiBoYW5kbGVyLlxuICAgICAgICBuZXdTdGF0ZS5zbGFja1ggPSB0aGlzLnN0YXRlLnNsYWNrWCArICh4IC0gbmV3U3RhdGUueCk7XG4gICAgICAgIG5ld1N0YXRlLnNsYWNrWSA9IHRoaXMuc3RhdGUuc2xhY2tZICsgKHkgLSBuZXdTdGF0ZS55KTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGV2ZW50IHdlIGZpcmUgdG8gcmVmbGVjdCB3aGF0IHJlYWxseSBoYXBwZW5lZCBhZnRlciBib3VuZHMgdG9vayBlZmZlY3QuXG4gICAgICAgIHVpRGF0YS54ID0gbmV3U3RhdGUueDtcbiAgICAgICAgdWlEYXRhLnkgPSBuZXdTdGF0ZS55O1xuICAgICAgICB1aURhdGEuZGVsdGFYID0gbmV3U3RhdGUueCAtIHRoaXMuc3RhdGUueDtcbiAgICAgICAgdWlEYXRhLmRlbHRhWSA9IG5ld1N0YXRlLnkgLSB0aGlzLnN0YXRlLnk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNob3J0LWNpcmN1aXQgaWYgdXNlcidzIGNhbGxiYWNrIGtpbGxlZCBpdC5cbiAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZSA9IHRoaXMucHJvcHMub25EcmFnKGUsIHVpRGF0YSk7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25EcmFnU3RvcFwiLCAoZSwgY29yZURhdGEpID0+IHtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5kcmFnZ2luZykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBTaG9ydC1jaXJjdWl0IGlmIHVzZXIncyBjYWxsYmFjayBraWxsZWQgaXQuXG4gICAgICBjb25zdCBzaG91bGRDb250aW51ZSA9IHRoaXMucHJvcHMub25TdG9wKGUsICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlRHJhZ2dhYmxlRGF0YSkodGhpcywgY29yZURhdGEpKTtcbiAgICAgIGlmIChzaG91bGRDb250aW51ZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICgwLCBfbG9nLmRlZmF1bHQpKCdEcmFnZ2FibGU6IG9uRHJhZ1N0b3A6ICVqJywgY29yZURhdGEpO1xuICAgICAgY29uc3QgbmV3U3RhdGUgLyo6IFBhcnRpYWw8RHJhZ2dhYmxlU3RhdGU+Ki8gPSB7XG4gICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgc2xhY2tYOiAwLFxuICAgICAgICBzbGFja1k6IDBcbiAgICAgIH07XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIGNvbXBvbmVudCwgdGhlIHJlc3VsdCBvZiB0aGlzIG9wZXJhdGlvbiB3aWxsIGJlIHRvXG4gICAgICAvLyByZXZlcnQgYmFjayB0byB0aGUgb2xkIHBvc2l0aW9uLiBXZSBleHBlY3QgYSBoYW5kbGVyIG9uIGBvbkRyYWdTdG9wYCwgYXQgdGhlIGxlYXN0LlxuICAgICAgY29uc3QgY29udHJvbGxlZCA9IEJvb2xlYW4odGhpcy5wcm9wcy5wb3NpdGlvbik7XG4gICAgICBpZiAoY29udHJvbGxlZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgeCxcbiAgICAgICAgICB5XG4gICAgICAgIH0gPSB0aGlzLnByb3BzLnBvc2l0aW9uO1xuICAgICAgICBuZXdTdGF0ZS54ID0geDtcbiAgICAgICAgbmV3U3RhdGUueSA9IHk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICB9KTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgLy8gV2hldGhlciBvciBub3Qgd2UgYXJlIGN1cnJlbnRseSBkcmFnZ2luZy5cbiAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgIC8vIFdoZXRoZXIgb3Igbm90IHdlIGhhdmUgYmVlbiBkcmFnZ2VkIGJlZm9yZS5cbiAgICAgIGRyYWdnZWQ6IGZhbHNlLFxuICAgICAgLy8gQ3VycmVudCB0cmFuc2Zvcm0geCBhbmQgeS5cbiAgICAgIHg6IHByb3BzLnBvc2l0aW9uID8gcHJvcHMucG9zaXRpb24ueCA6IHByb3BzLmRlZmF1bHRQb3NpdGlvbi54LFxuICAgICAgeTogcHJvcHMucG9zaXRpb24gPyBwcm9wcy5wb3NpdGlvbi55IDogcHJvcHMuZGVmYXVsdFBvc2l0aW9uLnksXG4gICAgICBwcmV2UHJvcHNQb3NpdGlvbjoge1xuICAgICAgICAuLi5wcm9wcy5wb3NpdGlvblxuICAgICAgfSxcbiAgICAgIC8vIFVzZWQgZm9yIGNvbXBlbnNhdGluZyBmb3Igb3V0LW9mLWJvdW5kcyBkcmFnc1xuICAgICAgc2xhY2tYOiAwLFxuICAgICAgc2xhY2tZOiAwLFxuICAgICAgLy8gQ2FuIG9ubHkgZGV0ZXJtaW5lIGlmIFNWRyBhZnRlciBtb3VudGluZ1xuICAgICAgaXNFbGVtZW50U1ZHOiBmYWxzZVxuICAgIH07XG4gICAgaWYgKHByb3BzLnBvc2l0aW9uICYmICEocHJvcHMub25EcmFnIHx8IHByb3BzLm9uU3RvcCkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oJ0EgYHBvc2l0aW9uYCB3YXMgYXBwbGllZCB0byB0aGlzIDxEcmFnZ2FibGU+LCB3aXRob3V0IGRyYWcgaGFuZGxlcnMuIFRoaXMgd2lsbCBtYWtlIHRoaXMgJyArICdjb21wb25lbnQgZWZmZWN0aXZlbHkgdW5kcmFnZ2FibGUuIFBsZWFzZSBhdHRhY2ggYG9uRHJhZ2Agb3IgYG9uU3RvcGAgaGFuZGxlcnMgc28geW91IGNhbiBhZGp1c3QgdGhlICcgKyAnYHBvc2l0aW9uYCBvZiB0aGlzIGVsZW1lbnQuJyk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgZWxlbWVudCBwYXNzZWQgaXMgYW4gaW5zdGFuY2VvZiBTVkdFbGVtZW50XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuU1ZHRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5maW5kRE9NTm9kZSgpIGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc0VsZW1lbnRTVkc6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGRyYWdnaW5nOiBmYWxzZVxuICAgIH0pOyAvLyBwcmV2ZW50cyBpbnZhcmlhbnQgaWYgdW5tb3VudGVkIHdoaWxlIGRyYWdnaW5nXG4gIH1cblxuICAvLyBSZWFjdCBTdHJpY3QgTW9kZSBjb21wYXRpYmlsaXR5OiBpZiBgbm9kZVJlZmAgaXMgcGFzc2VkLCB3ZSB3aWxsIHVzZSBpdCBpbnN0ZWFkIG9mIHRyeWluZyB0byBmaW5kXG4gIC8vIHRoZSB1bmRlcmx5aW5nIERPTSBub2RlIG91cnNlbHZlcy4gU2VlIHRoZSBSRUFETUUgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gIGZpbmRET01Ob2RlKCkgLyo6ID9IVE1MRWxlbWVudCove1xuICAgIHZhciBfdGhpcyRwcm9wcyRub2RlUmVmJGMsIF90aGlzJHByb3BzO1xuICAgIHJldHVybiAoX3RoaXMkcHJvcHMkbm9kZVJlZiRjID0gKF90aGlzJHByb3BzID0gdGhpcy5wcm9wcykgPT09IG51bGwgfHwgX3RoaXMkcHJvcHMgPT09IHZvaWQgMCB8fCAoX3RoaXMkcHJvcHMgPSBfdGhpcyRwcm9wcy5ub2RlUmVmKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcHJvcHMuY3VycmVudCkgIT09IG51bGwgJiYgX3RoaXMkcHJvcHMkbm9kZVJlZiRjICE9PSB2b2lkIDAgPyBfdGhpcyRwcm9wcyRub2RlUmVmJGMgOiBfcmVhY3REb20uZGVmYXVsdC5maW5kRE9NTm9kZSh0aGlzKTtcbiAgfVxuICByZW5kZXIoKSAvKjogUmVhY3RFbGVtZW50PGFueT4qL3tcbiAgICBjb25zdCB7XG4gICAgICBheGlzLFxuICAgICAgYm91bmRzLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBkZWZhdWx0UG9zaXRpb24sXG4gICAgICBkZWZhdWx0Q2xhc3NOYW1lLFxuICAgICAgZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nLFxuICAgICAgZGVmYXVsdENsYXNzTmFtZURyYWdnZWQsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIHBvc2l0aW9uT2Zmc2V0LFxuICAgICAgc2NhbGUsXG4gICAgICAuLi5kcmFnZ2FibGVDb3JlUHJvcHNcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBsZXQgc3R5bGUgPSB7fTtcbiAgICBsZXQgc3ZnVHJhbnNmb3JtID0gbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgY29udHJvbGxlZCwgd2UgZG9uJ3Qgd2FudCB0byBtb3ZlIGl0IC0gdW5sZXNzIGl0J3MgZHJhZ2dpbmcuXG4gICAgY29uc3QgY29udHJvbGxlZCA9IEJvb2xlYW4ocG9zaXRpb24pO1xuICAgIGNvbnN0IGRyYWdnYWJsZSA9ICFjb250cm9sbGVkIHx8IHRoaXMuc3RhdGUuZHJhZ2dpbmc7XG4gICAgY29uc3QgdmFsaWRQb3NpdGlvbiA9IHBvc2l0aW9uIHx8IGRlZmF1bHRQb3NpdGlvbjtcbiAgICBjb25zdCB0cmFuc2Zvcm1PcHRzID0ge1xuICAgICAgLy8gU2V0IGxlZnQgaWYgaG9yaXpvbnRhbCBkcmFnIGlzIGVuYWJsZWRcbiAgICAgIHg6ICgwLCBfcG9zaXRpb25GbnMuY2FuRHJhZ1gpKHRoaXMpICYmIGRyYWdnYWJsZSA/IHRoaXMuc3RhdGUueCA6IHZhbGlkUG9zaXRpb24ueCxcbiAgICAgIC8vIFNldCB0b3AgaWYgdmVydGljYWwgZHJhZyBpcyBlbmFibGVkXG4gICAgICB5OiAoMCwgX3Bvc2l0aW9uRm5zLmNhbkRyYWdZKSh0aGlzKSAmJiBkcmFnZ2FibGUgPyB0aGlzLnN0YXRlLnkgOiB2YWxpZFBvc2l0aW9uLnlcbiAgICB9O1xuXG4gICAgLy8gSWYgdGhpcyBlbGVtZW50IHdhcyBTVkcsIHdlIHVzZSB0aGUgYHRyYW5zZm9ybWAgYXR0cmlidXRlLlxuICAgIGlmICh0aGlzLnN0YXRlLmlzRWxlbWVudFNWRykge1xuICAgICAgc3ZnVHJhbnNmb3JtID0gKDAsIF9kb21GbnMuY3JlYXRlU1ZHVHJhbnNmb3JtKSh0cmFuc2Zvcm1PcHRzLCBwb3NpdGlvbk9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFkZCBhIENTUyB0cmFuc2Zvcm0gdG8gbW92ZSB0aGUgZWxlbWVudCBhcm91bmQuIFRoaXMgYWxsb3dzIHVzIHRvIG1vdmUgdGhlIGVsZW1lbnQgYXJvdW5kXG4gICAgICAvLyB3aXRob3V0IHdvcnJ5aW5nIGFib3V0IHdoZXRoZXIgb3Igbm90IGl0IGlzIHJlbGF0aXZlbHkgb3IgYWJzb2x1dGVseSBwb3NpdGlvbmVkLlxuICAgICAgLy8gSWYgdGhlIGl0ZW0geW91IGFyZSBkcmFnZ2luZyBhbHJlYWR5IGhhcyBhIHRyYW5zZm9ybSBzZXQsIHdyYXAgaXQgaW4gYSA8c3Bhbj4gc28gPERyYWdnYWJsZT5cbiAgICAgIC8vIGhhcyBhIGNsZWFuIHNsYXRlLlxuICAgICAgc3R5bGUgPSAoMCwgX2RvbUZucy5jcmVhdGVDU1NUcmFuc2Zvcm0pKHRyYW5zZm9ybU9wdHMsIHBvc2l0aW9uT2Zmc2V0KTtcbiAgICB9XG5cbiAgICAvLyBNYXJrIHdpdGggY2xhc3Mgd2hpbGUgZHJhZ2dpbmdcbiAgICBjb25zdCBjbGFzc05hbWUgPSAoMCwgX2Nsc3guZGVmYXVsdCkoY2hpbGRyZW4ucHJvcHMuY2xhc3NOYW1lIHx8ICcnLCBkZWZhdWx0Q2xhc3NOYW1lLCB7XG4gICAgICBbZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nXTogdGhpcy5zdGF0ZS5kcmFnZ2luZyxcbiAgICAgIFtkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dlZF06IHRoaXMuc3RhdGUuZHJhZ2dlZFxuICAgIH0pO1xuXG4gICAgLy8gUmV1c2UgdGhlIGNoaWxkIHByb3ZpZGVkXG4gICAgLy8gVGhpcyBtYWtlcyBpdCBmbGV4aWJsZSB0byB1c2Ugd2hhdGV2ZXIgZWxlbWVudCBpcyB3YW50ZWQgKGRpdiwgdWwsIGV0YylcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoX0RyYWdnYWJsZUNvcmUuZGVmYXVsdCwgX2V4dGVuZHMoe30sIGRyYWdnYWJsZUNvcmVQcm9wcywge1xuICAgICAgb25TdGFydDogdGhpcy5vbkRyYWdTdGFydCxcbiAgICAgIG9uRHJhZzogdGhpcy5vbkRyYWcsXG4gICAgICBvblN0b3A6IHRoaXMub25EcmFnU3RvcFxuICAgIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pLCB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIC4uLmNoaWxkcmVuLnByb3BzLnN0eWxlLFxuICAgICAgICAuLi5zdHlsZVxuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybTogc3ZnVHJhbnNmb3JtXG4gICAgfSkpO1xuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnZ2FibGU7XG5fZGVmaW5lUHJvcGVydHkoRHJhZ2dhYmxlLCBcImRpc3BsYXlOYW1lXCIsICdEcmFnZ2FibGUnKTtcbl9kZWZpbmVQcm9wZXJ0eShEcmFnZ2FibGUsIFwicHJvcFR5cGVzXCIsIHtcbiAgLy8gQWNjZXB0cyBhbGwgcHJvcHMgPERyYWdnYWJsZUNvcmU+IGFjY2VwdHMuXG4gIC4uLl9EcmFnZ2FibGVDb3JlLmRlZmF1bHQucHJvcFR5cGVzLFxuICAvKipcbiAgICogYGF4aXNgIGRldGVybWluZXMgd2hpY2ggYXhpcyB0aGUgZHJhZ2dhYmxlIGNhbiBtb3ZlLlxuICAgKlxuICAgKiAgTm90ZSB0aGF0IGFsbCBjYWxsYmFja3Mgd2lsbCBzdGlsbCByZXR1cm4gZGF0YSBhcyBub3JtYWwuIFRoaXMgb25seVxuICAgKiAgY29udHJvbHMgZmx1c2hpbmcgdG8gdGhlIERPTS5cbiAgICpcbiAgICogJ2JvdGgnIGFsbG93cyBtb3ZlbWVudCBob3Jpem9udGFsbHkgYW5kIHZlcnRpY2FsbHkuXG4gICAqICd4JyBsaW1pdHMgbW92ZW1lbnQgdG8gaG9yaXpvbnRhbCBheGlzLlxuICAgKiAneScgbGltaXRzIG1vdmVtZW50IHRvIHZlcnRpY2FsIGF4aXMuXG4gICAqICdub25lJyBsaW1pdHMgYWxsIG1vdmVtZW50LlxuICAgKlxuICAgKiBEZWZhdWx0cyB0byAnYm90aCcuXG4gICAqL1xuICBheGlzOiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2YoWydib3RoJywgJ3gnLCAneScsICdub25lJ10pLFxuICAvKipcbiAgICogYGJvdW5kc2AgZGV0ZXJtaW5lcyB0aGUgcmFuZ2Ugb2YgbW92ZW1lbnQgYXZhaWxhYmxlIHRvIHRoZSBlbGVtZW50LlxuICAgKiBBdmFpbGFibGUgdmFsdWVzIGFyZTpcbiAgICpcbiAgICogJ3BhcmVudCcgcmVzdHJpY3RzIG1vdmVtZW50IHdpdGhpbiB0aGUgRHJhZ2dhYmxlJ3MgcGFyZW50IG5vZGUuXG4gICAqXG4gICAqIEFsdGVybmF0aXZlbHksIHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzLCBhbGwgb2Ygd2hpY2ggYXJlIG9wdGlvbmFsOlxuICAgKlxuICAgKiB7bGVmdDogTEVGVF9CT1VORCwgcmlnaHQ6IFJJR0hUX0JPVU5ELCBib3R0b206IEJPVFRPTV9CT1VORCwgdG9wOiBUT1BfQk9VTkR9XG4gICAqXG4gICAqIEFsbCB2YWx1ZXMgYXJlIGluIHB4LlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogICBsZXQgQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICogICAgICAgICByZXR1cm4gKFxuICAgKiAgICAgICAgICAgIDxEcmFnZ2FibGUgYm91bmRzPXt7cmlnaHQ6IDMwMCwgYm90dG9tOiAzMDB9fT5cbiAgICogICAgICAgICAgICAgIDxkaXY+Q29udGVudDwvZGl2PlxuICAgKiAgICAgICAgICAgPC9EcmFnZ2FibGU+XG4gICAqICAgICAgICAgKTtcbiAgICogICAgICAgfVxuICAgKiAgIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGJvdW5kczogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICBsZWZ0OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHJpZ2h0OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHRvcDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgICBib3R0b206IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXJcbiAgfSksIF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsIF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbZmFsc2VdKV0pLFxuICBkZWZhdWx0Q2xhc3NOYW1lOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICBkZWZhdWx0Q2xhc3NOYW1lRHJhZ2dpbmc6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIGRlZmF1bHRDbGFzc05hbWVEcmFnZ2VkOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICAvKipcbiAgICogYGRlZmF1bHRQb3NpdGlvbmAgc3BlY2lmaWVzIHRoZSB4IGFuZCB5IHRoYXQgdGhlIGRyYWdnZWQgaXRlbSBzaG91bGQgc3RhcnQgYXRcbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBganN4XG4gICAqICAgICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAqICAgICAgICAgICAgICByZXR1cm4gKFxuICAgKiAgICAgICAgICAgICAgICAgIDxEcmFnZ2FibGUgZGVmYXVsdFBvc2l0aW9uPXt7eDogMjUsIHk6IDI1fX0+XG4gICAqICAgICAgICAgICAgICAgICAgICAgIDxkaXY+SSBzdGFydCB3aXRoIHRyYW5zZm9ybVg6IDI1cHggYW5kIHRyYW5zZm9ybVk6IDI1cHg7PC9kaXY+XG4gICAqICAgICAgICAgICAgICAgICAgPC9EcmFnZ2FibGU+XG4gICAqICAgICAgICAgICAgICApO1xuICAgKiAgICAgICAgICB9XG4gICAqICAgICAgfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgZGVmYXVsdFBvc2l0aW9uOiBfcHJvcFR5cGVzLmRlZmF1bHQuc2hhcGUoe1xuICAgIHg6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gICAgeTogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlclxuICB9KSxcbiAgcG9zaXRpb25PZmZzZXQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7XG4gICAgeDogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlciwgX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZ10pLFxuICAgIHk6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsIF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmddKVxuICB9KSxcbiAgLyoqXG4gICAqIGBwb3NpdGlvbmAsIGlmIHByZXNlbnQsIGRlZmluZXMgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqICBUaGlzIGlzIHNpbWlsYXIgdG8gaG93IGZvcm0gZWxlbWVudHMgaW4gUmVhY3Qgd29yayAtIGlmIG5vIGBwb3NpdGlvbmAgaXMgc3VwcGxpZWQsIHRoZSBjb21wb25lbnRcbiAgICogIGlzIHVuY29udHJvbGxlZC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBganN4XG4gICAqICAgICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAqICAgICAgICAgICAgICByZXR1cm4gKFxuICAgKiAgICAgICAgICAgICAgICAgIDxEcmFnZ2FibGUgcG9zaXRpb249e3t4OiAyNSwgeTogMjV9fT5cbiAgICogICAgICAgICAgICAgICAgICAgICAgPGRpdj5JIHN0YXJ0IHdpdGggdHJhbnNmb3JtWDogMjVweCBhbmQgdHJhbnNmb3JtWTogMjVweDs8L2Rpdj5cbiAgICogICAgICAgICAgICAgICAgICA8L0RyYWdnYWJsZT5cbiAgICogICAgICAgICAgICAgICk7XG4gICAqICAgICAgICAgIH1cbiAgICogICAgICB9KTtcbiAgICogYGBgXG4gICAqL1xuICBwb3NpdGlvbjogX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICB4OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHk6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXJcbiAgfSksXG4gIC8qKlxuICAgKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBiZSBkZWZpbmVkIG9uIHRoZSBjaGlsZCwgbm90IGhlcmUuXG4gICAqL1xuICBjbGFzc05hbWU6IF9zaGltcy5kb250U2V0TWUsXG4gIHN0eWxlOiBfc2hpbXMuZG9udFNldE1lLFxuICB0cmFuc2Zvcm06IF9zaGltcy5kb250U2V0TWVcbn0pO1xuX2RlZmluZVByb3BlcnR5KERyYWdnYWJsZSwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICAuLi5fRHJhZ2dhYmxlQ29yZS5kZWZhdWx0LmRlZmF1bHRQcm9wcyxcbiAgYXhpczogJ2JvdGgnLFxuICBib3VuZHM6IGZhbHNlLFxuICBkZWZhdWx0Q2xhc3NOYW1lOiAncmVhY3QtZHJhZ2dhYmxlJyxcbiAgZGVmYXVsdENsYXNzTmFtZURyYWdnaW5nOiAncmVhY3QtZHJhZ2dhYmxlLWRyYWdnaW5nJyxcbiAgZGVmYXVsdENsYXNzTmFtZURyYWdnZWQ6ICdyZWFjdC1kcmFnZ2FibGUtZHJhZ2dlZCcsXG4gIGRlZmF1bHRQb3NpdGlvbjoge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9LFxuICBzY2FsZTogMVxufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/react-draggable/build/cjs/Draggable.js\n");

/***/ }),

/***/ "../../node_modules/react-draggable/build/cjs/DraggableCore.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/react-draggable/build/cjs/DraggableCore.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"../../node_modules/prop-types/index.js\"));\nvar _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ \"webpack/sharing/consume/default/react-dom/react-dom\"));\nvar _domFns = __webpack_require__(/*! ./utils/domFns */ \"../../node_modules/react-draggable/build/cjs/utils/domFns.js\");\nvar _positionFns = __webpack_require__(/*! ./utils/positionFns */ \"../../node_modules/react-draggable/build/cjs/utils/positionFns.js\");\nvar _shims = __webpack_require__(/*! ./utils/shims */ \"../../node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _log = _interopRequireDefault(__webpack_require__(/*! ./utils/log */ \"../../node_modules/react-draggable/build/cjs/utils/log.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*:: import type {EventHandler, MouseTouchEvent} from './utils/types';*/\n/*:: import type {Element as ReactElement} from 'react';*/\n// Simple abstraction for dragging events names.\nconst eventsFor = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    stop: 'touchend'\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    stop: 'mouseup'\n  }\n};\n\n// Default to mouse events.\nlet dragEventFor = eventsFor.mouse;\n/*:: export type DraggableData = {\n  node: HTMLElement,\n  x: number, y: number,\n  deltaX: number, deltaY: number,\n  lastX: number, lastY: number,\n};*/\n/*:: export type DraggableEventHandler = (e: MouseEvent, data: DraggableData) => void | false;*/\n/*:: export type ControlPosition = {x: number, y: number};*/\n/*:: export type PositionOffsetControlPosition = {x: number|string, y: number|string};*/\n/*:: export type DraggableCoreDefaultProps = {\n  allowAnyClick: boolean,\n  disabled: boolean,\n  enableUserSelectHack: boolean,\n  onStart: DraggableEventHandler,\n  onDrag: DraggableEventHandler,\n  onStop: DraggableEventHandler,\n  onMouseDown: (e: MouseEvent) => void,\n  scale: number,\n};*/\n/*:: export type DraggableCoreProps = {\n  ...DraggableCoreDefaultProps,\n  cancel: string,\n  children: ReactElement<any>,\n  offsetParent: HTMLElement,\n  grid: [number, number],\n  handle: string,\n  nodeRef?: ?React.ElementRef<any>,\n};*/\n//\n// Define <DraggableCore>.\n//\n// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can\n// work well with libraries that require more control over the element.\n//\n\nclass DraggableCore extends React.Component /*:: <DraggableCoreProps>*/{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"dragging\", false);\n    // Used while dragging to determine deltas.\n    _defineProperty(this, \"lastX\", NaN);\n    _defineProperty(this, \"lastY\", NaN);\n    _defineProperty(this, \"touchIdentifier\", null);\n    _defineProperty(this, \"mounted\", false);\n    _defineProperty(this, \"handleDragStart\", e => {\n      // Make it possible to attach event handlers on top of this one.\n      this.props.onMouseDown(e);\n\n      // Only accept left-clicks.\n      if (!this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false;\n\n      // Get nodes. Be sure to grab relative document (could be iframed)\n      const thisNode = this.findDOMNode();\n      if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {\n        throw new Error('<DraggableCore> not mounted on DragStart!');\n      }\n      const {\n        ownerDocument\n      } = thisNode;\n\n      // Short circuit if handle or cancel prop was provided and selector doesn't match.\n      if (this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.handle, thisNode) || this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.cancel, thisNode)) {\n        return;\n      }\n\n      // Prevent scrolling on mobile devices, like ipad/iphone.\n      // Important that this is after handle/cancel.\n      if (e.type === 'touchstart') e.preventDefault();\n\n      // Set touch identifier in component state if this is a touch event. This allows us to\n      // distinguish between individual touches on multitouch screens by identifying which\n      // touchpoint was set to this element.\n      const touchIdentifier = (0, _domFns.getTouchIdentifier)(e);\n      this.touchIdentifier = touchIdentifier;\n\n      // Get the current drag point from the event. This is used as the offset.\n      const position = (0, _positionFns.getControlPosition)(e, touchIdentifier, this);\n      if (position == null) return; // not possible but satisfies flow\n      const {\n        x,\n        y\n      } = position;\n\n      // Create an event object with all the data parents need to make a decision here.\n      const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n      (0, _log.default)('DraggableCore: handleDragStart: %j', coreEvent);\n\n      // Call event handler. If it returns explicit false, cancel.\n      (0, _log.default)('calling', this.props.onStart);\n      const shouldUpdate = this.props.onStart(e, coreEvent);\n      if (shouldUpdate === false || this.mounted === false) return;\n\n      // Add a style to the body to disable user-select. This prevents text from\n      // being selected all over the page.\n      if (this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument);\n\n      // Initiate dragging. Set the current x and y as offsets\n      // so we know how much we've moved during the drag. This allows us\n      // to drag elements around even if they have been moved, without issue.\n      this.dragging = true;\n      this.lastX = x;\n      this.lastY = y;\n\n      // Add events to the document directly so we catch when the user's mouse/touch moves outside of\n      // this element. We use different events depending on whether or not we have detected that this\n      // is a touch-capable device.\n      (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, this.handleDrag);\n      (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, this.handleDragStop);\n    });\n    _defineProperty(this, \"handleDrag\", e => {\n      // Get the current drag point from the event. This is used as the offset.\n      const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);\n      if (position == null) return;\n      let {\n        x,\n        y\n      } = position;\n\n      // Snap to grid if prop has been provided\n      if (Array.isArray(this.props.grid)) {\n        let deltaX = x - this.lastX,\n          deltaY = y - this.lastY;\n        [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);\n        if (!deltaX && !deltaY) return; // skip useless drag\n        x = this.lastX + deltaX, y = this.lastY + deltaY;\n      }\n      const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n      (0, _log.default)('DraggableCore: handleDrag: %j', coreEvent);\n\n      // Call event handler. If it returns explicit false, trigger end.\n      const shouldUpdate = this.props.onDrag(e, coreEvent);\n      if (shouldUpdate === false || this.mounted === false) {\n        try {\n          // $FlowIgnore\n          this.handleDragStop(new MouseEvent('mouseup'));\n        } catch (err) {\n          // Old browsers\n          const event = ((document.createEvent('MouseEvents') /*: any*/) /*: MouseTouchEvent*/);\n          // I see why this insanity was deprecated\n          // $FlowIgnore\n          event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n          this.handleDragStop(event);\n        }\n        return;\n      }\n      this.lastX = x;\n      this.lastY = y;\n    });\n    _defineProperty(this, \"handleDragStop\", e => {\n      if (!this.dragging) return;\n      const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);\n      if (position == null) return;\n      let {\n        x,\n        y\n      } = position;\n\n      // Snap to grid if prop has been provided\n      if (Array.isArray(this.props.grid)) {\n        let deltaX = x - this.lastX || 0;\n        let deltaY = y - this.lastY || 0;\n        [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);\n        x = this.lastX + deltaX, y = this.lastY + deltaY;\n      }\n      const coreEvent = (0, _positionFns.createCoreData)(this, x, y);\n\n      // Call event handler\n      const shouldContinue = this.props.onStop(e, coreEvent);\n      if (shouldContinue === false || this.mounted === false) return false;\n      const thisNode = this.findDOMNode();\n      if (thisNode) {\n        // Remove user-select hack\n        if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);\n      }\n      (0, _log.default)('DraggableCore: handleDragStop: %j', coreEvent);\n\n      // Reset the el.\n      this.dragging = false;\n      this.lastX = NaN;\n      this.lastY = NaN;\n      if (thisNode) {\n        // Remove event handlers\n        (0, _log.default)('DraggableCore: Removing handlers');\n        (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);\n        (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);\n      }\n    });\n    _defineProperty(this, \"onMouseDown\", e => {\n      dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse\n\n      return this.handleDragStart(e);\n    });\n    _defineProperty(this, \"onMouseUp\", e => {\n      dragEventFor = eventsFor.mouse;\n      return this.handleDragStop(e);\n    });\n    // Same as onMouseDown (start drag), but now consider this a touch device.\n    _defineProperty(this, \"onTouchStart\", e => {\n      // We're on a touch device now, so change the event handlers\n      dragEventFor = eventsFor.touch;\n      return this.handleDragStart(e);\n    });\n    _defineProperty(this, \"onTouchEnd\", e => {\n      // We're on a touch device now, so change the event handlers\n      dragEventFor = eventsFor.touch;\n      return this.handleDragStop(e);\n    });\n  }\n  componentDidMount() {\n    this.mounted = true;\n    // Touch handlers must be added with {passive: false} to be cancelable.\n    // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n    const thisNode = this.findDOMNode();\n    if (thisNode) {\n      (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n        passive: false\n      });\n    }\n  }\n  componentWillUnmount() {\n    this.mounted = false;\n    // Remove any leftover event handlers. Remove both touch and mouse handlers in case\n    // some browser quirk caused a touch event to fire during a mouse move, or vice versa.\n    const thisNode = this.findDOMNode();\n    if (thisNode) {\n      const {\n        ownerDocument\n      } = thisNode;\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);\n      (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);\n      (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {\n        passive: false\n      });\n      if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument);\n    }\n  }\n\n  // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find\n  // the underlying DOM node ourselves. See the README for more information.\n  findDOMNode() /*: ?HTMLElement*/{\n    var _this$props, _this$props2;\n    return (_this$props = this.props) !== null && _this$props !== void 0 && _this$props.nodeRef ? (_this$props2 = this.props) === null || _this$props2 === void 0 || (_this$props2 = _this$props2.nodeRef) === null || _this$props2 === void 0 ? void 0 : _this$props2.current : _reactDom.default.findDOMNode(this);\n  }\n  render() /*: React.Element<any>*/{\n    // Reuse the child provided\n    // This makes it flexible to use whatever element is wanted (div, ul, etc)\n    return /*#__PURE__*/React.cloneElement(React.Children.only(this.props.children), {\n      // Note: mouseMove handler is attached to document so it will still function\n      // when the user drags quickly and leaves the bounds of the element.\n      onMouseDown: this.onMouseDown,\n      onMouseUp: this.onMouseUp,\n      // onTouchStart is added on `componentDidMount` so they can be added with\n      // {passive: false}, which allows it to cancel. See\n      // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n      onTouchEnd: this.onTouchEnd\n    });\n  }\n}\nexports[\"default\"] = DraggableCore;\n_defineProperty(DraggableCore, \"displayName\", 'DraggableCore');\n_defineProperty(DraggableCore, \"propTypes\", {\n  /**\n   * `allowAnyClick` allows dragging using any mouse button.\n   * By default, we only accept the left button.\n   *\n   * Defaults to `false`.\n   */\n  allowAnyClick: _propTypes.default.bool,\n  children: _propTypes.default.node.isRequired,\n  /**\n   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,\n   * with the exception of `onMouseDown`, will not fire.\n   */\n  disabled: _propTypes.default.bool,\n  /**\n   * By default, we add 'user-select:none' attributes to the document body\n   * to prevent ugly text selection during drag. If this is causing problems\n   * for your app, set this to `false`.\n   */\n  enableUserSelectHack: _propTypes.default.bool,\n  /**\n   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets\n   * instead of using the parent node.\n   */\n  offsetParent: function (props /*: DraggableCoreProps*/, propName /*: $Keys<DraggableCoreProps>*/) {\n    if (props[propName] && props[propName].nodeType !== 1) {\n      throw new Error('Draggable\\'s offsetParent must be a DOM Node.');\n    }\n  },\n  /**\n   * `grid` specifies the x and y that dragging should snap to.\n   */\n  grid: _propTypes.default.arrayOf(_propTypes.default.number),\n  /**\n   * `handle` specifies a selector to be used as the handle that initiates drag.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *         return (\n   *            <Draggable handle=\".handle\">\n   *              <div>\n   *                  <div className=\"handle\">Click me to drag</div>\n   *                  <div>This is some other content</div>\n   *              </div>\n   *           </Draggable>\n   *         );\n   *       }\n   *   });\n   * ```\n   */\n  handle: _propTypes.default.string,\n  /**\n   * `cancel` specifies a selector to be used to prevent drag initialization.\n   *\n   * Example:\n   *\n   * ```jsx\n   *   let App = React.createClass({\n   *       render: function () {\n   *           return(\n   *               <Draggable cancel=\".cancel\">\n   *                   <div>\n   *                     <div className=\"cancel\">You can't drag from here</div>\n   *                     <div>Dragging here works fine</div>\n   *                   </div>\n   *               </Draggable>\n   *           );\n   *       }\n   *   });\n   * ```\n   */\n  cancel: _propTypes.default.string,\n  /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.\n   * Unfortunately, in order for <Draggable> to work properly, we need raw access\n   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`\n   * as in this example:\n   *\n   * function MyComponent() {\n   *   const nodeRef = React.useRef(null);\n   *   return (\n   *     <Draggable nodeRef={nodeRef}>\n   *       <div ref={nodeRef}>Example Target</div>\n   *     </Draggable>\n   *   );\n   * }\n   *\n   * This can be used for arbitrarily nested components, so long as the ref ends up\n   * pointing to the actual child DOM node and not a custom component.\n   */\n  nodeRef: _propTypes.default.object,\n  /**\n   * Called when dragging starts.\n   * If this function returns the boolean false, dragging will be canceled.\n   */\n  onStart: _propTypes.default.func,\n  /**\n   * Called while dragging.\n   * If this function returns the boolean false, dragging will be canceled.\n   */\n  onDrag: _propTypes.default.func,\n  /**\n   * Called when dragging stops.\n   * If this function returns the boolean false, the drag will remain active.\n   */\n  onStop: _propTypes.default.func,\n  /**\n   * A workaround option which can be passed if onMouseDown needs to be accessed,\n   * since it'll always be blocked (as there is internal use of onMouseDown)\n   */\n  onMouseDown: _propTypes.default.func,\n  /**\n   * `scale`, if set, applies scaling while dragging an element\n   */\n  scale: _propTypes.default.number,\n  /**\n   * These properties should be defined on the child, not here.\n   */\n  className: _shims.dontSetMe,\n  style: _shims.dontSetMe,\n  transform: _shims.dontSetMe\n});\n_defineProperty(DraggableCore, \"defaultProps\", {\n  allowAnyClick: false,\n  // by default only accept left click\n  disabled: false,\n  enableUserSelectHack: true,\n  onStart: function () {},\n  onDrag: function () {},\n  onStop: function () {},\n  onMouseDown: function () {},\n  scale: 1\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWdnYWJsZS9idWlsZC9janMvRHJhZ2dhYmxlQ29yZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9zdC8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9EcmFnZ2FibGVDb3JlLmpzPzRjZjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbnZhciBfcmVhY3REb20gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xudmFyIF9kb21GbnMgPSByZXF1aXJlKFwiLi91dGlscy9kb21GbnNcIik7XG52YXIgX3Bvc2l0aW9uRm5zID0gcmVxdWlyZShcIi4vdXRpbHMvcG9zaXRpb25GbnNcIik7XG52YXIgX3NoaW1zID0gcmVxdWlyZShcIi4vdXRpbHMvc2hpbXNcIik7XG52YXIgX2xvZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvbG9nXCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbi8qOjogaW1wb3J0IHR5cGUge0V2ZW50SGFuZGxlciwgTW91c2VUb3VjaEV2ZW50fSBmcm9tICcuL3V0aWxzL3R5cGVzJzsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7RWxlbWVudCBhcyBSZWFjdEVsZW1lbnR9IGZyb20gJ3JlYWN0JzsqL1xuLy8gU2ltcGxlIGFic3RyYWN0aW9uIGZvciBkcmFnZ2luZyBldmVudHMgbmFtZXMuXG5jb25zdCBldmVudHNGb3IgPSB7XG4gIHRvdWNoOiB7XG4gICAgc3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgICBtb3ZlOiAndG91Y2htb3ZlJyxcbiAgICBzdG9wOiAndG91Y2hlbmQnXG4gIH0sXG4gIG1vdXNlOiB7XG4gICAgc3RhcnQ6ICdtb3VzZWRvd24nLFxuICAgIG1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIHN0b3A6ICdtb3VzZXVwJ1xuICB9XG59O1xuXG4vLyBEZWZhdWx0IHRvIG1vdXNlIGV2ZW50cy5cbmxldCBkcmFnRXZlbnRGb3IgPSBldmVudHNGb3IubW91c2U7XG4vKjo6IGV4cG9ydCB0eXBlIERyYWdnYWJsZURhdGEgPSB7XG4gIG5vZGU6IEhUTUxFbGVtZW50LFxuICB4OiBudW1iZXIsIHk6IG51bWJlcixcbiAgZGVsdGFYOiBudW1iZXIsIGRlbHRhWTogbnVtYmVyLFxuICBsYXN0WDogbnVtYmVyLCBsYXN0WTogbnVtYmVyLFxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVFdmVudEhhbmRsZXIgPSAoZTogTW91c2VFdmVudCwgZGF0YTogRHJhZ2dhYmxlRGF0YSkgPT4gdm9pZCB8IGZhbHNlOyovXG4vKjo6IGV4cG9ydCB0eXBlIENvbnRyb2xQb3NpdGlvbiA9IHt4OiBudW1iZXIsIHk6IG51bWJlcn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24gPSB7eDogbnVtYmVyfHN0cmluZywgeTogbnVtYmVyfHN0cmluZ307Ki9cbi8qOjogZXhwb3J0IHR5cGUgRHJhZ2dhYmxlQ29yZURlZmF1bHRQcm9wcyA9IHtcbiAgYWxsb3dBbnlDbGljazogYm9vbGVhbixcbiAgZGlzYWJsZWQ6IGJvb2xlYW4sXG4gIGVuYWJsZVVzZXJTZWxlY3RIYWNrOiBib29sZWFuLFxuICBvblN0YXJ0OiBEcmFnZ2FibGVFdmVudEhhbmRsZXIsXG4gIG9uRHJhZzogRHJhZ2dhYmxlRXZlbnRIYW5kbGVyLFxuICBvblN0b3A6IERyYWdnYWJsZUV2ZW50SGFuZGxlcixcbiAgb25Nb3VzZURvd246IChlOiBNb3VzZUV2ZW50KSA9PiB2b2lkLFxuICBzY2FsZTogbnVtYmVyLFxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBEcmFnZ2FibGVDb3JlUHJvcHMgPSB7XG4gIC4uLkRyYWdnYWJsZUNvcmVEZWZhdWx0UHJvcHMsXG4gIGNhbmNlbDogc3RyaW5nLFxuICBjaGlsZHJlbjogUmVhY3RFbGVtZW50PGFueT4sXG4gIG9mZnNldFBhcmVudDogSFRNTEVsZW1lbnQsXG4gIGdyaWQ6IFtudW1iZXIsIG51bWJlcl0sXG4gIGhhbmRsZTogc3RyaW5nLFxuICBub2RlUmVmPzogP1JlYWN0LkVsZW1lbnRSZWY8YW55Pixcbn07Ki9cbi8vXG4vLyBEZWZpbmUgPERyYWdnYWJsZUNvcmU+LlxuLy9cbi8vIDxEcmFnZ2FibGVDb3JlPiBpcyBmb3IgYWR2YW5jZWQgdXNhZ2Ugb2YgPERyYWdnYWJsZT4uIEl0IG1haW50YWlucyBtaW5pbWFsIGludGVybmFsIHN0YXRlIHNvIGl0IGNhblxuLy8gd29yayB3ZWxsIHdpdGggbGlicmFyaWVzIHRoYXQgcmVxdWlyZSBtb3JlIGNvbnRyb2wgb3ZlciB0aGUgZWxlbWVudC5cbi8vXG5cbmNsYXNzIERyYWdnYWJsZUNvcmUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgLyo6OiA8RHJhZ2dhYmxlQ29yZVByb3BzPiove1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRyYWdnaW5nXCIsIGZhbHNlKTtcbiAgICAvLyBVc2VkIHdoaWxlIGRyYWdnaW5nIHRvIGRldGVybWluZSBkZWx0YXMuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibGFzdFhcIiwgTmFOKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJsYXN0WVwiLCBOYU4pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvdWNoSWRlbnRpZmllclwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb3VudGVkXCIsIGZhbHNlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVEcmFnU3RhcnRcIiwgZSA9PiB7XG4gICAgICAvLyBNYWtlIGl0IHBvc3NpYmxlIHRvIGF0dGFjaCBldmVudCBoYW5kbGVycyBvbiB0b3Agb2YgdGhpcyBvbmUuXG4gICAgICB0aGlzLnByb3BzLm9uTW91c2VEb3duKGUpO1xuXG4gICAgICAvLyBPbmx5IGFjY2VwdCBsZWZ0LWNsaWNrcy5cbiAgICAgIGlmICghdGhpcy5wcm9wcy5hbGxvd0FueUNsaWNrICYmIHR5cGVvZiBlLmJ1dHRvbiA9PT0gJ251bWJlcicgJiYgZS5idXR0b24gIT09IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gR2V0IG5vZGVzLiBCZSBzdXJlIHRvIGdyYWIgcmVsYXRpdmUgZG9jdW1lbnQgKGNvdWxkIGJlIGlmcmFtZWQpXG4gICAgICBjb25zdCB0aGlzTm9kZSA9IHRoaXMuZmluZERPTU5vZGUoKTtcbiAgICAgIGlmICghdGhpc05vZGUgfHwgIXRoaXNOb2RlLm93bmVyRG9jdW1lbnQgfHwgIXRoaXNOb2RlLm93bmVyRG9jdW1lbnQuYm9keSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzxEcmFnZ2FibGVDb3JlPiBub3QgbW91bnRlZCBvbiBEcmFnU3RhcnQhJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG93bmVyRG9jdW1lbnRcbiAgICAgIH0gPSB0aGlzTm9kZTtcblxuICAgICAgLy8gU2hvcnQgY2lyY3VpdCBpZiBoYW5kbGUgb3IgY2FuY2VsIHByb3Agd2FzIHByb3ZpZGVkIGFuZCBzZWxlY3RvciBkb2Vzbid0IG1hdGNoLlxuICAgICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZWQgfHwgIShlLnRhcmdldCBpbnN0YW5jZW9mIG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuTm9kZSkgfHwgdGhpcy5wcm9wcy5oYW5kbGUgJiYgISgwLCBfZG9tRm5zLm1hdGNoZXNTZWxlY3RvckFuZFBhcmVudHNUbykoZS50YXJnZXQsIHRoaXMucHJvcHMuaGFuZGxlLCB0aGlzTm9kZSkgfHwgdGhpcy5wcm9wcy5jYW5jZWwgJiYgKDAsIF9kb21GbnMubWF0Y2hlc1NlbGVjdG9yQW5kUGFyZW50c1RvKShlLnRhcmdldCwgdGhpcy5wcm9wcy5jYW5jZWwsIHRoaXNOb2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nIG9uIG1vYmlsZSBkZXZpY2VzLCBsaWtlIGlwYWQvaXBob25lLlxuICAgICAgLy8gSW1wb3J0YW50IHRoYXQgdGhpcyBpcyBhZnRlciBoYW5kbGUvY2FuY2VsLlxuICAgICAgaWYgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIC8vIFNldCB0b3VjaCBpZGVudGlmaWVyIGluIGNvbXBvbmVudCBzdGF0ZSBpZiB0aGlzIGlzIGEgdG91Y2ggZXZlbnQuIFRoaXMgYWxsb3dzIHVzIHRvXG4gICAgICAvLyBkaXN0aW5ndWlzaCBiZXR3ZWVuIGluZGl2aWR1YWwgdG91Y2hlcyBvbiBtdWx0aXRvdWNoIHNjcmVlbnMgYnkgaWRlbnRpZnlpbmcgd2hpY2hcbiAgICAgIC8vIHRvdWNocG9pbnQgd2FzIHNldCB0byB0aGlzIGVsZW1lbnQuXG4gICAgICBjb25zdCB0b3VjaElkZW50aWZpZXIgPSAoMCwgX2RvbUZucy5nZXRUb3VjaElkZW50aWZpZXIpKGUpO1xuICAgICAgdGhpcy50b3VjaElkZW50aWZpZXIgPSB0b3VjaElkZW50aWZpZXI7XG5cbiAgICAgIC8vIEdldCB0aGUgY3VycmVudCBkcmFnIHBvaW50IGZyb20gdGhlIGV2ZW50LiBUaGlzIGlzIHVzZWQgYXMgdGhlIG9mZnNldC5cbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gKDAsIF9wb3NpdGlvbkZucy5nZXRDb250cm9sUG9zaXRpb24pKGUsIHRvdWNoSWRlbnRpZmllciwgdGhpcyk7XG4gICAgICBpZiAocG9zaXRpb24gPT0gbnVsbCkgcmV0dXJuOyAvLyBub3QgcG9zc2libGUgYnV0IHNhdGlzZmllcyBmbG93XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBwb3NpdGlvbjtcblxuICAgICAgLy8gQ3JlYXRlIGFuIGV2ZW50IG9iamVjdCB3aXRoIGFsbCB0aGUgZGF0YSBwYXJlbnRzIG5lZWQgdG8gbWFrZSBhIGRlY2lzaW9uIGhlcmUuXG4gICAgICBjb25zdCBjb3JlRXZlbnQgPSAoMCwgX3Bvc2l0aW9uRm5zLmNyZWF0ZUNvcmVEYXRhKSh0aGlzLCB4LCB5KTtcbiAgICAgICgwLCBfbG9nLmRlZmF1bHQpKCdEcmFnZ2FibGVDb3JlOiBoYW5kbGVEcmFnU3RhcnQ6ICVqJywgY29yZUV2ZW50KTtcblxuICAgICAgLy8gQ2FsbCBldmVudCBoYW5kbGVyLiBJZiBpdCByZXR1cm5zIGV4cGxpY2l0IGZhbHNlLCBjYW5jZWwuXG4gICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnY2FsbGluZycsIHRoaXMucHJvcHMub25TdGFydCk7XG4gICAgICBjb25zdCBzaG91bGRVcGRhdGUgPSB0aGlzLnByb3BzLm9uU3RhcnQoZSwgY29yZUV2ZW50KTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGUgPT09IGZhbHNlIHx8IHRoaXMubW91bnRlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgLy8gQWRkIGEgc3R5bGUgdG8gdGhlIGJvZHkgdG8gZGlzYWJsZSB1c2VyLXNlbGVjdC4gVGhpcyBwcmV2ZW50cyB0ZXh0IGZyb21cbiAgICAgIC8vIGJlaW5nIHNlbGVjdGVkIGFsbCBvdmVyIHRoZSBwYWdlLlxuICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLmFkZFVzZXJTZWxlY3RTdHlsZXMpKG93bmVyRG9jdW1lbnQpO1xuXG4gICAgICAvLyBJbml0aWF0ZSBkcmFnZ2luZy4gU2V0IHRoZSBjdXJyZW50IHggYW5kIHkgYXMgb2Zmc2V0c1xuICAgICAgLy8gc28gd2Uga25vdyBob3cgbXVjaCB3ZSd2ZSBtb3ZlZCBkdXJpbmcgdGhlIGRyYWcuIFRoaXMgYWxsb3dzIHVzXG4gICAgICAvLyB0byBkcmFnIGVsZW1lbnRzIGFyb3VuZCBldmVuIGlmIHRoZXkgaGF2ZSBiZWVuIG1vdmVkLCB3aXRob3V0IGlzc3VlLlxuICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB0aGlzLmxhc3RYID0geDtcbiAgICAgIHRoaXMubGFzdFkgPSB5O1xuXG4gICAgICAvLyBBZGQgZXZlbnRzIHRvIHRoZSBkb2N1bWVudCBkaXJlY3RseSBzbyB3ZSBjYXRjaCB3aGVuIHRoZSB1c2VyJ3MgbW91c2UvdG91Y2ggbW92ZXMgb3V0c2lkZSBvZlxuICAgICAgLy8gdGhpcyBlbGVtZW50LiBXZSB1c2UgZGlmZmVyZW50IGV2ZW50cyBkZXBlbmRpbmcgb24gd2hldGhlciBvciBub3Qgd2UgaGF2ZSBkZXRlY3RlZCB0aGF0IHRoaXNcbiAgICAgIC8vIGlzIGEgdG91Y2gtY2FwYWJsZSBkZXZpY2UuXG4gICAgICAoMCwgX2RvbUZucy5hZGRFdmVudCkob3duZXJEb2N1bWVudCwgZHJhZ0V2ZW50Rm9yLm1vdmUsIHRoaXMuaGFuZGxlRHJhZyk7XG4gICAgICAoMCwgX2RvbUZucy5hZGRFdmVudCkob3duZXJEb2N1bWVudCwgZHJhZ0V2ZW50Rm9yLnN0b3AsIHRoaXMuaGFuZGxlRHJhZ1N0b3ApO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZURyYWdcIiwgZSA9PiB7XG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgZHJhZyBwb2ludCBmcm9tIHRoZSBldmVudC4gVGhpcyBpcyB1c2VkIGFzIHRoZSBvZmZzZXQuXG4gICAgICBjb25zdCBwb3NpdGlvbiA9ICgwLCBfcG9zaXRpb25GbnMuZ2V0Q29udHJvbFBvc2l0aW9uKShlLCB0aGlzLnRvdWNoSWRlbnRpZmllciwgdGhpcyk7XG4gICAgICBpZiAocG9zaXRpb24gPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgbGV0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHBvc2l0aW9uO1xuXG4gICAgICAvLyBTbmFwIHRvIGdyaWQgaWYgcHJvcCBoYXMgYmVlbiBwcm92aWRlZFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5wcm9wcy5ncmlkKSkge1xuICAgICAgICBsZXQgZGVsdGFYID0geCAtIHRoaXMubGFzdFgsXG4gICAgICAgICAgZGVsdGFZID0geSAtIHRoaXMubGFzdFk7XG4gICAgICAgIFtkZWx0YVgsIGRlbHRhWV0gPSAoMCwgX3Bvc2l0aW9uRm5zLnNuYXBUb0dyaWQpKHRoaXMucHJvcHMuZ3JpZCwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICBpZiAoIWRlbHRhWCAmJiAhZGVsdGFZKSByZXR1cm47IC8vIHNraXAgdXNlbGVzcyBkcmFnXG4gICAgICAgIHggPSB0aGlzLmxhc3RYICsgZGVsdGFYLCB5ID0gdGhpcy5sYXN0WSArIGRlbHRhWTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvcmVFdmVudCA9ICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlQ29yZURhdGEpKHRoaXMsIHgsIHkpO1xuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZUNvcmU6IGhhbmRsZURyYWc6ICVqJywgY29yZUV2ZW50KTtcblxuICAgICAgLy8gQ2FsbCBldmVudCBoYW5kbGVyLiBJZiBpdCByZXR1cm5zIGV4cGxpY2l0IGZhbHNlLCB0cmlnZ2VyIGVuZC5cbiAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZSA9IHRoaXMucHJvcHMub25EcmFnKGUsIGNvcmVFdmVudCk7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlID09PSBmYWxzZSB8fCB0aGlzLm1vdW50ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gJEZsb3dJZ25vcmVcbiAgICAgICAgICB0aGlzLmhhbmRsZURyYWdTdG9wKG5ldyBNb3VzZUV2ZW50KCdtb3VzZXVwJykpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBPbGQgYnJvd3NlcnNcbiAgICAgICAgICBjb25zdCBldmVudCA9ICgoZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJykgLyo6IGFueSovKSAvKjogTW91c2VUb3VjaEV2ZW50Ki8pO1xuICAgICAgICAgIC8vIEkgc2VlIHdoeSB0aGlzIGluc2FuaXR5IHdhcyBkZXByZWNhdGVkXG4gICAgICAgICAgLy8gJEZsb3dJZ25vcmVcbiAgICAgICAgICBldmVudC5pbml0TW91c2VFdmVudCgnbW91c2V1cCcsIHRydWUsIHRydWUsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0b3AoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFggPSB4O1xuICAgICAgdGhpcy5sYXN0WSA9IHk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlRHJhZ1N0b3BcIiwgZSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHJldHVybjtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gKDAsIF9wb3NpdGlvbkZucy5nZXRDb250cm9sUG9zaXRpb24pKGUsIHRoaXMudG91Y2hJZGVudGlmaWVyLCB0aGlzKTtcbiAgICAgIGlmIChwb3NpdGlvbiA9PSBudWxsKSByZXR1cm47XG4gICAgICBsZXQge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gcG9zaXRpb247XG5cbiAgICAgIC8vIFNuYXAgdG8gZ3JpZCBpZiBwcm9wIGhhcyBiZWVuIHByb3ZpZGVkXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnByb3BzLmdyaWQpKSB7XG4gICAgICAgIGxldCBkZWx0YVggPSB4IC0gdGhpcy5sYXN0WCB8fCAwO1xuICAgICAgICBsZXQgZGVsdGFZID0geSAtIHRoaXMubGFzdFkgfHwgMDtcbiAgICAgICAgW2RlbHRhWCwgZGVsdGFZXSA9ICgwLCBfcG9zaXRpb25GbnMuc25hcFRvR3JpZCkodGhpcy5wcm9wcy5ncmlkLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIHggPSB0aGlzLmxhc3RYICsgZGVsdGFYLCB5ID0gdGhpcy5sYXN0WSArIGRlbHRhWTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvcmVFdmVudCA9ICgwLCBfcG9zaXRpb25GbnMuY3JlYXRlQ29yZURhdGEpKHRoaXMsIHgsIHkpO1xuXG4gICAgICAvLyBDYWxsIGV2ZW50IGhhbmRsZXJcbiAgICAgIGNvbnN0IHNob3VsZENvbnRpbnVlID0gdGhpcy5wcm9wcy5vblN0b3AoZSwgY29yZUV2ZW50KTtcbiAgICAgIGlmIChzaG91bGRDb250aW51ZSA9PT0gZmFsc2UgfHwgdGhpcy5tb3VudGVkID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgY29uc3QgdGhpc05vZGUgPSB0aGlzLmZpbmRET01Ob2RlKCk7XG4gICAgICBpZiAodGhpc05vZGUpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHVzZXItc2VsZWN0IGhhY2tcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLnJlbW92ZVVzZXJTZWxlY3RTdHlsZXMpKHRoaXNOb2RlLm93bmVyRG9jdW1lbnQpO1xuICAgICAgfVxuICAgICAgKDAsIF9sb2cuZGVmYXVsdCkoJ0RyYWdnYWJsZUNvcmU6IGhhbmRsZURyYWdTdG9wOiAlaicsIGNvcmVFdmVudCk7XG5cbiAgICAgIC8vIFJlc2V0IHRoZSBlbC5cbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMubGFzdFggPSBOYU47XG4gICAgICB0aGlzLmxhc3RZID0gTmFOO1xuICAgICAgaWYgKHRoaXNOb2RlKSB7XG4gICAgICAgIC8vIFJlbW92ZSBldmVudCBoYW5kbGVyc1xuICAgICAgICAoMCwgX2xvZy5kZWZhdWx0KSgnRHJhZ2dhYmxlQ29yZTogUmVtb3ZpbmcgaGFuZGxlcnMnKTtcbiAgICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKHRoaXNOb2RlLm93bmVyRG9jdW1lbnQsIGRyYWdFdmVudEZvci5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuICAgICAgICAoMCwgX2RvbUZucy5yZW1vdmVFdmVudCkodGhpc05vZGUub3duZXJEb2N1bWVudCwgZHJhZ0V2ZW50Rm9yLnN0b3AsIHRoaXMuaGFuZGxlRHJhZ1N0b3ApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uTW91c2VEb3duXCIsIGUgPT4ge1xuICAgICAgZHJhZ0V2ZW50Rm9yID0gZXZlbnRzRm9yLm1vdXNlOyAvLyBvbiB0b3VjaHNjcmVlbiBsYXB0b3BzIHdlIGNvdWxkIHN3aXRjaCBiYWNrIHRvIG1vdXNlXG5cbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZURyYWdTdGFydChlKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbk1vdXNlVXBcIiwgZSA9PiB7XG4gICAgICBkcmFnRXZlbnRGb3IgPSBldmVudHNGb3IubW91c2U7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVEcmFnU3RvcChlKTtcbiAgICB9KTtcbiAgICAvLyBTYW1lIGFzIG9uTW91c2VEb3duIChzdGFydCBkcmFnKSwgYnV0IG5vdyBjb25zaWRlciB0aGlzIGEgdG91Y2ggZGV2aWNlLlxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uVG91Y2hTdGFydFwiLCBlID0+IHtcbiAgICAgIC8vIFdlJ3JlIG9uIGEgdG91Y2ggZGV2aWNlIG5vdywgc28gY2hhbmdlIHRoZSBldmVudCBoYW5kbGVyc1xuICAgICAgZHJhZ0V2ZW50Rm9yID0gZXZlbnRzRm9yLnRvdWNoO1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KGUpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uVG91Y2hFbmRcIiwgZSA9PiB7XG4gICAgICAvLyBXZSdyZSBvbiBhIHRvdWNoIGRldmljZSBub3csIHNvIGNoYW5nZSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgIGRyYWdFdmVudEZvciA9IGV2ZW50c0Zvci50b3VjaDtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZURyYWdTdG9wKGUpO1xuICAgIH0pO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgLy8gVG91Y2ggaGFuZGxlcnMgbXVzdCBiZSBhZGRlZCB3aXRoIHtwYXNzaXZlOiBmYWxzZX0gdG8gYmUgY2FuY2VsYWJsZS5cbiAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE3LzAxL3Njcm9sbGluZy1pbnRlcnZlbnRpb25cbiAgICBjb25zdCB0aGlzTm9kZSA9IHRoaXMuZmluZERPTU5vZGUoKTtcbiAgICBpZiAodGhpc05vZGUpIHtcbiAgICAgICgwLCBfZG9tRm5zLmFkZEV2ZW50KSh0aGlzTm9kZSwgZXZlbnRzRm9yLnRvdWNoLnN0YXJ0LCB0aGlzLm9uVG91Y2hTdGFydCwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgIC8vIFJlbW92ZSBhbnkgbGVmdG92ZXIgZXZlbnQgaGFuZGxlcnMuIFJlbW92ZSBib3RoIHRvdWNoIGFuZCBtb3VzZSBoYW5kbGVycyBpbiBjYXNlXG4gICAgLy8gc29tZSBicm93c2VyIHF1aXJrIGNhdXNlZCBhIHRvdWNoIGV2ZW50IHRvIGZpcmUgZHVyaW5nIGEgbW91c2UgbW92ZSwgb3IgdmljZSB2ZXJzYS5cbiAgICBjb25zdCB0aGlzTm9kZSA9IHRoaXMuZmluZERPTU5vZGUoKTtcbiAgICBpZiAodGhpc05vZGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3duZXJEb2N1bWVudFxuICAgICAgfSA9IHRoaXNOb2RlO1xuICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci5tb3VzZS5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci50b3VjaC5tb3ZlLCB0aGlzLmhhbmRsZURyYWcpO1xuICAgICAgKDAsIF9kb21GbnMucmVtb3ZlRXZlbnQpKG93bmVyRG9jdW1lbnQsIGV2ZW50c0Zvci5tb3VzZS5zdG9wLCB0aGlzLmhhbmRsZURyYWdTdG9wKTtcbiAgICAgICgwLCBfZG9tRm5zLnJlbW92ZUV2ZW50KShvd25lckRvY3VtZW50LCBldmVudHNGb3IudG91Y2guc3RvcCwgdGhpcy5oYW5kbGVEcmFnU3RvcCk7XG4gICAgICAoMCwgX2RvbUZucy5yZW1vdmVFdmVudCkodGhpc05vZGUsIGV2ZW50c0Zvci50b3VjaC5zdGFydCwgdGhpcy5vblRvdWNoU3RhcnQsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlVXNlclNlbGVjdEhhY2spICgwLCBfZG9tRm5zLnJlbW92ZVVzZXJTZWxlY3RTdHlsZXMpKG93bmVyRG9jdW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlYWN0IFN0cmljdCBNb2RlIGNvbXBhdGliaWxpdHk6IGlmIGBub2RlUmVmYCBpcyBwYXNzZWQsIHdlIHdpbGwgdXNlIGl0IGluc3RlYWQgb2YgdHJ5aW5nIHRvIGZpbmRcbiAgLy8gdGhlIHVuZGVybHlpbmcgRE9NIG5vZGUgb3Vyc2VsdmVzLiBTZWUgdGhlIFJFQURNRSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgZmluZERPTU5vZGUoKSAvKjogP0hUTUxFbGVtZW50Ki97XG4gICAgdmFyIF90aGlzJHByb3BzLCBfdGhpcyRwcm9wczI7XG4gICAgcmV0dXJuIChfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMpICE9PSBudWxsICYmIF90aGlzJHByb3BzICE9PSB2b2lkIDAgJiYgX3RoaXMkcHJvcHMubm9kZVJlZiA/IChfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wczIgPT09IHZvaWQgMCB8fCAoX3RoaXMkcHJvcHMyID0gX3RoaXMkcHJvcHMyLm5vZGVSZWYpID09PSBudWxsIHx8IF90aGlzJHByb3BzMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcHJvcHMyLmN1cnJlbnQgOiBfcmVhY3REb20uZGVmYXVsdC5maW5kRE9NTm9kZSh0aGlzKTtcbiAgfVxuICByZW5kZXIoKSAvKjogUmVhY3QuRWxlbWVudDxhbnk+Ki97XG4gICAgLy8gUmV1c2UgdGhlIGNoaWxkIHByb3ZpZGVkXG4gICAgLy8gVGhpcyBtYWtlcyBpdCBmbGV4aWJsZSB0byB1c2Ugd2hhdGV2ZXIgZWxlbWVudCBpcyB3YW50ZWQgKGRpdiwgdWwsIGV0YylcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChSZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pLCB7XG4gICAgICAvLyBOb3RlOiBtb3VzZU1vdmUgaGFuZGxlciBpcyBhdHRhY2hlZCB0byBkb2N1bWVudCBzbyBpdCB3aWxsIHN0aWxsIGZ1bmN0aW9uXG4gICAgICAvLyB3aGVuIHRoZSB1c2VyIGRyYWdzIHF1aWNrbHkgYW5kIGxlYXZlcyB0aGUgYm91bmRzIG9mIHRoZSBlbGVtZW50LlxuICAgICAgb25Nb3VzZURvd246IHRoaXMub25Nb3VzZURvd24sXG4gICAgICBvbk1vdXNlVXA6IHRoaXMub25Nb3VzZVVwLFxuICAgICAgLy8gb25Ub3VjaFN0YXJ0IGlzIGFkZGVkIG9uIGBjb21wb25lbnREaWRNb3VudGAgc28gdGhleSBjYW4gYmUgYWRkZWQgd2l0aFxuICAgICAgLy8ge3Bhc3NpdmU6IGZhbHNlfSwgd2hpY2ggYWxsb3dzIGl0IHRvIGNhbmNlbC4gU2VlXG4gICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE3LzAxL3Njcm9sbGluZy1pbnRlcnZlbnRpb25cbiAgICAgIG9uVG91Y2hFbmQ6IHRoaXMub25Ub3VjaEVuZFxuICAgIH0pO1xuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnZ2FibGVDb3JlO1xuX2RlZmluZVByb3BlcnR5KERyYWdnYWJsZUNvcmUsIFwiZGlzcGxheU5hbWVcIiwgJ0RyYWdnYWJsZUNvcmUnKTtcbl9kZWZpbmVQcm9wZXJ0eShEcmFnZ2FibGVDb3JlLCBcInByb3BUeXBlc1wiLCB7XG4gIC8qKlxuICAgKiBgYWxsb3dBbnlDbGlja2AgYWxsb3dzIGRyYWdnaW5nIHVzaW5nIGFueSBtb3VzZSBidXR0b24uXG4gICAqIEJ5IGRlZmF1bHQsIHdlIG9ubHkgYWNjZXB0IHRoZSBsZWZ0IGJ1dHRvbi5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICovXG4gIGFsbG93QW55Q2xpY2s6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICBjaGlsZHJlbjogX3Byb3BUeXBlcy5kZWZhdWx0Lm5vZGUuaXNSZXF1aXJlZCxcbiAgLyoqXG4gICAqIGBkaXNhYmxlZGAsIGlmIHRydWUsIHN0b3BzIHRoZSA8RHJhZ2dhYmxlPiBmcm9tIGRyYWdnaW5nLiBBbGwgaGFuZGxlcnMsXG4gICAqIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBgb25Nb3VzZURvd25gLCB3aWxsIG5vdCBmaXJlLlxuICAgKi9cbiAgZGlzYWJsZWQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvKipcbiAgICogQnkgZGVmYXVsdCwgd2UgYWRkICd1c2VyLXNlbGVjdDpub25lJyBhdHRyaWJ1dGVzIHRvIHRoZSBkb2N1bWVudCBib2R5XG4gICAqIHRvIHByZXZlbnQgdWdseSB0ZXh0IHNlbGVjdGlvbiBkdXJpbmcgZHJhZy4gSWYgdGhpcyBpcyBjYXVzaW5nIHByb2JsZW1zXG4gICAqIGZvciB5b3VyIGFwcCwgc2V0IHRoaXMgdG8gYGZhbHNlYC5cbiAgICovXG4gIGVuYWJsZVVzZXJTZWxlY3RIYWNrOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLyoqXG4gICAqIGBvZmZzZXRQYXJlbnRgLCBpZiBzZXQsIHVzZXMgdGhlIHBhc3NlZCBET00gbm9kZSB0byBjb21wdXRlIGRyYWcgb2Zmc2V0c1xuICAgKiBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBwYXJlbnQgbm9kZS5cbiAgICovXG4gIG9mZnNldFBhcmVudDogZnVuY3Rpb24gKHByb3BzIC8qOiBEcmFnZ2FibGVDb3JlUHJvcHMqLywgcHJvcE5hbWUgLyo6ICRLZXlzPERyYWdnYWJsZUNvcmVQcm9wcz4qLykge1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gJiYgcHJvcHNbcHJvcE5hbWVdLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RyYWdnYWJsZVxcJ3Mgb2Zmc2V0UGFyZW50IG11c3QgYmUgYSBET00gTm9kZS4nKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBgZ3JpZGAgc3BlY2lmaWVzIHRoZSB4IGFuZCB5IHRoYXQgZHJhZ2dpbmcgc2hvdWxkIHNuYXAgdG8uXG4gICAqL1xuICBncmlkOiBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyKSxcbiAgLyoqXG4gICAqIGBoYW5kbGVgIHNwZWNpZmllcyBhIHNlbGVjdG9yIHRvIGJlIHVzZWQgYXMgdGhlIGhhbmRsZSB0aGF0IGluaXRpYXRlcyBkcmFnLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogICBsZXQgQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICogICAgICAgICByZXR1cm4gKFxuICAgKiAgICAgICAgICAgIDxEcmFnZ2FibGUgaGFuZGxlPVwiLmhhbmRsZVwiPlxuICAgKiAgICAgICAgICAgICAgPGRpdj5cbiAgICogICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhhbmRsZVwiPkNsaWNrIG1lIHRvIGRyYWc8L2Rpdj5cbiAgICogICAgICAgICAgICAgICAgICA8ZGl2PlRoaXMgaXMgc29tZSBvdGhlciBjb250ZW50PC9kaXY+XG4gICAqICAgICAgICAgICAgICA8L2Rpdj5cbiAgICogICAgICAgICAgIDwvRHJhZ2dhYmxlPlxuICAgKiAgICAgICAgICk7XG4gICAqICAgICAgIH1cbiAgICogICB9KTtcbiAgICogYGBgXG4gICAqL1xuICBoYW5kbGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIC8qKlxuICAgKiBgY2FuY2VsYCBzcGVjaWZpZXMgYSBzZWxlY3RvciB0byBiZSB1c2VkIHRvIHByZXZlbnQgZHJhZyBpbml0aWFsaXphdGlvbi5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogYGBganN4XG4gICAqICAgbGV0IEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAqICAgICAgICAgICByZXR1cm4oXG4gICAqICAgICAgICAgICAgICAgPERyYWdnYWJsZSBjYW5jZWw9XCIuY2FuY2VsXCI+XG4gICAqICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYW5jZWxcIj5Zb3UgY2FuJ3QgZHJhZyBmcm9tIGhlcmU8L2Rpdj5cbiAgICogICAgICAgICAgICAgICAgICAgICA8ZGl2PkRyYWdnaW5nIGhlcmUgd29ya3MgZmluZTwvZGl2PlxuICAgKiAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICogICAgICAgICAgICAgICA8L0RyYWdnYWJsZT5cbiAgICogICAgICAgICAgICk7XG4gICAqICAgICAgIH1cbiAgICogICB9KTtcbiAgICogYGBgXG4gICAqL1xuICBjYW5jZWw6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIC8qIElmIHJ1bm5pbmcgaW4gUmVhY3QgU3RyaWN0IG1vZGUsIFJlYWN0RE9NLmZpbmRET01Ob2RlKCkgaXMgZGVwcmVjYXRlZC5cbiAgICogVW5mb3J0dW5hdGVseSwgaW4gb3JkZXIgZm9yIDxEcmFnZ2FibGU+IHRvIHdvcmsgcHJvcGVybHksIHdlIG5lZWQgcmF3IGFjY2Vzc1xuICAgKiB0byB0aGUgdW5kZXJseWluZyBET00gbm9kZS4gSWYgeW91IHdhbnQgdG8gYXZvaWQgdGhlIHdhcm5pbmcsIHBhc3MgYSBgbm9kZVJlZmBcbiAgICogYXMgaW4gdGhpcyBleGFtcGxlOlxuICAgKlxuICAgKiBmdW5jdGlvbiBNeUNvbXBvbmVudCgpIHtcbiAgICogICBjb25zdCBub2RlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgKiAgIHJldHVybiAoXG4gICAqICAgICA8RHJhZ2dhYmxlIG5vZGVSZWY9e25vZGVSZWZ9PlxuICAgKiAgICAgICA8ZGl2IHJlZj17bm9kZVJlZn0+RXhhbXBsZSBUYXJnZXQ8L2Rpdj5cbiAgICogICAgIDwvRHJhZ2dhYmxlPlxuICAgKiAgICk7XG4gICAqIH1cbiAgICpcbiAgICogVGhpcyBjYW4gYmUgdXNlZCBmb3IgYXJiaXRyYXJpbHkgbmVzdGVkIGNvbXBvbmVudHMsIHNvIGxvbmcgYXMgdGhlIHJlZiBlbmRzIHVwXG4gICAqIHBvaW50aW5nIHRvIHRoZSBhY3R1YWwgY2hpbGQgRE9NIG5vZGUgYW5kIG5vdCBhIGN1c3RvbSBjb21wb25lbnQuXG4gICAqL1xuICBub2RlUmVmOiBfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0LFxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gZHJhZ2dpbmcgc3RhcnRzLlxuICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGJvb2xlYW4gZmFsc2UsIGRyYWdnaW5nIHdpbGwgYmUgY2FuY2VsZWQuXG4gICAqL1xuICBvblN0YXJ0OiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLyoqXG4gICAqIENhbGxlZCB3aGlsZSBkcmFnZ2luZy5cbiAgICogSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBib29sZWFuIGZhbHNlLCBkcmFnZ2luZyB3aWxsIGJlIGNhbmNlbGVkLlxuICAgKi9cbiAgb25EcmFnOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGRyYWdnaW5nIHN0b3BzLlxuICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGJvb2xlYW4gZmFsc2UsIHRoZSBkcmFnIHdpbGwgcmVtYWluIGFjdGl2ZS5cbiAgICovXG4gIG9uU3RvcDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8qKlxuICAgKiBBIHdvcmthcm91bmQgb3B0aW9uIHdoaWNoIGNhbiBiZSBwYXNzZWQgaWYgb25Nb3VzZURvd24gbmVlZHMgdG8gYmUgYWNjZXNzZWQsXG4gICAqIHNpbmNlIGl0J2xsIGFsd2F5cyBiZSBibG9ja2VkIChhcyB0aGVyZSBpcyBpbnRlcm5hbCB1c2Ugb2Ygb25Nb3VzZURvd24pXG4gICAqL1xuICBvbk1vdXNlRG93bjogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8qKlxuICAgKiBgc2NhbGVgLCBpZiBzZXQsIGFwcGxpZXMgc2NhbGluZyB3aGlsZSBkcmFnZ2luZyBhbiBlbGVtZW50XG4gICAqL1xuICBzY2FsZTogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgLyoqXG4gICAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIGJlIGRlZmluZWQgb24gdGhlIGNoaWxkLCBub3QgaGVyZS5cbiAgICovXG4gIGNsYXNzTmFtZTogX3NoaW1zLmRvbnRTZXRNZSxcbiAgc3R5bGU6IF9zaGltcy5kb250U2V0TWUsXG4gIHRyYW5zZm9ybTogX3NoaW1zLmRvbnRTZXRNZVxufSk7XG5fZGVmaW5lUHJvcGVydHkoRHJhZ2dhYmxlQ29yZSwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBhbGxvd0FueUNsaWNrOiBmYWxzZSxcbiAgLy8gYnkgZGVmYXVsdCBvbmx5IGFjY2VwdCBsZWZ0IGNsaWNrXG4gIGRpc2FibGVkOiBmYWxzZSxcbiAgZW5hYmxlVXNlclNlbGVjdEhhY2s6IHRydWUsXG4gIG9uU3RhcnQ6IGZ1bmN0aW9uICgpIHt9LFxuICBvbkRyYWc6IGZ1bmN0aW9uICgpIHt9LFxuICBvblN0b3A6IGZ1bmN0aW9uICgpIHt9LFxuICBvbk1vdXNlRG93bjogZnVuY3Rpb24gKCkge30sXG4gIHNjYWxlOiAxXG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/react-draggable/build/cjs/DraggableCore.js\n");

/***/ }),

/***/ "../../node_modules/react-draggable/build/cjs/cjs.js":
/*!***********************************************************!*\
  !*** ../../node_modules/react-draggable/build/cjs/cjs.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  default: Draggable,\n  DraggableCore\n} = __webpack_require__(/*! ./Draggable */ \"../../node_modules/react-draggable/build/cjs/Draggable.js\");\n\n// Previous versions of this lib exported <Draggable> as the root export. As to no-// them, or TypeScript, we export *both* as the root and as 'default'.\n// See https://github.com/mzabriskie/react-draggable/pull/254\n// and https://github.com/mzabriskie/react-draggable/issues/266\nmodule.exports = Draggable;\nmodule.exports[\"default\"] = Draggable;\nmodule.exports.DraggableCore = DraggableCore;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWdnYWJsZS9idWlsZC9janMvY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9zdC8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy9janMuanM/OGZhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuY29uc3Qge1xuICBkZWZhdWx0OiBEcmFnZ2FibGUsXG4gIERyYWdnYWJsZUNvcmVcbn0gPSByZXF1aXJlKCcuL0RyYWdnYWJsZScpO1xuXG4vLyBQcmV2aW91cyB2ZXJzaW9ucyBvZiB0aGlzIGxpYiBleHBvcnRlZCA8RHJhZ2dhYmxlPiBhcyB0aGUgcm9vdCBleHBvcnQuIEFzIHRvIG5vLS8vIHRoZW0sIG9yIFR5cGVTY3JpcHQsIHdlIGV4cG9ydCAqYm90aCogYXMgdGhlIHJvb3QgYW5kIGFzICdkZWZhdWx0Jy5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbXphYnJpc2tpZS9yZWFjdC1kcmFnZ2FibGUvcHVsbC8yNTRcbi8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vbXphYnJpc2tpZS9yZWFjdC1kcmFnZ2FibGUvaXNzdWVzLzI2NlxubW9kdWxlLmV4cG9ydHMgPSBEcmFnZ2FibGU7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ2dhYmxlO1xubW9kdWxlLmV4cG9ydHMuRHJhZ2dhYmxlQ29yZSA9IERyYWdnYWJsZUNvcmU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/react-draggable/build/cjs/cjs.js\n");

/***/ }),

/***/ "../../node_modules/react-draggable/build/cjs/utils/domFns.js":
/*!********************************************************************!*\
  !*** ../../node_modules/react-draggable/build/cjs/utils/domFns.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.addClassName = addClassName;\nexports.addEvent = addEvent;\nexports.addUserSelectStyles = addUserSelectStyles;\nexports.createCSSTransform = createCSSTransform;\nexports.createSVGTransform = createSVGTransform;\nexports.getTouch = getTouch;\nexports.getTouchIdentifier = getTouchIdentifier;\nexports.getTranslation = getTranslation;\nexports.innerHeight = innerHeight;\nexports.innerWidth = innerWidth;\nexports.matchesSelector = matchesSelector;\nexports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;\nexports.offsetXYFromParent = offsetXYFromParent;\nexports.outerHeight = outerHeight;\nexports.outerWidth = outerWidth;\nexports.removeClassName = removeClassName;\nexports.removeEvent = removeEvent;\nexports.removeUserSelectStyles = removeUserSelectStyles;\nvar _shims = __webpack_require__(/*! ./shims */ \"../../node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _getPrefix = _interopRequireWildcard(__webpack_require__(/*! ./getPrefix */ \"../../node_modules/react-draggable/build/cjs/utils/getPrefix.js\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/*:: import type {ControlPosition, PositionOffsetControlPosition, MouseTouchEvent} from './types';*/\nlet matchesSelectorFunc = '';\nfunction matchesSelector(el /*: Node*/, selector /*: string*/) /*: boolean*/{\n  if (!matchesSelectorFunc) {\n    matchesSelectorFunc = (0, _shims.findInArray)(['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'], function (method) {\n      // $FlowIgnore: Doesn't think elements are indexable\n      return (0, _shims.isFunction)(el[method]);\n    });\n  }\n\n  // Might not be found entirely (not an Element?) - in that case, bail\n  // $FlowIgnore: Doesn't think elements are indexable\n  if (!(0, _shims.isFunction)(el[matchesSelectorFunc])) return false;\n\n  // $FlowIgnore: Doesn't think elements are indexable\n  return el[matchesSelectorFunc](selector);\n}\n\n// Works up the tree to the draggable itself attempting to match selector.\nfunction matchesSelectorAndParentsTo(el /*: Node*/, selector /*: string*/, baseNode /*: Node*/) /*: boolean*/{\n  let node = el;\n  do {\n    if (matchesSelector(node, selector)) return true;\n    if (node === baseNode) return false;\n    // $FlowIgnore[incompatible-type]\n    node = node.parentNode;\n  } while (node);\n  return false;\n}\nfunction addEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/, inputOptions /*: Object*/) /*: void*/{\n  if (!el) return;\n  const options = {\n    capture: true,\n    ...inputOptions\n  };\n  // $FlowIgnore[method-unbinding]\n  if (el.addEventListener) {\n    el.addEventListener(event, handler, options);\n  } else if (el.attachEvent) {\n    el.attachEvent('on' + event, handler);\n  } else {\n    // $FlowIgnore: Doesn't think elements are indexable\n    el['on' + event] = handler;\n  }\n}\nfunction removeEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/, inputOptions /*: Object*/) /*: void*/{\n  if (!el) return;\n  const options = {\n    capture: true,\n    ...inputOptions\n  };\n  // $FlowIgnore[method-unbinding]\n  if (el.removeEventListener) {\n    el.removeEventListener(event, handler, options);\n  } else if (el.detachEvent) {\n    el.detachEvent('on' + event, handler);\n  } else {\n    // $FlowIgnore: Doesn't think elements are indexable\n    el['on' + event] = null;\n  }\n}\nfunction outerHeight(node /*: HTMLElement*/) /*: number*/{\n  // This is deliberately excluding margin for our calculations, since we are using\n  // offsetTop which is including margin. See getBoundPosition\n  let height = node.clientHeight;\n  const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n  height += (0, _shims.int)(computedStyle.borderTopWidth);\n  height += (0, _shims.int)(computedStyle.borderBottomWidth);\n  return height;\n}\nfunction outerWidth(node /*: HTMLElement*/) /*: number*/{\n  // This is deliberately excluding margin for our calculations, since we are using\n  // offsetLeft which is including margin. See getBoundPosition\n  let width = node.clientWidth;\n  const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n  width += (0, _shims.int)(computedStyle.borderLeftWidth);\n  width += (0, _shims.int)(computedStyle.borderRightWidth);\n  return width;\n}\nfunction innerHeight(node /*: HTMLElement*/) /*: number*/{\n  let height = node.clientHeight;\n  const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n  height -= (0, _shims.int)(computedStyle.paddingTop);\n  height -= (0, _shims.int)(computedStyle.paddingBottom);\n  return height;\n}\nfunction innerWidth(node /*: HTMLElement*/) /*: number*/{\n  let width = node.clientWidth;\n  const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);\n  width -= (0, _shims.int)(computedStyle.paddingLeft);\n  width -= (0, _shims.int)(computedStyle.paddingRight);\n  return width;\n}\n/*:: interface EventWithOffset {\n  clientX: number, clientY: number\n}*/\n// Get from offsetParent\nfunction offsetXYFromParent(evt /*: EventWithOffset*/, offsetParent /*: HTMLElement*/, scale /*: number*/) /*: ControlPosition*/{\n  const isBody = offsetParent === offsetParent.ownerDocument.body;\n  const offsetParentRect = isBody ? {\n    left: 0,\n    top: 0\n  } : offsetParent.getBoundingClientRect();\n  const x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;\n  const y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;\n  return {\n    x,\n    y\n  };\n}\nfunction createCSSTransform(controlPos /*: ControlPosition*/, positionOffset /*: PositionOffsetControlPosition*/) /*: Object*/{\n  const translation = getTranslation(controlPos, positionOffset, 'px');\n  return {\n    [(0, _getPrefix.browserPrefixToKey)('transform', _getPrefix.default)]: translation\n  };\n}\nfunction createSVGTransform(controlPos /*: ControlPosition*/, positionOffset /*: PositionOffsetControlPosition*/) /*: string*/{\n  const translation = getTranslation(controlPos, positionOffset, '');\n  return translation;\n}\nfunction getTranslation(_ref /*:: */, positionOffset /*: PositionOffsetControlPosition*/, unitSuffix /*: string*/) /*: string*/{\n  let {\n    x,\n    y\n  } /*: ControlPosition*/ = _ref /*: ControlPosition*/;\n  let translation = \"translate(\".concat(x).concat(unitSuffix, \",\").concat(y).concat(unitSuffix, \")\");\n  if (positionOffset) {\n    const defaultX = \"\".concat(typeof positionOffset.x === 'string' ? positionOffset.x : positionOffset.x + unitSuffix);\n    const defaultY = \"\".concat(typeof positionOffset.y === 'string' ? positionOffset.y : positionOffset.y + unitSuffix);\n    translation = \"translate(\".concat(defaultX, \", \").concat(defaultY, \")\") + translation;\n  }\n  return translation;\n}\nfunction getTouch(e /*: MouseTouchEvent*/, identifier /*: number*/) /*: ?{clientX: number, clientY: number}*/{\n  return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, t => identifier === t.identifier) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, t => identifier === t.identifier);\n}\nfunction getTouchIdentifier(e /*: MouseTouchEvent*/) /*: ?number*/{\n  if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;\n  if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;\n}\n\n// User-select Hacks:\n//\n// Useful for preventing blue highlights all over everything when dragging.\n\n// Note we're passing `document` b/c we could be iframed\nfunction addUserSelectStyles(doc /*: ?Document*/) {\n  if (!doc) return;\n  let styleEl = doc.getElementById('react-draggable-style-el');\n  if (!styleEl) {\n    styleEl = doc.createElement('style');\n    styleEl.type = 'text/css';\n    styleEl.id = 'react-draggable-style-el';\n    styleEl.innerHTML = '.react-draggable-transparent-selection *::-moz-selection {all: inherit;}\\n';\n    styleEl.innerHTML += '.react-draggable-transparent-selection *::selection {all: inherit;}\\n';\n    doc.getElementsByTagName('head')[0].appendChild(styleEl);\n  }\n  if (doc.body) addClassName(doc.body, 'react-draggable-transparent-selection');\n}\nfunction removeUserSelectStyles(doc /*: ?Document*/) {\n  if (!doc) return;\n  try {\n    if (doc.body) removeClassName(doc.body, 'react-draggable-transparent-selection');\n    // $FlowIgnore: IE\n    if (doc.selection) {\n      // $FlowIgnore: IE\n      doc.selection.empty();\n    } else {\n      // Remove selection caused by scroll, unless it's a focused input\n      // (we use doc.defaultView in case we're in an iframe)\n      const selection = (doc.defaultView || window).getSelection();\n      if (selection && selection.type !== 'Caret') {\n        selection.removeAllRanges();\n      }\n    }\n  } catch (e) {\n    // probably IE\n  }\n}\nfunction addClassName(el /*: HTMLElement*/, className /*: string*/) {\n  if (el.classList) {\n    el.classList.add(className);\n  } else {\n    if (!el.className.match(new RegExp(\"(?:^|\\\\s)\".concat(className, \"(?!\\\\S)\")))) {\n      el.className += \" \".concat(className);\n    }\n  }\n}\nfunction removeClassName(el /*: HTMLElement*/, className /*: string*/) {\n  if (el.classList) {\n    el.classList.remove(className);\n  } else {\n    el.className = el.className.replace(new RegExp(\"(?:^|\\\\s)\".concat(className, \"(?!\\\\S)\"), 'g'), '');\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWdnYWJsZS9idWlsZC9janMvdXRpbHMvZG9tRm5zLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWdnYWJsZS9idWlsZC9janMvdXRpbHMvZG9tRm5zLmpzPzIzOTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFkZENsYXNzTmFtZSA9IGFkZENsYXNzTmFtZTtcbmV4cG9ydHMuYWRkRXZlbnQgPSBhZGRFdmVudDtcbmV4cG9ydHMuYWRkVXNlclNlbGVjdFN0eWxlcyA9IGFkZFVzZXJTZWxlY3RTdHlsZXM7XG5leHBvcnRzLmNyZWF0ZUNTU1RyYW5zZm9ybSA9IGNyZWF0ZUNTU1RyYW5zZm9ybTtcbmV4cG9ydHMuY3JlYXRlU1ZHVHJhbnNmb3JtID0gY3JlYXRlU1ZHVHJhbnNmb3JtO1xuZXhwb3J0cy5nZXRUb3VjaCA9IGdldFRvdWNoO1xuZXhwb3J0cy5nZXRUb3VjaElkZW50aWZpZXIgPSBnZXRUb3VjaElkZW50aWZpZXI7XG5leHBvcnRzLmdldFRyYW5zbGF0aW9uID0gZ2V0VHJhbnNsYXRpb247XG5leHBvcnRzLmlubmVySGVpZ2h0ID0gaW5uZXJIZWlnaHQ7XG5leHBvcnRzLmlubmVyV2lkdGggPSBpbm5lcldpZHRoO1xuZXhwb3J0cy5tYXRjaGVzU2VsZWN0b3IgPSBtYXRjaGVzU2VsZWN0b3I7XG5leHBvcnRzLm1hdGNoZXNTZWxlY3RvckFuZFBhcmVudHNUbyA9IG1hdGNoZXNTZWxlY3RvckFuZFBhcmVudHNUbztcbmV4cG9ydHMub2Zmc2V0WFlGcm9tUGFyZW50ID0gb2Zmc2V0WFlGcm9tUGFyZW50O1xuZXhwb3J0cy5vdXRlckhlaWdodCA9IG91dGVySGVpZ2h0O1xuZXhwb3J0cy5vdXRlcldpZHRoID0gb3V0ZXJXaWR0aDtcbmV4cG9ydHMucmVtb3ZlQ2xhc3NOYW1lID0gcmVtb3ZlQ2xhc3NOYW1lO1xuZXhwb3J0cy5yZW1vdmVFdmVudCA9IHJlbW92ZUV2ZW50O1xuZXhwb3J0cy5yZW1vdmVVc2VyU2VsZWN0U3R5bGVzID0gcmVtb3ZlVXNlclNlbGVjdFN0eWxlcztcbnZhciBfc2hpbXMgPSByZXF1aXJlKFwiLi9zaGltc1wiKTtcbnZhciBfZ2V0UHJlZml4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vZ2V0UHJlZml4XCIpKTtcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiAobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuLyo6OiBpbXBvcnQgdHlwZSB7Q29udHJvbFBvc2l0aW9uLCBQb3NpdGlvbk9mZnNldENvbnRyb2xQb3NpdGlvbiwgTW91c2VUb3VjaEV2ZW50fSBmcm9tICcuL3R5cGVzJzsqL1xubGV0IG1hdGNoZXNTZWxlY3RvckZ1bmMgPSAnJztcbmZ1bmN0aW9uIG1hdGNoZXNTZWxlY3RvcihlbCAvKjogTm9kZSovLCBzZWxlY3RvciAvKjogc3RyaW5nKi8pIC8qOiBib29sZWFuKi97XG4gIGlmICghbWF0Y2hlc1NlbGVjdG9yRnVuYykge1xuICAgIG1hdGNoZXNTZWxlY3RvckZ1bmMgPSAoMCwgX3NoaW1zLmZpbmRJbkFycmF5KShbJ21hdGNoZXMnLCAnd2Via2l0TWF0Y2hlc1NlbGVjdG9yJywgJ21vek1hdGNoZXNTZWxlY3RvcicsICdtc01hdGNoZXNTZWxlY3RvcicsICdvTWF0Y2hlc1NlbGVjdG9yJ10sIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIC8vICRGbG93SWdub3JlOiBEb2Vzbid0IHRoaW5rIGVsZW1lbnRzIGFyZSBpbmRleGFibGVcbiAgICAgIHJldHVybiAoMCwgX3NoaW1zLmlzRnVuY3Rpb24pKGVsW21ldGhvZF0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gTWlnaHQgbm90IGJlIGZvdW5kIGVudGlyZWx5IChub3QgYW4gRWxlbWVudD8pIC0gaW4gdGhhdCBjYXNlLCBiYWlsXG4gIC8vICRGbG93SWdub3JlOiBEb2Vzbid0IHRoaW5rIGVsZW1lbnRzIGFyZSBpbmRleGFibGVcbiAgaWYgKCEoMCwgX3NoaW1zLmlzRnVuY3Rpb24pKGVsW21hdGNoZXNTZWxlY3RvckZ1bmNdKSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vICRGbG93SWdub3JlOiBEb2Vzbid0IHRoaW5rIGVsZW1lbnRzIGFyZSBpbmRleGFibGVcbiAgcmV0dXJuIGVsW21hdGNoZXNTZWxlY3RvckZ1bmNdKHNlbGVjdG9yKTtcbn1cblxuLy8gV29ya3MgdXAgdGhlIHRyZWUgdG8gdGhlIGRyYWdnYWJsZSBpdHNlbGYgYXR0ZW1wdGluZyB0byBtYXRjaCBzZWxlY3Rvci5cbmZ1bmN0aW9uIG1hdGNoZXNTZWxlY3RvckFuZFBhcmVudHNUbyhlbCAvKjogTm9kZSovLCBzZWxlY3RvciAvKjogc3RyaW5nKi8sIGJhc2VOb2RlIC8qOiBOb2RlKi8pIC8qOiBib29sZWFuKi97XG4gIGxldCBub2RlID0gZWw7XG4gIGRvIHtcbiAgICBpZiAobWF0Y2hlc1NlbGVjdG9yKG5vZGUsIHNlbGVjdG9yKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKG5vZGUgPT09IGJhc2VOb2RlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gJEZsb3dJZ25vcmVbaW5jb21wYXRpYmxlLXR5cGVdXG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfSB3aGlsZSAobm9kZSk7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50KGVsIC8qOiA/Tm9kZSovLCBldmVudCAvKjogc3RyaW5nKi8sIGhhbmRsZXIgLyo6IEZ1bmN0aW9uKi8sIGlucHV0T3B0aW9ucyAvKjogT2JqZWN0Ki8pIC8qOiB2b2lkKi97XG4gIGlmICghZWwpIHJldHVybjtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBjYXB0dXJlOiB0cnVlLFxuICAgIC4uLmlucHV0T3B0aW9uc1xuICB9O1xuICAvLyAkRmxvd0lnbm9yZVttZXRob2QtdW5iaW5kaW5nXVxuICBpZiAoZWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKGVsLmF0dGFjaEV2ZW50KSB7XG4gICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBoYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyAkRmxvd0lnbm9yZTogRG9lc24ndCB0aGluayBlbGVtZW50cyBhcmUgaW5kZXhhYmxlXG4gICAgZWxbJ29uJyArIGV2ZW50XSA9IGhhbmRsZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50KGVsIC8qOiA/Tm9kZSovLCBldmVudCAvKjogc3RyaW5nKi8sIGhhbmRsZXIgLyo6IEZ1bmN0aW9uKi8sIGlucHV0T3B0aW9ucyAvKjogT2JqZWN0Ki8pIC8qOiB2b2lkKi97XG4gIGlmICghZWwpIHJldHVybjtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBjYXB0dXJlOiB0cnVlLFxuICAgIC4uLmlucHV0T3B0aW9uc1xuICB9O1xuICAvLyAkRmxvd0lnbm9yZVttZXRob2QtdW5iaW5kaW5nXVxuICBpZiAoZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKGVsLmRldGFjaEV2ZW50KSB7XG4gICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBoYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyAkRmxvd0lnbm9yZTogRG9lc24ndCB0aGluayBlbGVtZW50cyBhcmUgaW5kZXhhYmxlXG4gICAgZWxbJ29uJyArIGV2ZW50XSA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIG91dGVySGVpZ2h0KG5vZGUgLyo6IEhUTUxFbGVtZW50Ki8pIC8qOiBudW1iZXIqL3tcbiAgLy8gVGhpcyBpcyBkZWxpYmVyYXRlbHkgZXhjbHVkaW5nIG1hcmdpbiBmb3Igb3VyIGNhbGN1bGF0aW9ucywgc2luY2Ugd2UgYXJlIHVzaW5nXG4gIC8vIG9mZnNldFRvcCB3aGljaCBpcyBpbmNsdWRpbmcgbWFyZ2luLiBTZWUgZ2V0Qm91bmRQb3NpdGlvblxuICBsZXQgaGVpZ2h0ID0gbm9kZS5jbGllbnRIZWlnaHQ7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgaGVpZ2h0ICs9ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLmJvcmRlclRvcFdpZHRoKTtcbiAgaGVpZ2h0ICs9ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoKTtcbiAgcmV0dXJuIGhlaWdodDtcbn1cbmZ1bmN0aW9uIG91dGVyV2lkdGgobm9kZSAvKjogSFRNTEVsZW1lbnQqLykgLyo6IG51bWJlciove1xuICAvLyBUaGlzIGlzIGRlbGliZXJhdGVseSBleGNsdWRpbmcgbWFyZ2luIGZvciBvdXIgY2FsY3VsYXRpb25zLCBzaW5jZSB3ZSBhcmUgdXNpbmdcbiAgLy8gb2Zmc2V0TGVmdCB3aGljaCBpcyBpbmNsdWRpbmcgbWFyZ2luLiBTZWUgZ2V0Qm91bmRQb3NpdGlvblxuICBsZXQgd2lkdGggPSBub2RlLmNsaWVudFdpZHRoO1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIHdpZHRoICs9ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCk7XG4gIHdpZHRoICs9ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLmJvcmRlclJpZ2h0V2lkdGgpO1xuICByZXR1cm4gd2lkdGg7XG59XG5mdW5jdGlvbiBpbm5lckhlaWdodChub2RlIC8qOiBIVE1MRWxlbWVudCovKSAvKjogbnVtYmVyKi97XG4gIGxldCBoZWlnaHQgPSBub2RlLmNsaWVudEhlaWdodDtcbiAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICBoZWlnaHQgLT0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUucGFkZGluZ1RvcCk7XG4gIGhlaWdodCAtPSAoMCwgX3NoaW1zLmludCkoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tKTtcbiAgcmV0dXJuIGhlaWdodDtcbn1cbmZ1bmN0aW9uIGlubmVyV2lkdGgobm9kZSAvKjogSFRNTEVsZW1lbnQqLykgLyo6IG51bWJlciove1xuICBsZXQgd2lkdGggPSBub2RlLmNsaWVudFdpZHRoO1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIHdpZHRoIC09ICgwLCBfc2hpbXMuaW50KShjb21wdXRlZFN0eWxlLnBhZGRpbmdMZWZ0KTtcbiAgd2lkdGggLT0gKDAsIF9zaGltcy5pbnQpKGNvbXB1dGVkU3R5bGUucGFkZGluZ1JpZ2h0KTtcbiAgcmV0dXJuIHdpZHRoO1xufVxuLyo6OiBpbnRlcmZhY2UgRXZlbnRXaXRoT2Zmc2V0IHtcbiAgY2xpZW50WDogbnVtYmVyLCBjbGllbnRZOiBudW1iZXJcbn0qL1xuLy8gR2V0IGZyb20gb2Zmc2V0UGFyZW50XG5mdW5jdGlvbiBvZmZzZXRYWUZyb21QYXJlbnQoZXZ0IC8qOiBFdmVudFdpdGhPZmZzZXQqLywgb2Zmc2V0UGFyZW50IC8qOiBIVE1MRWxlbWVudCovLCBzY2FsZSAvKjogbnVtYmVyKi8pIC8qOiBDb250cm9sUG9zaXRpb24qL3tcbiAgY29uc3QgaXNCb2R5ID0gb2Zmc2V0UGFyZW50ID09PSBvZmZzZXRQYXJlbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICBjb25zdCBvZmZzZXRQYXJlbnRSZWN0ID0gaXNCb2R5ID8ge1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwXG4gIH0gOiBvZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHggPSAoZXZ0LmNsaWVudFggKyBvZmZzZXRQYXJlbnQuc2Nyb2xsTGVmdCAtIG9mZnNldFBhcmVudFJlY3QubGVmdCkgLyBzY2FsZTtcbiAgY29uc3QgeSA9IChldnQuY2xpZW50WSArIG9mZnNldFBhcmVudC5zY3JvbGxUb3AgLSBvZmZzZXRQYXJlbnRSZWN0LnRvcCkgLyBzY2FsZTtcbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNTU1RyYW5zZm9ybShjb250cm9sUG9zIC8qOiBDb250cm9sUG9zaXRpb24qLywgcG9zaXRpb25PZmZzZXQgLyo6IFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uKi8pIC8qOiBPYmplY3QqL3tcbiAgY29uc3QgdHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbihjb250cm9sUG9zLCBwb3NpdGlvbk9mZnNldCwgJ3B4Jyk7XG4gIHJldHVybiB7XG4gICAgWygwLCBfZ2V0UHJlZml4LmJyb3dzZXJQcmVmaXhUb0tleSkoJ3RyYW5zZm9ybScsIF9nZXRQcmVmaXguZGVmYXVsdCldOiB0cmFuc2xhdGlvblxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU1ZHVHJhbnNmb3JtKGNvbnRyb2xQb3MgLyo6IENvbnRyb2xQb3NpdGlvbiovLCBwb3NpdGlvbk9mZnNldCAvKjogUG9zaXRpb25PZmZzZXRDb250cm9sUG9zaXRpb24qLykgLyo6IHN0cmluZyove1xuICBjb25zdCB0cmFuc2xhdGlvbiA9IGdldFRyYW5zbGF0aW9uKGNvbnRyb2xQb3MsIHBvc2l0aW9uT2Zmc2V0LCAnJyk7XG4gIHJldHVybiB0cmFuc2xhdGlvbjtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKF9yZWYgLyo6OiAqLywgcG9zaXRpb25PZmZzZXQgLyo6IFBvc2l0aW9uT2Zmc2V0Q29udHJvbFBvc2l0aW9uKi8sIHVuaXRTdWZmaXggLyo6IHN0cmluZyovKSAvKjogc3RyaW5nKi97XG4gIGxldCB7XG4gICAgeCxcbiAgICB5XG4gIH0gLyo6IENvbnRyb2xQb3NpdGlvbiovID0gX3JlZiAvKjogQ29udHJvbFBvc2l0aW9uKi87XG4gIGxldCB0cmFuc2xhdGlvbiA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdCh4KS5jb25jYXQodW5pdFN1ZmZpeCwgXCIsXCIpLmNvbmNhdCh5KS5jb25jYXQodW5pdFN1ZmZpeCwgXCIpXCIpO1xuICBpZiAocG9zaXRpb25PZmZzZXQpIHtcbiAgICBjb25zdCBkZWZhdWx0WCA9IFwiXCIuY29uY2F0KHR5cGVvZiBwb3NpdGlvbk9mZnNldC54ID09PSAnc3RyaW5nJyA/IHBvc2l0aW9uT2Zmc2V0LnggOiBwb3NpdGlvbk9mZnNldC54ICsgdW5pdFN1ZmZpeCk7XG4gICAgY29uc3QgZGVmYXVsdFkgPSBcIlwiLmNvbmNhdCh0eXBlb2YgcG9zaXRpb25PZmZzZXQueSA9PT0gJ3N0cmluZycgPyBwb3NpdGlvbk9mZnNldC55IDogcG9zaXRpb25PZmZzZXQueSArIHVuaXRTdWZmaXgpO1xuICAgIHRyYW5zbGF0aW9uID0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KGRlZmF1bHRYLCBcIiwgXCIpLmNvbmNhdChkZWZhdWx0WSwgXCIpXCIpICsgdHJhbnNsYXRpb247XG4gIH1cbiAgcmV0dXJuIHRyYW5zbGF0aW9uO1xufVxuZnVuY3Rpb24gZ2V0VG91Y2goZSAvKjogTW91c2VUb3VjaEV2ZW50Ki8sIGlkZW50aWZpZXIgLyo6IG51bWJlciovKSAvKjogP3tjbGllbnRYOiBudW1iZXIsIGNsaWVudFk6IG51bWJlcn0qL3tcbiAgcmV0dXJuIGUudGFyZ2V0VG91Y2hlcyAmJiAoMCwgX3NoaW1zLmZpbmRJbkFycmF5KShlLnRhcmdldFRvdWNoZXMsIHQgPT4gaWRlbnRpZmllciA9PT0gdC5pZGVudGlmaWVyKSB8fCBlLmNoYW5nZWRUb3VjaGVzICYmICgwLCBfc2hpbXMuZmluZEluQXJyYXkpKGUuY2hhbmdlZFRvdWNoZXMsIHQgPT4gaWRlbnRpZmllciA9PT0gdC5pZGVudGlmaWVyKTtcbn1cbmZ1bmN0aW9uIGdldFRvdWNoSWRlbnRpZmllcihlIC8qOiBNb3VzZVRvdWNoRXZlbnQqLykgLyo6ID9udW1iZXIqL3tcbiAgaWYgKGUudGFyZ2V0VG91Y2hlcyAmJiBlLnRhcmdldFRvdWNoZXNbMF0pIHJldHVybiBlLnRhcmdldFRvdWNoZXNbMF0uaWRlbnRpZmllcjtcbiAgaWYgKGUuY2hhbmdlZFRvdWNoZXMgJiYgZS5jaGFuZ2VkVG91Y2hlc1swXSkgcmV0dXJuIGUuY2hhbmdlZFRvdWNoZXNbMF0uaWRlbnRpZmllcjtcbn1cblxuLy8gVXNlci1zZWxlY3QgSGFja3M6XG4vL1xuLy8gVXNlZnVsIGZvciBwcmV2ZW50aW5nIGJsdWUgaGlnaGxpZ2h0cyBhbGwgb3ZlciBldmVyeXRoaW5nIHdoZW4gZHJhZ2dpbmcuXG5cbi8vIE5vdGUgd2UncmUgcGFzc2luZyBgZG9jdW1lbnRgIGIvYyB3ZSBjb3VsZCBiZSBpZnJhbWVkXG5mdW5jdGlvbiBhZGRVc2VyU2VsZWN0U3R5bGVzKGRvYyAvKjogP0RvY3VtZW50Ki8pIHtcbiAgaWYgKCFkb2MpIHJldHVybjtcbiAgbGV0IHN0eWxlRWwgPSBkb2MuZ2V0RWxlbWVudEJ5SWQoJ3JlYWN0LWRyYWdnYWJsZS1zdHlsZS1lbCcpO1xuICBpZiAoIXN0eWxlRWwpIHtcbiAgICBzdHlsZUVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgc3R5bGVFbC50eXBlID0gJ3RleHQvY3NzJztcbiAgICBzdHlsZUVsLmlkID0gJ3JlYWN0LWRyYWdnYWJsZS1zdHlsZS1lbCc7XG4gICAgc3R5bGVFbC5pbm5lckhUTUwgPSAnLnJlYWN0LWRyYWdnYWJsZS10cmFuc3BhcmVudC1zZWxlY3Rpb24gKjo6LW1vei1zZWxlY3Rpb24ge2FsbDogaW5oZXJpdDt9XFxuJztcbiAgICBzdHlsZUVsLmlubmVySFRNTCArPSAnLnJlYWN0LWRyYWdnYWJsZS10cmFuc3BhcmVudC1zZWxlY3Rpb24gKjo6c2VsZWN0aW9uIHthbGw6IGluaGVyaXQ7fVxcbic7XG4gICAgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc3R5bGVFbCk7XG4gIH1cbiAgaWYgKGRvYy5ib2R5KSBhZGRDbGFzc05hbWUoZG9jLmJvZHksICdyZWFjdC1kcmFnZ2FibGUtdHJhbnNwYXJlbnQtc2VsZWN0aW9uJyk7XG59XG5mdW5jdGlvbiByZW1vdmVVc2VyU2VsZWN0U3R5bGVzKGRvYyAvKjogP0RvY3VtZW50Ki8pIHtcbiAgaWYgKCFkb2MpIHJldHVybjtcbiAgdHJ5IHtcbiAgICBpZiAoZG9jLmJvZHkpIHJlbW92ZUNsYXNzTmFtZShkb2MuYm9keSwgJ3JlYWN0LWRyYWdnYWJsZS10cmFuc3BhcmVudC1zZWxlY3Rpb24nKTtcbiAgICAvLyAkRmxvd0lnbm9yZTogSUVcbiAgICBpZiAoZG9jLnNlbGVjdGlvbikge1xuICAgICAgLy8gJEZsb3dJZ25vcmU6IElFXG4gICAgICBkb2Muc2VsZWN0aW9uLmVtcHR5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZSBzZWxlY3Rpb24gY2F1c2VkIGJ5IHNjcm9sbCwgdW5sZXNzIGl0J3MgYSBmb2N1c2VkIGlucHV0XG4gICAgICAvLyAod2UgdXNlIGRvYy5kZWZhdWx0VmlldyBpbiBjYXNlIHdlJ3JlIGluIGFuIGlmcmFtZSlcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IChkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93KS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLnR5cGUgIT09ICdDYXJldCcpIHtcbiAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHByb2JhYmx5IElFXG4gIH1cbn1cbmZ1bmN0aW9uIGFkZENsYXNzTmFtZShlbCAvKjogSFRNTEVsZW1lbnQqLywgY2xhc3NOYW1lIC8qOiBzdHJpbmcqLykge1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICB9IGVsc2Uge1xuICAgIGlmICghZWwuY2xhc3NOYW1lLm1hdGNoKG5ldyBSZWdFeHAoXCIoPzpefFxcXFxzKVwiLmNvbmNhdChjbGFzc05hbWUsIFwiKD8hXFxcXFMpXCIpKSkpIHtcbiAgICAgIGVsLmNsYXNzTmFtZSArPSBcIiBcIi5jb25jYXQoY2xhc3NOYW1lKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzTmFtZShlbCAvKjogSFRNTEVsZW1lbnQqLywgY2xhc3NOYW1lIC8qOiBzdHJpbmcqLykge1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICB9IGVsc2Uge1xuICAgIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoPzpefFxcXFxzKVwiLmNvbmNhdChjbGFzc05hbWUsIFwiKD8hXFxcXFMpXCIpLCAnZycpLCAnJyk7XG4gIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/react-draggable/build/cjs/utils/domFns.js\n");

/***/ }),

/***/ "../../node_modules/react-draggable/build/cjs/utils/getPrefix.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/react-draggable/build/cjs/utils/getPrefix.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.browserPrefixToKey = browserPrefixToKey;\nexports.browserPrefixToStyle = browserPrefixToStyle;\nexports[\"default\"] = void 0;\nexports.getPrefix = getPrefix;\nconst prefixes = ['Moz', 'Webkit', 'O', 'ms'];\nfunction getPrefix() /*: string*/{\n  var _window$document;\n  let prop /*: string*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';\n  // Ensure we're running in an environment where there is actually a global\n  // `window` obj\n  if (typeof window === 'undefined') return '';\n\n  // If we're in a pseudo-browser server-side environment, this access\n  // path may not exist, so bail out if it doesn't.\n  const style = (_window$document = window.document) === null || _window$document === void 0 || (_window$document = _window$document.documentElement) === null || _window$document === void 0 ? void 0 : _window$document.style;\n  if (!style) return '';\n  if (prop in style) return '';\n  for (let i = 0; i < prefixes.length; i++) {\n    if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];\n  }\n  return '';\n}\nfunction browserPrefixToKey(prop /*: string*/, prefix /*: string*/) /*: string*/{\n  return prefix ? \"\".concat(prefix).concat(kebabToTitleCase(prop)) : prop;\n}\nfunction browserPrefixToStyle(prop /*: string*/, prefix /*: string*/) /*: string*/{\n  return prefix ? \"-\".concat(prefix.toLowerCase(), \"-\").concat(prop) : prop;\n}\nfunction kebabToTitleCase(str /*: string*/) /*: string*/{\n  let out = '';\n  let shouldCapitalize = true;\n  for (let i = 0; i < str.length; i++) {\n    if (shouldCapitalize) {\n      out += str[i].toUpperCase();\n      shouldCapitalize = false;\n    } else if (str[i] === '-') {\n      shouldCapitalize = true;\n    } else {\n      out += str[i];\n    }\n  }\n  return out;\n}\n\n// Default export is the prefix itself, like 'Moz', 'Webkit', etc\n// Note that you may have to re-test for certain things; for instance, Chrome 50\n// can handle unprefixed `transform`, but not unprefixed `user-select`\nvar _default = exports[\"default\"] = (getPrefix() /*: string*/);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWdnYWJsZS9idWlsZC9janMvdXRpbHMvZ2V0UHJlZml4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL2dldFByZWZpeC5qcz9jY2RmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5icm93c2VyUHJlZml4VG9LZXkgPSBicm93c2VyUHJlZml4VG9LZXk7XG5leHBvcnRzLmJyb3dzZXJQcmVmaXhUb1N0eWxlID0gYnJvd3NlclByZWZpeFRvU3R5bGU7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5leHBvcnRzLmdldFByZWZpeCA9IGdldFByZWZpeDtcbmNvbnN0IHByZWZpeGVzID0gWydNb3onLCAnV2Via2l0JywgJ08nLCAnbXMnXTtcbmZ1bmN0aW9uIGdldFByZWZpeCgpIC8qOiBzdHJpbmcqL3tcbiAgdmFyIF93aW5kb3ckZG9jdW1lbnQ7XG4gIGxldCBwcm9wIC8qOiBzdHJpbmcqLyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ3RyYW5zZm9ybSc7XG4gIC8vIEVuc3VyZSB3ZSdyZSBydW5uaW5nIGluIGFuIGVudmlyb25tZW50IHdoZXJlIHRoZXJlIGlzIGFjdHVhbGx5IGEgZ2xvYmFsXG4gIC8vIGB3aW5kb3dgIG9ialxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiAnJztcblxuICAvLyBJZiB3ZSdyZSBpbiBhIHBzZXVkby1icm93c2VyIHNlcnZlci1zaWRlIGVudmlyb25tZW50LCB0aGlzIGFjY2Vzc1xuICAvLyBwYXRoIG1heSBub3QgZXhpc3QsIHNvIGJhaWwgb3V0IGlmIGl0IGRvZXNuJ3QuXG4gIGNvbnN0IHN0eWxlID0gKF93aW5kb3ckZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQpID09PSBudWxsIHx8IF93aW5kb3ckZG9jdW1lbnQgPT09IHZvaWQgMCB8fCAoX3dpbmRvdyRkb2N1bWVudCA9IF93aW5kb3ckZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfd2luZG93JGRvY3VtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2luZG93JGRvY3VtZW50LnN0eWxlO1xuICBpZiAoIXN0eWxlKSByZXR1cm4gJyc7XG4gIGlmIChwcm9wIGluIHN0eWxlKSByZXR1cm4gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYnJvd3NlclByZWZpeFRvS2V5KHByb3AsIHByZWZpeGVzW2ldKSBpbiBzdHlsZSkgcmV0dXJuIHByZWZpeGVzW2ldO1xuICB9XG4gIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGJyb3dzZXJQcmVmaXhUb0tleShwcm9wIC8qOiBzdHJpbmcqLywgcHJlZml4IC8qOiBzdHJpbmcqLykgLyo6IHN0cmluZyove1xuICByZXR1cm4gcHJlZml4ID8gXCJcIi5jb25jYXQocHJlZml4KS5jb25jYXQoa2ViYWJUb1RpdGxlQ2FzZShwcm9wKSkgOiBwcm9wO1xufVxuZnVuY3Rpb24gYnJvd3NlclByZWZpeFRvU3R5bGUocHJvcCAvKjogc3RyaW5nKi8sIHByZWZpeCAvKjogc3RyaW5nKi8pIC8qOiBzdHJpbmcqL3tcbiAgcmV0dXJuIHByZWZpeCA/IFwiLVwiLmNvbmNhdChwcmVmaXgudG9Mb3dlckNhc2UoKSwgXCItXCIpLmNvbmNhdChwcm9wKSA6IHByb3A7XG59XG5mdW5jdGlvbiBrZWJhYlRvVGl0bGVDYXNlKHN0ciAvKjogc3RyaW5nKi8pIC8qOiBzdHJpbmcqL3tcbiAgbGV0IG91dCA9ICcnO1xuICBsZXQgc2hvdWxkQ2FwaXRhbGl6ZSA9IHRydWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHNob3VsZENhcGl0YWxpemUpIHtcbiAgICAgIG91dCArPSBzdHJbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgIHNob3VsZENhcGl0YWxpemUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gJy0nKSB7XG4gICAgICBzaG91bGRDYXBpdGFsaXplID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9IHN0cltpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuLy8gRGVmYXVsdCBleHBvcnQgaXMgdGhlIHByZWZpeCBpdHNlbGYsIGxpa2UgJ01veicsICdXZWJraXQnLCBldGNcbi8vIE5vdGUgdGhhdCB5b3UgbWF5IGhhdmUgdG8gcmUtdGVzdCBmb3IgY2VydGFpbiB0aGluZ3M7IGZvciBpbnN0YW5jZSwgQ2hyb21lIDUwXG4vLyBjYW4gaGFuZGxlIHVucHJlZml4ZWQgYHRyYW5zZm9ybWAsIGJ1dCBub3QgdW5wcmVmaXhlZCBgdXNlci1zZWxlY3RgXG52YXIgX2RlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQgPSAoZ2V0UHJlZml4KCkgLyo6IHN0cmluZyovKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/react-draggable/build/cjs/utils/getPrefix.js\n");

/***/ }),

/***/ "../../node_modules/react-draggable/build/cjs/utils/log.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/react-draggable/build/cjs/utils/log.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = log;\n/*eslint no-console:0*/\nfunction log() {\n  if (false) {}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWdnYWJsZS9idWlsZC9janMvdXRpbHMvbG9nLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9zdC8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9sb2cuanM/ZWEyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGxvZztcbi8qZXNsaW50IG5vLWNvbnNvbGU6MCovXG5mdW5jdGlvbiBsb2coKSB7XG4gIGlmICh1bmRlZmluZWQpIGNvbnNvbGUubG9nKC4uLmFyZ3VtZW50cyk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/react-draggable/build/cjs/utils/log.js\n");

/***/ }),

/***/ "../../node_modules/react-draggable/build/cjs/utils/positionFns.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/react-draggable/build/cjs/utils/positionFns.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.canDragX = canDragX;\nexports.canDragY = canDragY;\nexports.createCoreData = createCoreData;\nexports.createDraggableData = createDraggableData;\nexports.getBoundPosition = getBoundPosition;\nexports.getControlPosition = getControlPosition;\nexports.snapToGrid = snapToGrid;\nvar _shims = __webpack_require__(/*! ./shims */ \"../../node_modules/react-draggable/build/cjs/utils/shims.js\");\nvar _domFns = __webpack_require__(/*! ./domFns */ \"../../node_modules/react-draggable/build/cjs/utils/domFns.js\");\n/*:: import type Draggable from '../Draggable';*/\n/*:: import type {Bounds, ControlPosition, DraggableData, MouseTouchEvent} from './types';*/\n/*:: import type DraggableCore from '../DraggableCore';*/\nfunction getBoundPosition(draggable /*: Draggable*/, x /*: number*/, y /*: number*/) /*: [number, number]*/{\n  // If no bounds, short-circuit and move on\n  if (!draggable.props.bounds) return [x, y];\n\n  // Clone new bounds\n  let {\n    bounds\n  } = draggable.props;\n  bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);\n  const node = findDOMNode(draggable);\n  if (typeof bounds === 'string') {\n    const {\n      ownerDocument\n    } = node;\n    const ownerWindow = ownerDocument.defaultView;\n    let boundNode;\n    if (bounds === 'parent') {\n      boundNode = node.parentNode;\n    } else {\n      boundNode = ownerDocument.querySelector(bounds);\n    }\n    if (!(boundNode instanceof ownerWindow.HTMLElement)) {\n      throw new Error('Bounds selector \"' + bounds + '\" could not find an element.');\n    }\n    const boundNodeEl /*: HTMLElement*/ = boundNode; // for Flow, can't seem to refine correctly\n    const nodeStyle = ownerWindow.getComputedStyle(node);\n    const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);\n    // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.\n    bounds = {\n      left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),\n      top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),\n      right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),\n      bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)\n    };\n  }\n\n  // Keep x and y below right and bottom limits...\n  if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);\n  if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);\n\n  // But above left and top limits.\n  if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);\n  if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);\n  return [x, y];\n}\nfunction snapToGrid(grid /*: [number, number]*/, pendingX /*: number*/, pendingY /*: number*/) /*: [number, number]*/{\n  const x = Math.round(pendingX / grid[0]) * grid[0];\n  const y = Math.round(pendingY / grid[1]) * grid[1];\n  return [x, y];\n}\nfunction canDragX(draggable /*: Draggable*/) /*: boolean*/{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'x';\n}\nfunction canDragY(draggable /*: Draggable*/) /*: boolean*/{\n  return draggable.props.axis === 'both' || draggable.props.axis === 'y';\n}\n\n// Get {x, y} positions from event.\nfunction getControlPosition(e /*: MouseTouchEvent*/, touchIdentifier /*: ?number*/, draggableCore /*: DraggableCore*/) /*: ?ControlPosition*/{\n  const touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;\n  if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch\n  const node = findDOMNode(draggableCore);\n  // User can provide an offsetParent if desired.\n  const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;\n  return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);\n}\n\n// Create an data object exposed by <DraggableCore>'s events\nfunction createCoreData(draggable /*: DraggableCore*/, x /*: number*/, y /*: number*/) /*: DraggableData*/{\n  const isStart = !(0, _shims.isNum)(draggable.lastX);\n  const node = findDOMNode(draggable);\n  if (isStart) {\n    // If this is our first move, use the x and y as last coords.\n    return {\n      node,\n      deltaX: 0,\n      deltaY: 0,\n      lastX: x,\n      lastY: y,\n      x,\n      y\n    };\n  } else {\n    // Otherwise calculate proper values.\n    return {\n      node,\n      deltaX: x - draggable.lastX,\n      deltaY: y - draggable.lastY,\n      lastX: draggable.lastX,\n      lastY: draggable.lastY,\n      x,\n      y\n    };\n  }\n}\n\n// Create an data exposed by <Draggable>'s events\nfunction createDraggableData(draggable /*: Draggable*/, coreData /*: DraggableData*/) /*: DraggableData*/{\n  const scale = draggable.props.scale;\n  return {\n    node: coreData.node,\n    x: draggable.state.x + coreData.deltaX / scale,\n    y: draggable.state.y + coreData.deltaY / scale,\n    deltaX: coreData.deltaX / scale,\n    deltaY: coreData.deltaY / scale,\n    lastX: draggable.state.x,\n    lastY: draggable.state.y\n  };\n}\n\n// A lot faster than stringify/parse\nfunction cloneBounds(bounds /*: Bounds*/) /*: Bounds*/{\n  return {\n    left: bounds.left,\n    top: bounds.top,\n    right: bounds.right,\n    bottom: bounds.bottom\n  };\n}\nfunction findDOMNode(draggable /*: Draggable | DraggableCore*/) /*: HTMLElement*/{\n  const node = draggable.findDOMNode();\n  if (!node) {\n    throw new Error('<DraggableCore>: Unmounted during event!');\n  }\n  // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME\n  return node;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWdnYWJsZS9idWlsZC9janMvdXRpbHMvcG9zaXRpb25GbnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9zdC8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL2J1aWxkL2Nqcy91dGlscy9wb3NpdGlvbkZucy5qcz8zNGZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jYW5EcmFnWCA9IGNhbkRyYWdYO1xuZXhwb3J0cy5jYW5EcmFnWSA9IGNhbkRyYWdZO1xuZXhwb3J0cy5jcmVhdGVDb3JlRGF0YSA9IGNyZWF0ZUNvcmVEYXRhO1xuZXhwb3J0cy5jcmVhdGVEcmFnZ2FibGVEYXRhID0gY3JlYXRlRHJhZ2dhYmxlRGF0YTtcbmV4cG9ydHMuZ2V0Qm91bmRQb3NpdGlvbiA9IGdldEJvdW5kUG9zaXRpb247XG5leHBvcnRzLmdldENvbnRyb2xQb3NpdGlvbiA9IGdldENvbnRyb2xQb3NpdGlvbjtcbmV4cG9ydHMuc25hcFRvR3JpZCA9IHNuYXBUb0dyaWQ7XG52YXIgX3NoaW1zID0gcmVxdWlyZShcIi4vc2hpbXNcIik7XG52YXIgX2RvbUZucyA9IHJlcXVpcmUoXCIuL2RvbUZuc1wiKTtcbi8qOjogaW1wb3J0IHR5cGUgRHJhZ2dhYmxlIGZyb20gJy4uL0RyYWdnYWJsZSc7Ki9cbi8qOjogaW1wb3J0IHR5cGUge0JvdW5kcywgQ29udHJvbFBvc2l0aW9uLCBEcmFnZ2FibGVEYXRhLCBNb3VzZVRvdWNoRXZlbnR9IGZyb20gJy4vdHlwZXMnOyovXG4vKjo6IGltcG9ydCB0eXBlIERyYWdnYWJsZUNvcmUgZnJvbSAnLi4vRHJhZ2dhYmxlQ29yZSc7Ki9cbmZ1bmN0aW9uIGdldEJvdW5kUG9zaXRpb24oZHJhZ2dhYmxlIC8qOiBEcmFnZ2FibGUqLywgeCAvKjogbnVtYmVyKi8sIHkgLyo6IG51bWJlciovKSAvKjogW251bWJlciwgbnVtYmVyXSove1xuICAvLyBJZiBubyBib3VuZHMsIHNob3J0LWNpcmN1aXQgYW5kIG1vdmUgb25cbiAgaWYgKCFkcmFnZ2FibGUucHJvcHMuYm91bmRzKSByZXR1cm4gW3gsIHldO1xuXG4gIC8vIENsb25lIG5ldyBib3VuZHNcbiAgbGV0IHtcbiAgICBib3VuZHNcbiAgfSA9IGRyYWdnYWJsZS5wcm9wcztcbiAgYm91bmRzID0gdHlwZW9mIGJvdW5kcyA9PT0gJ3N0cmluZycgPyBib3VuZHMgOiBjbG9uZUJvdW5kcyhib3VuZHMpO1xuICBjb25zdCBub2RlID0gZmluZERPTU5vZGUoZHJhZ2dhYmxlKTtcbiAgaWYgKHR5cGVvZiBib3VuZHMgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3duZXJEb2N1bWVudFxuICAgIH0gPSBub2RlO1xuICAgIGNvbnN0IG93bmVyV2luZG93ID0gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICBsZXQgYm91bmROb2RlO1xuICAgIGlmIChib3VuZHMgPT09ICdwYXJlbnQnKSB7XG4gICAgICBib3VuZE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5kTm9kZSA9IG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3Rvcihib3VuZHMpO1xuICAgIH1cbiAgICBpZiAoIShib3VuZE5vZGUgaW5zdGFuY2VvZiBvd25lcldpbmRvdy5IVE1MRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQm91bmRzIHNlbGVjdG9yIFwiJyArIGJvdW5kcyArICdcIiBjb3VsZCBub3QgZmluZCBhbiBlbGVtZW50LicpO1xuICAgIH1cbiAgICBjb25zdCBib3VuZE5vZGVFbCAvKjogSFRNTEVsZW1lbnQqLyA9IGJvdW5kTm9kZTsgLy8gZm9yIEZsb3csIGNhbid0IHNlZW0gdG8gcmVmaW5lIGNvcnJlY3RseVxuICAgIGNvbnN0IG5vZGVTdHlsZSA9IG93bmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3QgYm91bmROb2RlU3R5bGUgPSBvd25lcldpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGJvdW5kTm9kZUVsKTtcbiAgICAvLyBDb21wdXRlIGJvdW5kcy4gVGhpcyBpcyBhIHBhaW4gd2l0aCBwYWRkaW5nIGFuZCBvZmZzZXRzIGJ1dCB0aGlzIGdldHMgaXQgZXhhY3RseSByaWdodC5cbiAgICBib3VuZHMgPSB7XG4gICAgICBsZWZ0OiAtbm9kZS5vZmZzZXRMZWZ0ICsgKDAsIF9zaGltcy5pbnQpKGJvdW5kTm9kZVN0eWxlLnBhZGRpbmdMZWZ0KSArICgwLCBfc2hpbXMuaW50KShub2RlU3R5bGUubWFyZ2luTGVmdCksXG4gICAgICB0b3A6IC1ub2RlLm9mZnNldFRvcCArICgwLCBfc2hpbXMuaW50KShib3VuZE5vZGVTdHlsZS5wYWRkaW5nVG9wKSArICgwLCBfc2hpbXMuaW50KShub2RlU3R5bGUubWFyZ2luVG9wKSxcbiAgICAgIHJpZ2h0OiAoMCwgX2RvbUZucy5pbm5lcldpZHRoKShib3VuZE5vZGVFbCkgLSAoMCwgX2RvbUZucy5vdXRlcldpZHRoKShub2RlKSAtIG5vZGUub2Zmc2V0TGVmdCArICgwLCBfc2hpbXMuaW50KShib3VuZE5vZGVTdHlsZS5wYWRkaW5nUmlnaHQpIC0gKDAsIF9zaGltcy5pbnQpKG5vZGVTdHlsZS5tYXJnaW5SaWdodCksXG4gICAgICBib3R0b206ICgwLCBfZG9tRm5zLmlubmVySGVpZ2h0KShib3VuZE5vZGVFbCkgLSAoMCwgX2RvbUZucy5vdXRlckhlaWdodCkobm9kZSkgLSBub2RlLm9mZnNldFRvcCArICgwLCBfc2hpbXMuaW50KShib3VuZE5vZGVTdHlsZS5wYWRkaW5nQm90dG9tKSAtICgwLCBfc2hpbXMuaW50KShub2RlU3R5bGUubWFyZ2luQm90dG9tKVxuICAgIH07XG4gIH1cblxuICAvLyBLZWVwIHggYW5kIHkgYmVsb3cgcmlnaHQgYW5kIGJvdHRvbSBsaW1pdHMuLi5cbiAgaWYgKCgwLCBfc2hpbXMuaXNOdW0pKGJvdW5kcy5yaWdodCkpIHggPSBNYXRoLm1pbih4LCBib3VuZHMucmlnaHQpO1xuICBpZiAoKDAsIF9zaGltcy5pc051bSkoYm91bmRzLmJvdHRvbSkpIHkgPSBNYXRoLm1pbih5LCBib3VuZHMuYm90dG9tKTtcblxuICAvLyBCdXQgYWJvdmUgbGVmdCBhbmQgdG9wIGxpbWl0cy5cbiAgaWYgKCgwLCBfc2hpbXMuaXNOdW0pKGJvdW5kcy5sZWZ0KSkgeCA9IE1hdGgubWF4KHgsIGJvdW5kcy5sZWZ0KTtcbiAgaWYgKCgwLCBfc2hpbXMuaXNOdW0pKGJvdW5kcy50b3ApKSB5ID0gTWF0aC5tYXgoeSwgYm91bmRzLnRvcCk7XG4gIHJldHVybiBbeCwgeV07XG59XG5mdW5jdGlvbiBzbmFwVG9HcmlkKGdyaWQgLyo6IFtudW1iZXIsIG51bWJlcl0qLywgcGVuZGluZ1ggLyo6IG51bWJlciovLCBwZW5kaW5nWSAvKjogbnVtYmVyKi8pIC8qOiBbbnVtYmVyLCBudW1iZXJdKi97XG4gIGNvbnN0IHggPSBNYXRoLnJvdW5kKHBlbmRpbmdYIC8gZ3JpZFswXSkgKiBncmlkWzBdO1xuICBjb25zdCB5ID0gTWF0aC5yb3VuZChwZW5kaW5nWSAvIGdyaWRbMV0pICogZ3JpZFsxXTtcbiAgcmV0dXJuIFt4LCB5XTtcbn1cbmZ1bmN0aW9uIGNhbkRyYWdYKGRyYWdnYWJsZSAvKjogRHJhZ2dhYmxlKi8pIC8qOiBib29sZWFuKi97XG4gIHJldHVybiBkcmFnZ2FibGUucHJvcHMuYXhpcyA9PT0gJ2JvdGgnIHx8IGRyYWdnYWJsZS5wcm9wcy5heGlzID09PSAneCc7XG59XG5mdW5jdGlvbiBjYW5EcmFnWShkcmFnZ2FibGUgLyo6IERyYWdnYWJsZSovKSAvKjogYm9vbGVhbiove1xuICByZXR1cm4gZHJhZ2dhYmxlLnByb3BzLmF4aXMgPT09ICdib3RoJyB8fCBkcmFnZ2FibGUucHJvcHMuYXhpcyA9PT0gJ3knO1xufVxuXG4vLyBHZXQge3gsIHl9IHBvc2l0aW9ucyBmcm9tIGV2ZW50LlxuZnVuY3Rpb24gZ2V0Q29udHJvbFBvc2l0aW9uKGUgLyo6IE1vdXNlVG91Y2hFdmVudCovLCB0b3VjaElkZW50aWZpZXIgLyo6ID9udW1iZXIqLywgZHJhZ2dhYmxlQ29yZSAvKjogRHJhZ2dhYmxlQ29yZSovKSAvKjogP0NvbnRyb2xQb3NpdGlvbiove1xuICBjb25zdCB0b3VjaE9iaiA9IHR5cGVvZiB0b3VjaElkZW50aWZpZXIgPT09ICdudW1iZXInID8gKDAsIF9kb21GbnMuZ2V0VG91Y2gpKGUsIHRvdWNoSWRlbnRpZmllcikgOiBudWxsO1xuICBpZiAodHlwZW9mIHRvdWNoSWRlbnRpZmllciA9PT0gJ251bWJlcicgJiYgIXRvdWNoT2JqKSByZXR1cm4gbnVsbDsgLy8gbm90IHRoZSByaWdodCB0b3VjaFxuICBjb25zdCBub2RlID0gZmluZERPTU5vZGUoZHJhZ2dhYmxlQ29yZSk7XG4gIC8vIFVzZXIgY2FuIHByb3ZpZGUgYW4gb2Zmc2V0UGFyZW50IGlmIGRlc2lyZWQuXG4gIGNvbnN0IG9mZnNldFBhcmVudCA9IGRyYWdnYWJsZUNvcmUucHJvcHMub2Zmc2V0UGFyZW50IHx8IG5vZGUub2Zmc2V0UGFyZW50IHx8IG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICByZXR1cm4gKDAsIF9kb21GbnMub2Zmc2V0WFlGcm9tUGFyZW50KSh0b3VjaE9iaiB8fCBlLCBvZmZzZXRQYXJlbnQsIGRyYWdnYWJsZUNvcmUucHJvcHMuc2NhbGUpO1xufVxuXG4vLyBDcmVhdGUgYW4gZGF0YSBvYmplY3QgZXhwb3NlZCBieSA8RHJhZ2dhYmxlQ29yZT4ncyBldmVudHNcbmZ1bmN0aW9uIGNyZWF0ZUNvcmVEYXRhKGRyYWdnYWJsZSAvKjogRHJhZ2dhYmxlQ29yZSovLCB4IC8qOiBudW1iZXIqLywgeSAvKjogbnVtYmVyKi8pIC8qOiBEcmFnZ2FibGVEYXRhKi97XG4gIGNvbnN0IGlzU3RhcnQgPSAhKDAsIF9zaGltcy5pc051bSkoZHJhZ2dhYmxlLmxhc3RYKTtcbiAgY29uc3Qgbm9kZSA9IGZpbmRET01Ob2RlKGRyYWdnYWJsZSk7XG4gIGlmIChpc1N0YXJ0KSB7XG4gICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgbW92ZSwgdXNlIHRoZSB4IGFuZCB5IGFzIGxhc3QgY29vcmRzLlxuICAgIHJldHVybiB7XG4gICAgICBub2RlLFxuICAgICAgZGVsdGFYOiAwLFxuICAgICAgZGVsdGFZOiAwLFxuICAgICAgbGFzdFg6IHgsXG4gICAgICBsYXN0WTogeSxcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2UgY2FsY3VsYXRlIHByb3BlciB2YWx1ZXMuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGUsXG4gICAgICBkZWx0YVg6IHggLSBkcmFnZ2FibGUubGFzdFgsXG4gICAgICBkZWx0YVk6IHkgLSBkcmFnZ2FibGUubGFzdFksXG4gICAgICBsYXN0WDogZHJhZ2dhYmxlLmxhc3RYLFxuICAgICAgbGFzdFk6IGRyYWdnYWJsZS5sYXN0WSxcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxufVxuXG4vLyBDcmVhdGUgYW4gZGF0YSBleHBvc2VkIGJ5IDxEcmFnZ2FibGU+J3MgZXZlbnRzXG5mdW5jdGlvbiBjcmVhdGVEcmFnZ2FibGVEYXRhKGRyYWdnYWJsZSAvKjogRHJhZ2dhYmxlKi8sIGNvcmVEYXRhIC8qOiBEcmFnZ2FibGVEYXRhKi8pIC8qOiBEcmFnZ2FibGVEYXRhKi97XG4gIGNvbnN0IHNjYWxlID0gZHJhZ2dhYmxlLnByb3BzLnNjYWxlO1xuICByZXR1cm4ge1xuICAgIG5vZGU6IGNvcmVEYXRhLm5vZGUsXG4gICAgeDogZHJhZ2dhYmxlLnN0YXRlLnggKyBjb3JlRGF0YS5kZWx0YVggLyBzY2FsZSxcbiAgICB5OiBkcmFnZ2FibGUuc3RhdGUueSArIGNvcmVEYXRhLmRlbHRhWSAvIHNjYWxlLFxuICAgIGRlbHRhWDogY29yZURhdGEuZGVsdGFYIC8gc2NhbGUsXG4gICAgZGVsdGFZOiBjb3JlRGF0YS5kZWx0YVkgLyBzY2FsZSxcbiAgICBsYXN0WDogZHJhZ2dhYmxlLnN0YXRlLngsXG4gICAgbGFzdFk6IGRyYWdnYWJsZS5zdGF0ZS55XG4gIH07XG59XG5cbi8vIEEgbG90IGZhc3RlciB0aGFuIHN0cmluZ2lmeS9wYXJzZVxuZnVuY3Rpb24gY2xvbmVCb3VuZHMoYm91bmRzIC8qOiBCb3VuZHMqLykgLyo6IEJvdW5kcyove1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGJvdW5kcy5sZWZ0LFxuICAgIHRvcDogYm91bmRzLnRvcCxcbiAgICByaWdodDogYm91bmRzLnJpZ2h0LFxuICAgIGJvdHRvbTogYm91bmRzLmJvdHRvbVxuICB9O1xufVxuZnVuY3Rpb24gZmluZERPTU5vZGUoZHJhZ2dhYmxlIC8qOiBEcmFnZ2FibGUgfCBEcmFnZ2FibGVDb3JlKi8pIC8qOiBIVE1MRWxlbWVudCove1xuICBjb25zdCBub2RlID0gZHJhZ2dhYmxlLmZpbmRET01Ob2RlKCk7XG4gIGlmICghbm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignPERyYWdnYWJsZUNvcmU+OiBVbm1vdW50ZWQgZHVyaW5nIGV2ZW50IScpO1xuICB9XG4gIC8vICRGbG93SWdub3JlIHdlIGNhbid0IGFzc2VydCBvbiBIVE1MRWxlbWVudCBkdWUgdG8gdGVzdHMuLi4gRklYTUVcbiAgcmV0dXJuIG5vZGU7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/react-draggable/build/cjs/utils/positionFns.js\n");

/***/ }),

/***/ "../../node_modules/react-draggable/build/cjs/utils/shims.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/react-draggable/build/cjs/utils/shims.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.dontSetMe = dontSetMe;\nexports.findInArray = findInArray;\nexports.int = int;\nexports.isFunction = isFunction;\nexports.isNum = isNum;\n// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc\nfunction findInArray(array /*: Array<any> | TouchList*/, callback /*: Function*/) /*: any*/{\n  for (let i = 0, length = array.length; i < length; i++) {\n    if (callback.apply(callback, [array[i], i, array])) return array[i];\n  }\n}\nfunction isFunction(func /*: any*/) /*: boolean %checks*/{\n  // $FlowIgnore[method-unbinding]\n  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';\n}\nfunction isNum(num /*: any*/) /*: boolean %checks*/{\n  return typeof num === 'number' && !isNaN(num);\n}\nfunction int(a /*: string*/) /*: number*/{\n  return parseInt(a, 10);\n}\nfunction dontSetMe(props /*: Object*/, propName /*: string*/, componentName /*: string*/) /*: ?Error*/{\n  if (props[propName]) {\n    return new Error(\"Invalid prop \".concat(propName, \" passed to \").concat(componentName, \" - do not set this, set it on the child.\"));\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWdnYWJsZS9idWlsZC9janMvdXRpbHMvc2hpbXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1kcmFnZ2FibGUvYnVpbGQvY2pzL3V0aWxzL3NoaW1zLmpzPzcwMmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRvbnRTZXRNZSA9IGRvbnRTZXRNZTtcbmV4cG9ydHMuZmluZEluQXJyYXkgPSBmaW5kSW5BcnJheTtcbmV4cG9ydHMuaW50ID0gaW50O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNOdW0gPSBpc051bTtcbi8vIEBjcmVkaXRzIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3JvZ296aG5pa29mZi9hNDNjZmVkMjdjNDFlNGU2OGNkY1xuZnVuY3Rpb24gZmluZEluQXJyYXkoYXJyYXkgLyo6IEFycmF5PGFueT4gfCBUb3VjaExpc3QqLywgY2FsbGJhY2sgLyo6IEZ1bmN0aW9uKi8pIC8qOiBhbnkqL3tcbiAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNhbGxiYWNrLmFwcGx5KGNhbGxiYWNrLCBbYXJyYXlbaV0sIGksIGFycmF5XSkpIHJldHVybiBhcnJheVtpXTtcbiAgfVxufVxuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jIC8qOiBhbnkqLykgLyo6IGJvb2xlYW4gJWNoZWNrcyove1xuICAvLyAkRmxvd0lnbm9yZVttZXRob2QtdW5iaW5kaW5nXVxuICByZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZ1bmMpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuZnVuY3Rpb24gaXNOdW0obnVtIC8qOiBhbnkqLykgLyo6IGJvb2xlYW4gJWNoZWNrcyove1xuICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKG51bSk7XG59XG5mdW5jdGlvbiBpbnQoYSAvKjogc3RyaW5nKi8pIC8qOiBudW1iZXIqL3tcbiAgcmV0dXJuIHBhcnNlSW50KGEsIDEwKTtcbn1cbmZ1bmN0aW9uIGRvbnRTZXRNZShwcm9wcyAvKjogT2JqZWN0Ki8sIHByb3BOYW1lIC8qOiBzdHJpbmcqLywgY29tcG9uZW50TmFtZSAvKjogc3RyaW5nKi8pIC8qOiA/RXJyb3IqL3tcbiAgaWYgKHByb3BzW3Byb3BOYW1lXSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3AgXCIuY29uY2F0KHByb3BOYW1lLCBcIiBwYXNzZWQgdG8gXCIpLmNvbmNhdChjb21wb25lbnROYW1lLCBcIiAtIGRvIG5vdCBzZXQgdGhpcywgc2V0IGl0IG9uIHRoZSBjaGlsZC5cIikpO1xuICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/react-draggable/build/cjs/utils/shims.js\n");

/***/ }),

/***/ "../../node_modules/react-draggable/node_modules/clsx/dist/clsx.m.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/react-draggable/node_modules/clsx/dist/clsx.m.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: () => (/* binding */ clsx),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f);else for(t in e)e[t]&&(n&&(n+=\" \"),n+=t);return n}function clsx(){for(var e,t,f=0,n=\"\";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clsx);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWRyYWdnYWJsZS9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9zdC8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtZHJhZ2dhYmxlL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzP2QyNzciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpZm9yKHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zik7ZWxzZSBmb3IodCBpbiBlKWVbdF0mJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIjtmPGFyZ3VtZW50cy5sZW5ndGg7KShlPWFyZ3VtZW50c1tmKytdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/react-draggable/node_modules/clsx/dist/clsx.m.js\n");

/***/ }),

/***/ "../../node_modules/react-grid-layout/build/GridItem.js":
/*!**************************************************************!*\
  !*** ../../node_modules/react-grid-layout/build/GridItem.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\"));\nvar _reactDom = __webpack_require__(/*! react-dom */ \"webpack/sharing/consume/default/react-dom/react-dom\");\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"../../node_modules/prop-types/index.js\"));\nvar _reactDraggable = __webpack_require__(/*! react-draggable */ \"../../node_modules/react-draggable/build/cjs/cjs.js\");\nvar _reactResizable = __webpack_require__(/*! react-resizable */ \"../../node_modules/react-resizable/index.js\");\nvar _utils = __webpack_require__(/*! ./utils */ \"../../node_modules/react-grid-layout/build/utils.js\");\nvar _calculateUtils = __webpack_require__(/*! ./calculateUtils */ \"../../node_modules/react-grid-layout/build/calculateUtils.js\");\nvar _ReactGridLayoutPropTypes = __webpack_require__(/*! ./ReactGridLayoutPropTypes */ \"../../node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js\");\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"../../node_modules/clsx/dist/clsx.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*:: import type { Element as ReactElement, Node as ReactNode } from \"react\";*/\n/*:: import type {\n  ReactDraggableCallbackData,\n  GridDragEvent,\n  GridResizeEvent,\n  DroppingPosition,\n  Position,\n  ResizeHandleAxis\n} from \"./utils\";*/\n/*:: import type { PositionParams } from \"./calculateUtils\";*/\n/*:: import type { ResizeHandle, ReactRef } from \"./ReactGridLayoutPropTypes\";*/\n/*:: type PartialPosition = { top: number, left: number };*/\n/*:: type GridItemCallback<Data: GridDragEvent | GridResizeEvent> = (\n  i: string,\n  w: number,\n  h: number,\n  Data\n) => void;*/\n/*:: type ResizeCallbackData = {\n  node: HTMLElement,\n  size: Position,\n  handle: ResizeHandleAxis\n};*/\n/*:: type GridItemResizeCallback = (\n  e: Event,\n  data: ResizeCallbackData,\n  position: Position\n) => void;*/\n/*:: type State = {\n  resizing: ?{ top: number, left: number, width: number, height: number },\n  dragging: ?{ top: number, left: number },\n  className: string\n};*/\n/*:: type Props = {\n  children: ReactElement<any>,\n  cols: number,\n  containerWidth: number,\n  margin: [number, number],\n  containerPadding: [number, number],\n  rowHeight: number,\n  maxRows: number,\n  isDraggable: boolean,\n  isResizable: boolean,\n  isBounded: boolean,\n  static?: boolean,\n  useCSSTransforms?: boolean,\n  usePercentages?: boolean,\n  transformScale: number,\n  droppingPosition?: DroppingPosition,\n\n  className: string,\n  style?: Object,\n  // Draggability\n  cancel: string,\n  handle: string,\n\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n\n  minW: number,\n  maxW: number,\n  minH: number,\n  maxH: number,\n  i: string,\n\n  resizeHandles?: ResizeHandleAxis[],\n  resizeHandle?: ResizeHandle,\n\n  onDrag?: GridItemCallback<GridDragEvent>,\n  onDragStart?: GridItemCallback<GridDragEvent>,\n  onDragStop?: GridItemCallback<GridDragEvent>,\n  onResize?: GridItemCallback<GridResizeEvent>,\n  onResizeStart?: GridItemCallback<GridResizeEvent>,\n  onResizeStop?: GridItemCallback<GridResizeEvent>\n};*/\n/*:: type DefaultProps = {\n  className: string,\n  cancel: string,\n  handle: string,\n  minH: number,\n  minW: number,\n  maxH: number,\n  maxW: number,\n  transformScale: number\n};*/\n/**\n * An individual item within a ReactGridLayout.\n */\nclass GridItem extends _react.default.Component /*:: <Props, State>*/{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      resizing: null,\n      dragging: null,\n      className: \"\"\n    });\n    _defineProperty(this, \"elementRef\", /*#__PURE__*/_react.default.createRef());\n    /**\n     * onDragStart event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     */\n    _defineProperty(this, \"onDragStart\", (e, _ref) => {\n      let {\n        node\n      } = _ref;\n      const {\n        onDragStart,\n        transformScale\n      } = this.props;\n      if (!onDragStart) return;\n      const newPosition /*: PartialPosition*/ = {\n        top: 0,\n        left: 0\n      };\n\n      // TODO: this wont work on nested parents\n      const {\n        offsetParent\n      } = node;\n      if (!offsetParent) return;\n      const parentRect = offsetParent.getBoundingClientRect();\n      const clientRect = node.getBoundingClientRect();\n      const cLeft = clientRect.left / transformScale;\n      const pLeft = parentRect.left / transformScale;\n      const cTop = clientRect.top / transformScale;\n      const pTop = parentRect.top / transformScale;\n      newPosition.left = cLeft - pLeft + offsetParent.scrollLeft;\n      newPosition.top = cTop - pTop + offsetParent.scrollTop;\n      this.setState({\n        dragging: newPosition\n      });\n\n      // Call callback with this data\n      const {\n        x,\n        y\n      } = (0, _calculateUtils.calcXY)(this.getPositionParams(), newPosition.top, newPosition.left, this.props.w, this.props.h);\n      return onDragStart.call(this, this.props.i, x, y, {\n        e,\n        node,\n        newPosition\n      });\n    });\n    /**\n     * onDrag event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     * @param  {boolean} dontFlush    if true, will not call flushSync\n     */\n    _defineProperty(this, \"onDrag\", (e, _ref2, dontFlush) => {\n      let {\n        node,\n        deltaX,\n        deltaY\n      } = _ref2;\n      const {\n        onDrag\n      } = this.props;\n      if (!onDrag) return;\n      if (!this.state.dragging) {\n        throw new Error(\"onDrag called before onDragStart.\");\n      }\n      let top = this.state.dragging.top + deltaY;\n      let left = this.state.dragging.left + deltaX;\n      const {\n        isBounded,\n        i,\n        w,\n        h,\n        containerWidth\n      } = this.props;\n      const positionParams = this.getPositionParams();\n\n      // Boundary calculations; keeps items within the grid\n      if (isBounded) {\n        const {\n          offsetParent\n        } = node;\n        if (offsetParent) {\n          const {\n            margin,\n            rowHeight,\n            containerPadding\n          } = this.props;\n          const bottomBoundary = offsetParent.clientHeight - (0, _calculateUtils.calcGridItemWHPx)(h, rowHeight, margin[1]);\n          top = (0, _calculateUtils.clamp)(top - containerPadding[1], 0, bottomBoundary);\n          const colWidth = (0, _calculateUtils.calcGridColWidth)(positionParams);\n          const rightBoundary = containerWidth - (0, _calculateUtils.calcGridItemWHPx)(w, colWidth, margin[0]);\n          left = (0, _calculateUtils.clamp)(left - containerPadding[0], 0, rightBoundary);\n        }\n      }\n      const newPosition /*: PartialPosition*/ = {\n        top,\n        left\n      };\n\n      // dontFlush is set if we're calling from inside\n      if (dontFlush) {\n        this.setState({\n          dragging: newPosition\n        });\n      } else {\n        (0, _reactDom.flushSync)(() => {\n          this.setState({\n            dragging: newPosition\n          });\n        });\n      }\n\n      // Call callback with this data\n      const {\n        x,\n        y\n      } = (0, _calculateUtils.calcXY)(positionParams, top, left, w, h);\n      return onDrag.call(this, i, x, y, {\n        e,\n        node,\n        newPosition\n      });\n    });\n    /**\n     * onDragStop event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     */\n    _defineProperty(this, \"onDragStop\", (e, _ref3) => {\n      let {\n        node\n      } = _ref3;\n      const {\n        onDragStop\n      } = this.props;\n      if (!onDragStop) return;\n      if (!this.state.dragging) {\n        throw new Error(\"onDragEnd called before onDragStart.\");\n      }\n      const {\n        w,\n        h,\n        i\n      } = this.props;\n      const {\n        left,\n        top\n      } = this.state.dragging;\n      const newPosition /*: PartialPosition*/ = {\n        top,\n        left\n      };\n      this.setState({\n        dragging: null\n      });\n      const {\n        x,\n        y\n      } = (0, _calculateUtils.calcXY)(this.getPositionParams(), top, left, w, h);\n      return onDragStop.call(this, i, x, y, {\n        e,\n        node,\n        newPosition\n      });\n    });\n    /**\n     * onResizeStop event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node and size information\n     */\n    _defineProperty(this, \"onResizeStop\", (e, callbackData, position) => this.onResizeHandler(e, callbackData, position, \"onResizeStop\"));\n    // onResizeStart event handler\n    _defineProperty(this, \"onResizeStart\", (e, callbackData, position) => this.onResizeHandler(e, callbackData, position, \"onResizeStart\"));\n    // onResize event handler\n    _defineProperty(this, \"onResize\", (e, callbackData, position) => this.onResizeHandler(e, callbackData, position, \"onResize\"));\n  }\n  shouldComponentUpdate(nextProps /*: Props*/, nextState /*: State*/) /*: boolean*/{\n    // We can't deeply compare children. If the developer memoizes them, we can\n    // use this optimization.\n    if (this.props.children !== nextProps.children) return true;\n    if (this.props.droppingPosition !== nextProps.droppingPosition) return true;\n    // TODO memoize these calculations so they don't take so long?\n    const oldPosition = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(this.props), this.props.x, this.props.y, this.props.w, this.props.h, this.state);\n    const newPosition = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(nextProps), nextProps.x, nextProps.y, nextProps.w, nextProps.h, nextState);\n    return !(0, _utils.fastPositionEqual)(oldPosition, newPosition) || this.props.useCSSTransforms !== nextProps.useCSSTransforms;\n  }\n  componentDidMount() {\n    this.moveDroppingItem({});\n  }\n  componentDidUpdate(prevProps /*: Props*/) {\n    this.moveDroppingItem(prevProps);\n  }\n\n  // When a droppingPosition is present, this means we should fire a move event, as if we had moved\n  // this element by `x, y` pixels.\n  moveDroppingItem(prevProps /*: Props*/) {\n    const {\n      droppingPosition\n    } = this.props;\n    if (!droppingPosition) return;\n    const node = this.elementRef.current;\n    // Can't find DOM node (are we unmounted?)\n    if (!node) return;\n    const prevDroppingPosition = prevProps.droppingPosition || {\n      left: 0,\n      top: 0\n    };\n    const {\n      dragging\n    } = this.state;\n    const shouldDrag = dragging && droppingPosition.left !== prevDroppingPosition.left || droppingPosition.top !== prevDroppingPosition.top;\n    if (!dragging) {\n      this.onDragStart(droppingPosition.e, {\n        node,\n        deltaX: droppingPosition.left,\n        deltaY: droppingPosition.top\n      });\n    } else if (shouldDrag) {\n      const deltaX = droppingPosition.left - dragging.left;\n      const deltaY = droppingPosition.top - dragging.top;\n      this.onDrag(droppingPosition.e, {\n        node,\n        deltaX,\n        deltaY\n      }, true // dontFLush: avoid flushSync to temper warnings\n      );\n    }\n  }\n\n  getPositionParams() /*: PositionParams*/{\n    let props /*: Props*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n    return {\n      cols: props.cols,\n      containerPadding: props.containerPadding,\n      containerWidth: props.containerWidth,\n      margin: props.margin,\n      maxRows: props.maxRows,\n      rowHeight: props.rowHeight\n    };\n  }\n\n  /**\n   * This is where we set the grid item's absolute placement. It gets a little tricky because we want to do it\n   * well when server rendering, and the only way to do that properly is to use percentage width/left because\n   * we don't know exactly what the browser viewport is.\n   * Unfortunately, CSS Transforms, which are great for performance, break in this instance because a percentage\n   * left is relative to the item itself, not its container! So we cannot use them on the server rendering pass.\n   *\n   * @param  {Object} pos Position object with width, height, left, top.\n   * @return {Object}     Style object.\n   */\n  createStyle(pos /*: Position*/) /*: { [key: string]: ?string }*/{\n    const {\n      usePercentages,\n      containerWidth,\n      useCSSTransforms\n    } = this.props;\n    let style;\n    // CSS Transforms support (default)\n    if (useCSSTransforms) {\n      style = (0, _utils.setTransform)(pos);\n    } else {\n      // top,left (slow)\n      style = (0, _utils.setTopLeft)(pos);\n\n      // This is used for server rendering.\n      if (usePercentages) {\n        style.left = (0, _utils.perc)(pos.left / containerWidth);\n        style.width = (0, _utils.perc)(pos.width / containerWidth);\n      }\n    }\n    return style;\n  }\n\n  /**\n   * Mix a Draggable instance into a child.\n   * @param  {Element} child    Child element.\n   * @return {Element}          Child wrapped in Draggable.\n   */\n  mixinDraggable(child /*: ReactElement<any>*/, isDraggable /*: boolean*/) /*: ReactElement<any>*/{\n    return /*#__PURE__*/_react.default.createElement(_reactDraggable.DraggableCore, {\n      disabled: !isDraggable,\n      onStart: this.onDragStart,\n      onDrag: this.onDrag,\n      onStop: this.onDragStop,\n      handle: this.props.handle,\n      cancel: \".react-resizable-handle\" + (this.props.cancel ? \",\" + this.props.cancel : \"\"),\n      scale: this.props.transformScale,\n      nodeRef: this.elementRef\n    }, child);\n  }\n\n  /**\n   * Utility function to setup callback handler definitions for\n   * similarily structured resize events.\n   */\n  curryResizeHandler(position /*: Position*/, handler /*: Function*/) /*: Function*/{\n    return (e /*: Event*/, data /*: ResizeCallbackData*/) => /*: Function*/handler(e, data, position);\n  }\n\n  /**\n   * Mix a Resizable instance into a child.\n   * @param  {Element} child    Child element.\n   * @param  {Object} position  Position object (pixel values)\n   * @return {Element}          Child wrapped in Resizable.\n   */\n  mixinResizable(child /*: ReactElement<any>*/, position /*: Position*/, isResizable /*: boolean*/) /*: ReactElement<any>*/{\n    const {\n      cols,\n      minW,\n      minH,\n      maxW,\n      maxH,\n      transformScale,\n      resizeHandles,\n      resizeHandle\n    } = this.props;\n    const positionParams = this.getPositionParams();\n\n    // This is the max possible width - doesn't go to infinity because of the width of the window\n    const maxWidth = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, cols, 0).width;\n\n    // Calculate min/max constraints using our min & maxes\n    const mins = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, minW, minH);\n    const maxes = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, maxW, maxH);\n    const minConstraints = [mins.width, mins.height];\n    const maxConstraints = [Math.min(maxes.width, maxWidth), Math.min(maxes.height, Infinity)];\n    return /*#__PURE__*/_react.default.createElement(_reactResizable.Resizable\n    // These are opts for the resize handle itself\n    , {\n      draggableOpts: {\n        disabled: !isResizable\n      },\n      className: isResizable ? undefined : \"react-resizable-hide\",\n      width: position.width,\n      height: position.height,\n      minConstraints: minConstraints,\n      maxConstraints: maxConstraints,\n      onResizeStop: this.curryResizeHandler(position, this.onResizeStop),\n      onResizeStart: this.curryResizeHandler(position, this.onResizeStart),\n      onResize: this.curryResizeHandler(position, this.onResize),\n      transformScale: transformScale,\n      resizeHandles: resizeHandles,\n      handle: resizeHandle\n    }, child);\n  }\n  /**\n   * Wrapper around resize events to provide more useful data.\n   */\n  onResizeHandler(e /*: Event*/, _ref4 /*:: */,\n  // 'size' is updated position\n  position /*: Position*/,\n  // existing position\n  handlerName /*: string*/) /*: void*/{\n    let {\n      node,\n      size,\n      handle\n    } /*: ResizeCallbackData*/ = _ref4 /*: ResizeCallbackData*/;\n    const handler = this.props[handlerName];\n    if (!handler) return;\n    const {\n      x,\n      y,\n      i,\n      maxH,\n      minH,\n      containerWidth\n    } = this.props;\n    const {\n      minW,\n      maxW\n    } = this.props;\n\n    // Clamping of dimensions based on resize direction\n    let updatedSize = size;\n    if (node) {\n      updatedSize = (0, _utils.resizeItemInDirection)(handle, position, size, containerWidth);\n      (0, _reactDom.flushSync)(() => {\n        this.setState({\n          resizing: handlerName === \"onResizeStop\" ? null : updatedSize\n        });\n      });\n    }\n\n    // Get new XY based on pixel size\n    let {\n      w,\n      h\n    } = (0, _calculateUtils.calcWH)(this.getPositionParams(), updatedSize.width, updatedSize.height, x, y, handle);\n\n    // Min/max capping.\n    // minW should be at least 1 (TODO propTypes validation?)\n    w = (0, _calculateUtils.clamp)(w, Math.max(minW, 1), maxW);\n    h = (0, _calculateUtils.clamp)(h, minH, maxH);\n    handler.call(this, i, w, h, {\n      e,\n      node,\n      size: updatedSize,\n      handle\n    });\n  }\n  render() /*: ReactNode*/{\n    const {\n      x,\n      y,\n      w,\n      h,\n      isDraggable,\n      isResizable,\n      droppingPosition,\n      useCSSTransforms\n    } = this.props;\n    const pos = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(), x, y, w, h, this.state);\n    const child = _react.default.Children.only(this.props.children);\n\n    // Create the child element. We clone the existing element but modify its className and style.\n    let newChild = /*#__PURE__*/_react.default.cloneElement(child, {\n      ref: this.elementRef,\n      className: (0, _clsx.default)(\"react-grid-item\", child.props.className, this.props.className, {\n        static: this.props.static,\n        resizing: Boolean(this.state.resizing),\n        \"react-draggable\": isDraggable,\n        \"react-draggable-dragging\": Boolean(this.state.dragging),\n        dropping: Boolean(droppingPosition),\n        cssTransforms: useCSSTransforms\n      }),\n      // We can set the width and height on the child, but unfortunately we can't set the position.\n      style: {\n        ...this.props.style,\n        ...child.props.style,\n        ...this.createStyle(pos)\n      }\n    });\n\n    // Resizable support. This is usually on but the user can toggle it off.\n    newChild = this.mixinResizable(newChild, pos, isResizable);\n\n    // Draggable support. This is always on, except for with placeholders.\n    newChild = this.mixinDraggable(newChild, isDraggable);\n    return newChild;\n  }\n}\nexports[\"default\"] = GridItem;\n_defineProperty(GridItem, \"propTypes\", {\n  // Children must be only a single element\n  children: _propTypes.default.element,\n  // General grid attributes\n  cols: _propTypes.default.number.isRequired,\n  containerWidth: _propTypes.default.number.isRequired,\n  rowHeight: _propTypes.default.number.isRequired,\n  margin: _propTypes.default.array.isRequired,\n  maxRows: _propTypes.default.number.isRequired,\n  containerPadding: _propTypes.default.array.isRequired,\n  // These are all in grid units\n  x: _propTypes.default.number.isRequired,\n  y: _propTypes.default.number.isRequired,\n  w: _propTypes.default.number.isRequired,\n  h: _propTypes.default.number.isRequired,\n  // All optional\n  minW: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"minWidth not Number\");\n    if (value > props.w || value > props.maxW) return new Error(\"minWidth larger than item width/maxWidth\");\n  },\n  maxW: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"maxWidth not Number\");\n    if (value < props.w || value < props.minW) return new Error(\"maxWidth smaller than item width/minWidth\");\n  },\n  minH: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"minHeight not Number\");\n    if (value > props.h || value > props.maxH) return new Error(\"minHeight larger than item height/maxHeight\");\n  },\n  maxH: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"maxHeight not Number\");\n    if (value < props.h || value < props.minH) return new Error(\"maxHeight smaller than item height/minHeight\");\n  },\n  // ID is nice to have for callbacks\n  i: _propTypes.default.string.isRequired,\n  // Resize handle options\n  resizeHandles: _ReactGridLayoutPropTypes.resizeHandleAxesType,\n  resizeHandle: _ReactGridLayoutPropTypes.resizeHandleType,\n  // Functions\n  onDragStop: _propTypes.default.func,\n  onDragStart: _propTypes.default.func,\n  onDrag: _propTypes.default.func,\n  onResizeStop: _propTypes.default.func,\n  onResizeStart: _propTypes.default.func,\n  onResize: _propTypes.default.func,\n  // Flags\n  isDraggable: _propTypes.default.bool.isRequired,\n  isResizable: _propTypes.default.bool.isRequired,\n  isBounded: _propTypes.default.bool.isRequired,\n  static: _propTypes.default.bool,\n  // Use CSS transforms instead of top/left\n  useCSSTransforms: _propTypes.default.bool.isRequired,\n  transformScale: _propTypes.default.number,\n  // Others\n  className: _propTypes.default.string,\n  // Selector for draggable handle\n  handle: _propTypes.default.string,\n  // Selector for draggable cancel (see react-draggable)\n  cancel: _propTypes.default.string,\n  // Current position of a dropping element\n  droppingPosition: _propTypes.default.shape({\n    e: _propTypes.default.object.isRequired,\n    left: _propTypes.default.number.isRequired,\n    top: _propTypes.default.number.isRequired\n  })\n});\n_defineProperty(GridItem, \"defaultProps\", {\n  className: \"\",\n  cancel: \"\",\n  handle: \"\",\n  minH: 1,\n  minW: 1,\n  maxH: Infinity,\n  maxW: Infinity,\n  transformScale: 1\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL0dyaWRJdGVtLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL0dyaWRJdGVtLmpzP2JmOWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoXCJyZWFjdC1kb21cIik7XG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xudmFyIF9yZWFjdERyYWdnYWJsZSA9IHJlcXVpcmUoXCJyZWFjdC1kcmFnZ2FibGVcIik7XG52YXIgX3JlYWN0UmVzaXphYmxlID0gcmVxdWlyZShcInJlYWN0LXJlc2l6YWJsZVwiKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBfY2FsY3VsYXRlVXRpbHMgPSByZXF1aXJlKFwiLi9jYWxjdWxhdGVVdGlsc1wiKTtcbnZhciBfUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzID0gcmVxdWlyZShcIi4vUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzXCIpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxuLyo6OiBpbXBvcnQgdHlwZSB7IEVsZW1lbnQgYXMgUmVhY3RFbGVtZW50LCBOb2RlIGFzIFJlYWN0Tm9kZSB9IGZyb20gXCJyZWFjdFwiOyovXG4vKjo6IGltcG9ydCB0eXBlIHtcbiAgUmVhY3REcmFnZ2FibGVDYWxsYmFja0RhdGEsXG4gIEdyaWREcmFnRXZlbnQsXG4gIEdyaWRSZXNpemVFdmVudCxcbiAgRHJvcHBpbmdQb3NpdGlvbixcbiAgUG9zaXRpb24sXG4gIFJlc2l6ZUhhbmRsZUF4aXNcbn0gZnJvbSBcIi4vdXRpbHNcIjsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7IFBvc2l0aW9uUGFyYW1zIH0gZnJvbSBcIi4vY2FsY3VsYXRlVXRpbHNcIjsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7IFJlc2l6ZUhhbmRsZSwgUmVhY3RSZWYgfSBmcm9tIFwiLi9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXNcIjsqL1xuLyo6OiB0eXBlIFBhcnRpYWxQb3NpdGlvbiA9IHsgdG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciB9OyovXG4vKjo6IHR5cGUgR3JpZEl0ZW1DYWxsYmFjazxEYXRhOiBHcmlkRHJhZ0V2ZW50IHwgR3JpZFJlc2l6ZUV2ZW50PiA9IChcbiAgaTogc3RyaW5nLFxuICB3OiBudW1iZXIsXG4gIGg6IG51bWJlcixcbiAgRGF0YVxuKSA9PiB2b2lkOyovXG4vKjo6IHR5cGUgUmVzaXplQ2FsbGJhY2tEYXRhID0ge1xuICBub2RlOiBIVE1MRWxlbWVudCxcbiAgc2l6ZTogUG9zaXRpb24sXG4gIGhhbmRsZTogUmVzaXplSGFuZGxlQXhpc1xufTsqL1xuLyo6OiB0eXBlIEdyaWRJdGVtUmVzaXplQ2FsbGJhY2sgPSAoXG4gIGU6IEV2ZW50LFxuICBkYXRhOiBSZXNpemVDYWxsYmFja0RhdGEsXG4gIHBvc2l0aW9uOiBQb3NpdGlvblxuKSA9PiB2b2lkOyovXG4vKjo6IHR5cGUgU3RhdGUgPSB7XG4gIHJlc2l6aW5nOiA/eyB0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9LFxuICBkcmFnZ2luZzogP3sgdG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciB9LFxuICBjbGFzc05hbWU6IHN0cmluZ1xufTsqL1xuLyo6OiB0eXBlIFByb3BzID0ge1xuICBjaGlsZHJlbjogUmVhY3RFbGVtZW50PGFueT4sXG4gIGNvbHM6IG51bWJlcixcbiAgY29udGFpbmVyV2lkdGg6IG51bWJlcixcbiAgbWFyZ2luOiBbbnVtYmVyLCBudW1iZXJdLFxuICBjb250YWluZXJQYWRkaW5nOiBbbnVtYmVyLCBudW1iZXJdLFxuICByb3dIZWlnaHQ6IG51bWJlcixcbiAgbWF4Um93czogbnVtYmVyLFxuICBpc0RyYWdnYWJsZTogYm9vbGVhbixcbiAgaXNSZXNpemFibGU6IGJvb2xlYW4sXG4gIGlzQm91bmRlZDogYm9vbGVhbixcbiAgc3RhdGljPzogYm9vbGVhbixcbiAgdXNlQ1NTVHJhbnNmb3Jtcz86IGJvb2xlYW4sXG4gIHVzZVBlcmNlbnRhZ2VzPzogYm9vbGVhbixcbiAgdHJhbnNmb3JtU2NhbGU6IG51bWJlcixcbiAgZHJvcHBpbmdQb3NpdGlvbj86IERyb3BwaW5nUG9zaXRpb24sXG5cbiAgY2xhc3NOYW1lOiBzdHJpbmcsXG4gIHN0eWxlPzogT2JqZWN0LFxuICAvLyBEcmFnZ2FiaWxpdHlcbiAgY2FuY2VsOiBzdHJpbmcsXG4gIGhhbmRsZTogc3RyaW5nLFxuXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICB3OiBudW1iZXIsXG4gIGg6IG51bWJlcixcblxuICBtaW5XOiBudW1iZXIsXG4gIG1heFc6IG51bWJlcixcbiAgbWluSDogbnVtYmVyLFxuICBtYXhIOiBudW1iZXIsXG4gIGk6IHN0cmluZyxcblxuICByZXNpemVIYW5kbGVzPzogUmVzaXplSGFuZGxlQXhpc1tdLFxuICByZXNpemVIYW5kbGU/OiBSZXNpemVIYW5kbGUsXG5cbiAgb25EcmFnPzogR3JpZEl0ZW1DYWxsYmFjazxHcmlkRHJhZ0V2ZW50PixcbiAgb25EcmFnU3RhcnQ/OiBHcmlkSXRlbUNhbGxiYWNrPEdyaWREcmFnRXZlbnQ+LFxuICBvbkRyYWdTdG9wPzogR3JpZEl0ZW1DYWxsYmFjazxHcmlkRHJhZ0V2ZW50PixcbiAgb25SZXNpemU/OiBHcmlkSXRlbUNhbGxiYWNrPEdyaWRSZXNpemVFdmVudD4sXG4gIG9uUmVzaXplU3RhcnQ/OiBHcmlkSXRlbUNhbGxiYWNrPEdyaWRSZXNpemVFdmVudD4sXG4gIG9uUmVzaXplU3RvcD86IEdyaWRJdGVtQ2FsbGJhY2s8R3JpZFJlc2l6ZUV2ZW50PlxufTsqL1xuLyo6OiB0eXBlIERlZmF1bHRQcm9wcyA9IHtcbiAgY2xhc3NOYW1lOiBzdHJpbmcsXG4gIGNhbmNlbDogc3RyaW5nLFxuICBoYW5kbGU6IHN0cmluZyxcbiAgbWluSDogbnVtYmVyLFxuICBtaW5XOiBudW1iZXIsXG4gIG1heEg6IG51bWJlcixcbiAgbWF4VzogbnVtYmVyLFxuICB0cmFuc2Zvcm1TY2FsZTogbnVtYmVyXG59OyovXG4vKipcbiAqIEFuIGluZGl2aWR1YWwgaXRlbSB3aXRoaW4gYSBSZWFjdEdyaWRMYXlvdXQuXG4gKi9cbmNsYXNzIEdyaWRJdGVtIGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IC8qOjogPFByb3BzLCBTdGF0ZT4qL3tcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICByZXNpemluZzogbnVsbCxcbiAgICAgIGRyYWdnaW5nOiBudWxsLFxuICAgICAgY2xhc3NOYW1lOiBcIlwiXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZWxlbWVudFJlZlwiLCAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlUmVmKCkpO1xuICAgIC8qKlxuICAgICAqIG9uRHJhZ1N0YXJ0IGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gIHtFdmVudH0gIGUgICAgICAgICAgICAgZXZlbnQgZGF0YVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gY2FsbGJhY2tEYXRhICBhbiBvYmplY3Qgd2l0aCBub2RlLCBkZWx0YSBhbmQgcG9zaXRpb24gaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdTdGFydFwiLCAoZSwgX3JlZikgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgbm9kZVxuICAgICAgfSA9IF9yZWY7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uRHJhZ1N0YXJ0LFxuICAgICAgICB0cmFuc2Zvcm1TY2FsZVxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAoIW9uRHJhZ1N0YXJ0KSByZXR1cm47XG4gICAgICBjb25zdCBuZXdQb3NpdGlvbiAvKjogUGFydGlhbFBvc2l0aW9uKi8gPSB7XG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMFxuICAgICAgfTtcblxuICAgICAgLy8gVE9ETzogdGhpcyB3b250IHdvcmsgb24gbmVzdGVkIHBhcmVudHNcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0UGFyZW50XG4gICAgICB9ID0gbm9kZTtcbiAgICAgIGlmICghb2Zmc2V0UGFyZW50KSByZXR1cm47XG4gICAgICBjb25zdCBwYXJlbnRSZWN0ID0gb2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY2xpZW50UmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjTGVmdCA9IGNsaWVudFJlY3QubGVmdCAvIHRyYW5zZm9ybVNjYWxlO1xuICAgICAgY29uc3QgcExlZnQgPSBwYXJlbnRSZWN0LmxlZnQgLyB0cmFuc2Zvcm1TY2FsZTtcbiAgICAgIGNvbnN0IGNUb3AgPSBjbGllbnRSZWN0LnRvcCAvIHRyYW5zZm9ybVNjYWxlO1xuICAgICAgY29uc3QgcFRvcCA9IHBhcmVudFJlY3QudG9wIC8gdHJhbnNmb3JtU2NhbGU7XG4gICAgICBuZXdQb3NpdGlvbi5sZWZ0ID0gY0xlZnQgLSBwTGVmdCArIG9mZnNldFBhcmVudC5zY3JvbGxMZWZ0O1xuICAgICAgbmV3UG9zaXRpb24udG9wID0gY1RvcCAtIHBUb3AgKyBvZmZzZXRQYXJlbnQuc2Nyb2xsVG9wO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGRyYWdnaW5nOiBuZXdQb3NpdGlvblxuICAgICAgfSk7XG5cbiAgICAgIC8vIENhbGwgY2FsbGJhY2sgd2l0aCB0aGlzIGRhdGFcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY1hZKSh0aGlzLmdldFBvc2l0aW9uUGFyYW1zKCksIG5ld1Bvc2l0aW9uLnRvcCwgbmV3UG9zaXRpb24ubGVmdCwgdGhpcy5wcm9wcy53LCB0aGlzLnByb3BzLmgpO1xuICAgICAgcmV0dXJuIG9uRHJhZ1N0YXJ0LmNhbGwodGhpcywgdGhpcy5wcm9wcy5pLCB4LCB5LCB7XG4gICAgICAgIGUsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5ld1Bvc2l0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBvbkRyYWcgZXZlbnQgaGFuZGxlclxuICAgICAqIEBwYXJhbSAge0V2ZW50fSAgZSAgICAgICAgICAgICBldmVudCBkYXRhXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBjYWxsYmFja0RhdGEgIGFuIG9iamVjdCB3aXRoIG5vZGUsIGRlbHRhIGFuZCBwb3NpdGlvbiBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGRvbnRGbHVzaCAgICBpZiB0cnVlLCB3aWxsIG5vdCBjYWxsIGZsdXNoU3luY1xuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJhZ1wiLCAoZSwgX3JlZjIsIGRvbnRGbHVzaCkgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgZGVsdGFYLFxuICAgICAgICBkZWx0YVlcbiAgICAgIH0gPSBfcmVmMjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb25EcmFnXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGlmICghb25EcmFnKSByZXR1cm47XG4gICAgICBpZiAoIXRoaXMuc3RhdGUuZHJhZ2dpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25EcmFnIGNhbGxlZCBiZWZvcmUgb25EcmFnU3RhcnQuXCIpO1xuICAgICAgfVxuICAgICAgbGV0IHRvcCA9IHRoaXMuc3RhdGUuZHJhZ2dpbmcudG9wICsgZGVsdGFZO1xuICAgICAgbGV0IGxlZnQgPSB0aGlzLnN0YXRlLmRyYWdnaW5nLmxlZnQgKyBkZWx0YVg7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzQm91bmRlZCxcbiAgICAgICAgaSxcbiAgICAgICAgdyxcbiAgICAgICAgaCxcbiAgICAgICAgY29udGFpbmVyV2lkdGhcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgcG9zaXRpb25QYXJhbXMgPSB0aGlzLmdldFBvc2l0aW9uUGFyYW1zKCk7XG5cbiAgICAgIC8vIEJvdW5kYXJ5IGNhbGN1bGF0aW9uczsga2VlcHMgaXRlbXMgd2l0aGluIHRoZSBncmlkXG4gICAgICBpZiAoaXNCb3VuZGVkKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBvZmZzZXRQYXJlbnRcbiAgICAgICAgfSA9IG5vZGU7XG4gICAgICAgIGlmIChvZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBtYXJnaW4sXG4gICAgICAgICAgICByb3dIZWlnaHQsXG4gICAgICAgICAgICBjb250YWluZXJQYWRkaW5nXG4gICAgICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgY29uc3QgYm90dG9tQm91bmRhcnkgPSBvZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IC0gKDAsIF9jYWxjdWxhdGVVdGlscy5jYWxjR3JpZEl0ZW1XSFB4KShoLCByb3dIZWlnaHQsIG1hcmdpblsxXSk7XG4gICAgICAgICAgdG9wID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jbGFtcCkodG9wIC0gY29udGFpbmVyUGFkZGluZ1sxXSwgMCwgYm90dG9tQm91bmRhcnkpO1xuICAgICAgICAgIGNvbnN0IGNvbFdpZHRoID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jYWxjR3JpZENvbFdpZHRoKShwb3NpdGlvblBhcmFtcyk7XG4gICAgICAgICAgY29uc3QgcmlnaHRCb3VuZGFyeSA9IGNvbnRhaW5lcldpZHRoIC0gKDAsIF9jYWxjdWxhdGVVdGlscy5jYWxjR3JpZEl0ZW1XSFB4KSh3LCBjb2xXaWR0aCwgbWFyZ2luWzBdKTtcbiAgICAgICAgICBsZWZ0ID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jbGFtcCkobGVmdCAtIGNvbnRhaW5lclBhZGRpbmdbMF0sIDAsIHJpZ2h0Qm91bmRhcnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdQb3NpdGlvbiAvKjogUGFydGlhbFBvc2l0aW9uKi8gPSB7XG4gICAgICAgIHRvcCxcbiAgICAgICAgbGVmdFxuICAgICAgfTtcblxuICAgICAgLy8gZG9udEZsdXNoIGlzIHNldCBpZiB3ZSdyZSBjYWxsaW5nIGZyb20gaW5zaWRlXG4gICAgICBpZiAoZG9udEZsdXNoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGRyYWdnaW5nOiBuZXdQb3NpdGlvblxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLCBfcmVhY3REb20uZmx1c2hTeW5jKSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBkcmFnZ2luZzogbmV3UG9zaXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGwgY2FsbGJhY2sgd2l0aCB0aGlzIGRhdGFcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY1hZKShwb3NpdGlvblBhcmFtcywgdG9wLCBsZWZ0LCB3LCBoKTtcbiAgICAgIHJldHVybiBvbkRyYWcuY2FsbCh0aGlzLCBpLCB4LCB5LCB7XG4gICAgICAgIGUsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5ld1Bvc2l0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBvbkRyYWdTdG9wIGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gIHtFdmVudH0gIGUgICAgICAgICAgICAgZXZlbnQgZGF0YVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gY2FsbGJhY2tEYXRhICBhbiBvYmplY3Qgd2l0aCBub2RlLCBkZWx0YSBhbmQgcG9zaXRpb24gaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdTdG9wXCIsIChlLCBfcmVmMykgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgbm9kZVxuICAgICAgfSA9IF9yZWYzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvbkRyYWdTdG9wXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGlmICghb25EcmFnU3RvcCkgcmV0dXJuO1xuICAgICAgaWYgKCF0aGlzLnN0YXRlLmRyYWdnaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9uRHJhZ0VuZCBjYWxsZWQgYmVmb3JlIG9uRHJhZ1N0YXJ0LlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdyxcbiAgICAgICAgaCxcbiAgICAgICAgaVxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxlZnQsXG4gICAgICAgIHRvcFxuICAgICAgfSA9IHRoaXMuc3RhdGUuZHJhZ2dpbmc7XG4gICAgICBjb25zdCBuZXdQb3NpdGlvbiAvKjogUGFydGlhbFBvc2l0aW9uKi8gPSB7XG4gICAgICAgIHRvcCxcbiAgICAgICAgbGVmdFxuICAgICAgfTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBkcmFnZ2luZzogbnVsbFxuICAgICAgfSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNYWSkodGhpcy5nZXRQb3NpdGlvblBhcmFtcygpLCB0b3AsIGxlZnQsIHcsIGgpO1xuICAgICAgcmV0dXJuIG9uRHJhZ1N0b3AuY2FsbCh0aGlzLCBpLCB4LCB5LCB7XG4gICAgICAgIGUsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5ld1Bvc2l0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBvblJlc2l6ZVN0b3AgZXZlbnQgaGFuZGxlclxuICAgICAqIEBwYXJhbSAge0V2ZW50fSAgZSAgICAgICAgICAgICBldmVudCBkYXRhXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBjYWxsYmFja0RhdGEgIGFuIG9iamVjdCB3aXRoIG5vZGUgYW5kIHNpemUgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvblJlc2l6ZVN0b3BcIiwgKGUsIGNhbGxiYWNrRGF0YSwgcG9zaXRpb24pID0+IHRoaXMub25SZXNpemVIYW5kbGVyKGUsIGNhbGxiYWNrRGF0YSwgcG9zaXRpb24sIFwib25SZXNpemVTdG9wXCIpKTtcbiAgICAvLyBvblJlc2l6ZVN0YXJ0IGV2ZW50IGhhbmRsZXJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvblJlc2l6ZVN0YXJ0XCIsIChlLCBjYWxsYmFja0RhdGEsIHBvc2l0aW9uKSA9PiB0aGlzLm9uUmVzaXplSGFuZGxlcihlLCBjYWxsYmFja0RhdGEsIHBvc2l0aW9uLCBcIm9uUmVzaXplU3RhcnRcIikpO1xuICAgIC8vIG9uUmVzaXplIGV2ZW50IGhhbmRsZXJcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvblJlc2l6ZVwiLCAoZSwgY2FsbGJhY2tEYXRhLCBwb3NpdGlvbikgPT4gdGhpcy5vblJlc2l6ZUhhbmRsZXIoZSwgY2FsbGJhY2tEYXRhLCBwb3NpdGlvbiwgXCJvblJlc2l6ZVwiKSk7XG4gIH1cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcyAvKjogUHJvcHMqLywgbmV4dFN0YXRlIC8qOiBTdGF0ZSovKSAvKjogYm9vbGVhbiove1xuICAgIC8vIFdlIGNhbid0IGRlZXBseSBjb21wYXJlIGNoaWxkcmVuLiBJZiB0aGUgZGV2ZWxvcGVyIG1lbW9pemVzIHRoZW0sIHdlIGNhblxuICAgIC8vIHVzZSB0aGlzIG9wdGltaXphdGlvbi5cbiAgICBpZiAodGhpcy5wcm9wcy5jaGlsZHJlbiAhPT0gbmV4dFByb3BzLmNoaWxkcmVuKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5wcm9wcy5kcm9wcGluZ1Bvc2l0aW9uICE9PSBuZXh0UHJvcHMuZHJvcHBpbmdQb3NpdGlvbikgcmV0dXJuIHRydWU7XG4gICAgLy8gVE9ETyBtZW1vaXplIHRoZXNlIGNhbGN1bGF0aW9ucyBzbyB0aGV5IGRvbid0IHRha2Ugc28gbG9uZz9cbiAgICBjb25zdCBvbGRQb3NpdGlvbiA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY0dyaWRJdGVtUG9zaXRpb24pKHRoaXMuZ2V0UG9zaXRpb25QYXJhbXModGhpcy5wcm9wcyksIHRoaXMucHJvcHMueCwgdGhpcy5wcm9wcy55LCB0aGlzLnByb3BzLncsIHRoaXMucHJvcHMuaCwgdGhpcy5zdGF0ZSk7XG4gICAgY29uc3QgbmV3UG9zaXRpb24gPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNHcmlkSXRlbVBvc2l0aW9uKSh0aGlzLmdldFBvc2l0aW9uUGFyYW1zKG5leHRQcm9wcyksIG5leHRQcm9wcy54LCBuZXh0UHJvcHMueSwgbmV4dFByb3BzLncsIG5leHRQcm9wcy5oLCBuZXh0U3RhdGUpO1xuICAgIHJldHVybiAhKDAsIF91dGlscy5mYXN0UG9zaXRpb25FcXVhbCkob2xkUG9zaXRpb24sIG5ld1Bvc2l0aW9uKSB8fCB0aGlzLnByb3BzLnVzZUNTU1RyYW5zZm9ybXMgIT09IG5leHRQcm9wcy51c2VDU1NUcmFuc2Zvcm1zO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMubW92ZURyb3BwaW5nSXRlbSh7fSk7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcyAvKjogUHJvcHMqLykge1xuICAgIHRoaXMubW92ZURyb3BwaW5nSXRlbShwcmV2UHJvcHMpO1xuICB9XG5cbiAgLy8gV2hlbiBhIGRyb3BwaW5nUG9zaXRpb24gaXMgcHJlc2VudCwgdGhpcyBtZWFucyB3ZSBzaG91bGQgZmlyZSBhIG1vdmUgZXZlbnQsIGFzIGlmIHdlIGhhZCBtb3ZlZFxuICAvLyB0aGlzIGVsZW1lbnQgYnkgYHgsIHlgIHBpeGVscy5cbiAgbW92ZURyb3BwaW5nSXRlbShwcmV2UHJvcHMgLyo6IFByb3BzKi8pIHtcbiAgICBjb25zdCB7XG4gICAgICBkcm9wcGluZ1Bvc2l0aW9uXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCFkcm9wcGluZ1Bvc2l0aW9uKSByZXR1cm47XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZWxlbWVudFJlZi5jdXJyZW50O1xuICAgIC8vIENhbid0IGZpbmQgRE9NIG5vZGUgKGFyZSB3ZSB1bm1vdW50ZWQ/KVxuICAgIGlmICghbm9kZSkgcmV0dXJuO1xuICAgIGNvbnN0IHByZXZEcm9wcGluZ1Bvc2l0aW9uID0gcHJldlByb3BzLmRyb3BwaW5nUG9zaXRpb24gfHwge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMFxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgZHJhZ2dpbmdcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzaG91bGREcmFnID0gZHJhZ2dpbmcgJiYgZHJvcHBpbmdQb3NpdGlvbi5sZWZ0ICE9PSBwcmV2RHJvcHBpbmdQb3NpdGlvbi5sZWZ0IHx8IGRyb3BwaW5nUG9zaXRpb24udG9wICE9PSBwcmV2RHJvcHBpbmdQb3NpdGlvbi50b3A7XG4gICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgdGhpcy5vbkRyYWdTdGFydChkcm9wcGluZ1Bvc2l0aW9uLmUsIHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgZGVsdGFYOiBkcm9wcGluZ1Bvc2l0aW9uLmxlZnQsXG4gICAgICAgIGRlbHRhWTogZHJvcHBpbmdQb3NpdGlvbi50b3BcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc2hvdWxkRHJhZykge1xuICAgICAgY29uc3QgZGVsdGFYID0gZHJvcHBpbmdQb3NpdGlvbi5sZWZ0IC0gZHJhZ2dpbmcubGVmdDtcbiAgICAgIGNvbnN0IGRlbHRhWSA9IGRyb3BwaW5nUG9zaXRpb24udG9wIC0gZHJhZ2dpbmcudG9wO1xuICAgICAgdGhpcy5vbkRyYWcoZHJvcHBpbmdQb3NpdGlvbi5lLCB7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGRlbHRhWCxcbiAgICAgICAgZGVsdGFZXG4gICAgICB9LCB0cnVlIC8vIGRvbnRGTHVzaDogYXZvaWQgZmx1c2hTeW5jIHRvIHRlbXBlciB3YXJuaW5nc1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBnZXRQb3NpdGlvblBhcmFtcygpIC8qOiBQb3NpdGlvblBhcmFtcyove1xuICAgIGxldCBwcm9wcyAvKjogUHJvcHMqLyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5wcm9wcztcbiAgICByZXR1cm4ge1xuICAgICAgY29sczogcHJvcHMuY29scyxcbiAgICAgIGNvbnRhaW5lclBhZGRpbmc6IHByb3BzLmNvbnRhaW5lclBhZGRpbmcsXG4gICAgICBjb250YWluZXJXaWR0aDogcHJvcHMuY29udGFpbmVyV2lkdGgsXG4gICAgICBtYXJnaW46IHByb3BzLm1hcmdpbixcbiAgICAgIG1heFJvd3M6IHByb3BzLm1heFJvd3MsXG4gICAgICByb3dIZWlnaHQ6IHByb3BzLnJvd0hlaWdodFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyB3aGVyZSB3ZSBzZXQgdGhlIGdyaWQgaXRlbSdzIGFic29sdXRlIHBsYWNlbWVudC4gSXQgZ2V0cyBhIGxpdHRsZSB0cmlja3kgYmVjYXVzZSB3ZSB3YW50IHRvIGRvIGl0XG4gICAqIHdlbGwgd2hlbiBzZXJ2ZXIgcmVuZGVyaW5nLCBhbmQgdGhlIG9ubHkgd2F5IHRvIGRvIHRoYXQgcHJvcGVybHkgaXMgdG8gdXNlIHBlcmNlbnRhZ2Ugd2lkdGgvbGVmdCBiZWNhdXNlXG4gICAqIHdlIGRvbid0IGtub3cgZXhhY3RseSB3aGF0IHRoZSBicm93c2VyIHZpZXdwb3J0IGlzLlxuICAgKiBVbmZvcnR1bmF0ZWx5LCBDU1MgVHJhbnNmb3Jtcywgd2hpY2ggYXJlIGdyZWF0IGZvciBwZXJmb3JtYW5jZSwgYnJlYWsgaW4gdGhpcyBpbnN0YW5jZSBiZWNhdXNlIGEgcGVyY2VudGFnZVxuICAgKiBsZWZ0IGlzIHJlbGF0aXZlIHRvIHRoZSBpdGVtIGl0c2VsZiwgbm90IGl0cyBjb250YWluZXIhIFNvIHdlIGNhbm5vdCB1c2UgdGhlbSBvbiB0aGUgc2VydmVyIHJlbmRlcmluZyBwYXNzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBvcyBQb3NpdGlvbiBvYmplY3Qgd2l0aCB3aWR0aCwgaGVpZ2h0LCBsZWZ0LCB0b3AuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgIFN0eWxlIG9iamVjdC5cbiAgICovXG4gIGNyZWF0ZVN0eWxlKHBvcyAvKjogUG9zaXRpb24qLykgLyo6IHsgW2tleTogc3RyaW5nXTogP3N0cmluZyB9Ki97XG4gICAgY29uc3Qge1xuICAgICAgdXNlUGVyY2VudGFnZXMsXG4gICAgICBjb250YWluZXJXaWR0aCxcbiAgICAgIHVzZUNTU1RyYW5zZm9ybXNcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBsZXQgc3R5bGU7XG4gICAgLy8gQ1NTIFRyYW5zZm9ybXMgc3VwcG9ydCAoZGVmYXVsdClcbiAgICBpZiAodXNlQ1NTVHJhbnNmb3Jtcykge1xuICAgICAgc3R5bGUgPSAoMCwgX3V0aWxzLnNldFRyYW5zZm9ybSkocG9zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdG9wLGxlZnQgKHNsb3cpXG4gICAgICBzdHlsZSA9ICgwLCBfdXRpbHMuc2V0VG9wTGVmdCkocG9zKTtcblxuICAgICAgLy8gVGhpcyBpcyB1c2VkIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgaWYgKHVzZVBlcmNlbnRhZ2VzKSB7XG4gICAgICAgIHN0eWxlLmxlZnQgPSAoMCwgX3V0aWxzLnBlcmMpKHBvcy5sZWZ0IC8gY29udGFpbmVyV2lkdGgpO1xuICAgICAgICBzdHlsZS53aWR0aCA9ICgwLCBfdXRpbHMucGVyYykocG9zLndpZHRoIC8gY29udGFpbmVyV2lkdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICAvKipcbiAgICogTWl4IGEgRHJhZ2dhYmxlIGluc3RhbmNlIGludG8gYSBjaGlsZC5cbiAgICogQHBhcmFtICB7RWxlbWVudH0gY2hpbGQgICAgQ2hpbGQgZWxlbWVudC5cbiAgICogQHJldHVybiB7RWxlbWVudH0gICAgICAgICAgQ2hpbGQgd3JhcHBlZCBpbiBEcmFnZ2FibGUuXG4gICAqL1xuICBtaXhpbkRyYWdnYWJsZShjaGlsZCAvKjogUmVhY3RFbGVtZW50PGFueT4qLywgaXNEcmFnZ2FibGUgLyo6IGJvb2xlYW4qLykgLyo6IFJlYWN0RWxlbWVudDxhbnk+Ki97XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdERyYWdnYWJsZS5EcmFnZ2FibGVDb3JlLCB7XG4gICAgICBkaXNhYmxlZDogIWlzRHJhZ2dhYmxlLFxuICAgICAgb25TdGFydDogdGhpcy5vbkRyYWdTdGFydCxcbiAgICAgIG9uRHJhZzogdGhpcy5vbkRyYWcsXG4gICAgICBvblN0b3A6IHRoaXMub25EcmFnU3RvcCxcbiAgICAgIGhhbmRsZTogdGhpcy5wcm9wcy5oYW5kbGUsXG4gICAgICBjYW5jZWw6IFwiLnJlYWN0LXJlc2l6YWJsZS1oYW5kbGVcIiArICh0aGlzLnByb3BzLmNhbmNlbCA/IFwiLFwiICsgdGhpcy5wcm9wcy5jYW5jZWwgOiBcIlwiKSxcbiAgICAgIHNjYWxlOiB0aGlzLnByb3BzLnRyYW5zZm9ybVNjYWxlLFxuICAgICAgbm9kZVJlZjogdGhpcy5lbGVtZW50UmVmXG4gICAgfSwgY2hpbGQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gc2V0dXAgY2FsbGJhY2sgaGFuZGxlciBkZWZpbml0aW9ucyBmb3JcbiAgICogc2ltaWxhcmlseSBzdHJ1Y3R1cmVkIHJlc2l6ZSBldmVudHMuXG4gICAqL1xuICBjdXJyeVJlc2l6ZUhhbmRsZXIocG9zaXRpb24gLyo6IFBvc2l0aW9uKi8sIGhhbmRsZXIgLyo6IEZ1bmN0aW9uKi8pIC8qOiBGdW5jdGlvbiove1xuICAgIHJldHVybiAoZSAvKjogRXZlbnQqLywgZGF0YSAvKjogUmVzaXplQ2FsbGJhY2tEYXRhKi8pID0+IC8qOiBGdW5jdGlvbiovaGFuZGxlcihlLCBkYXRhLCBwb3NpdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogTWl4IGEgUmVzaXphYmxlIGluc3RhbmNlIGludG8gYSBjaGlsZC5cbiAgICogQHBhcmFtICB7RWxlbWVudH0gY2hpbGQgICAgQ2hpbGQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBwb3NpdGlvbiAgUG9zaXRpb24gb2JqZWN0IChwaXhlbCB2YWx1ZXMpXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9ICAgICAgICAgIENoaWxkIHdyYXBwZWQgaW4gUmVzaXphYmxlLlxuICAgKi9cbiAgbWl4aW5SZXNpemFibGUoY2hpbGQgLyo6IFJlYWN0RWxlbWVudDxhbnk+Ki8sIHBvc2l0aW9uIC8qOiBQb3NpdGlvbiovLCBpc1Jlc2l6YWJsZSAvKjogYm9vbGVhbiovKSAvKjogUmVhY3RFbGVtZW50PGFueT4qL3tcbiAgICBjb25zdCB7XG4gICAgICBjb2xzLFxuICAgICAgbWluVyxcbiAgICAgIG1pbkgsXG4gICAgICBtYXhXLFxuICAgICAgbWF4SCxcbiAgICAgIHRyYW5zZm9ybVNjYWxlLFxuICAgICAgcmVzaXplSGFuZGxlcyxcbiAgICAgIHJlc2l6ZUhhbmRsZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHBvc2l0aW9uUGFyYW1zID0gdGhpcy5nZXRQb3NpdGlvblBhcmFtcygpO1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgbWF4IHBvc3NpYmxlIHdpZHRoIC0gZG9lc24ndCBnbyB0byBpbmZpbml0eSBiZWNhdXNlIG9mIHRoZSB3aWR0aCBvZiB0aGUgd2luZG93XG4gICAgY29uc3QgbWF4V2lkdGggPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNHcmlkSXRlbVBvc2l0aW9uKShwb3NpdGlvblBhcmFtcywgMCwgMCwgY29scywgMCkud2lkdGg7XG5cbiAgICAvLyBDYWxjdWxhdGUgbWluL21heCBjb25zdHJhaW50cyB1c2luZyBvdXIgbWluICYgbWF4ZXNcbiAgICBjb25zdCBtaW5zID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jYWxjR3JpZEl0ZW1Qb3NpdGlvbikocG9zaXRpb25QYXJhbXMsIDAsIDAsIG1pblcsIG1pbkgpO1xuICAgIGNvbnN0IG1heGVzID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jYWxjR3JpZEl0ZW1Qb3NpdGlvbikocG9zaXRpb25QYXJhbXMsIDAsIDAsIG1heFcsIG1heEgpO1xuICAgIGNvbnN0IG1pbkNvbnN0cmFpbnRzID0gW21pbnMud2lkdGgsIG1pbnMuaGVpZ2h0XTtcbiAgICBjb25zdCBtYXhDb25zdHJhaW50cyA9IFtNYXRoLm1pbihtYXhlcy53aWR0aCwgbWF4V2lkdGgpLCBNYXRoLm1pbihtYXhlcy5oZWlnaHQsIEluZmluaXR5KV07XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdFJlc2l6YWJsZS5SZXNpemFibGVcbiAgICAvLyBUaGVzZSBhcmUgb3B0cyBmb3IgdGhlIHJlc2l6ZSBoYW5kbGUgaXRzZWxmXG4gICAgLCB7XG4gICAgICBkcmFnZ2FibGVPcHRzOiB7XG4gICAgICAgIGRpc2FibGVkOiAhaXNSZXNpemFibGVcbiAgICAgIH0sXG4gICAgICBjbGFzc05hbWU6IGlzUmVzaXphYmxlID8gdW5kZWZpbmVkIDogXCJyZWFjdC1yZXNpemFibGUtaGlkZVwiLFxuICAgICAgd2lkdGg6IHBvc2l0aW9uLndpZHRoLFxuICAgICAgaGVpZ2h0OiBwb3NpdGlvbi5oZWlnaHQsXG4gICAgICBtaW5Db25zdHJhaW50czogbWluQ29uc3RyYWludHMsXG4gICAgICBtYXhDb25zdHJhaW50czogbWF4Q29uc3RyYWludHMsXG4gICAgICBvblJlc2l6ZVN0b3A6IHRoaXMuY3VycnlSZXNpemVIYW5kbGVyKHBvc2l0aW9uLCB0aGlzLm9uUmVzaXplU3RvcCksXG4gICAgICBvblJlc2l6ZVN0YXJ0OiB0aGlzLmN1cnJ5UmVzaXplSGFuZGxlcihwb3NpdGlvbiwgdGhpcy5vblJlc2l6ZVN0YXJ0KSxcbiAgICAgIG9uUmVzaXplOiB0aGlzLmN1cnJ5UmVzaXplSGFuZGxlcihwb3NpdGlvbiwgdGhpcy5vblJlc2l6ZSksXG4gICAgICB0cmFuc2Zvcm1TY2FsZTogdHJhbnNmb3JtU2NhbGUsXG4gICAgICByZXNpemVIYW5kbGVzOiByZXNpemVIYW5kbGVzLFxuICAgICAgaGFuZGxlOiByZXNpemVIYW5kbGVcbiAgICB9LCBjaGlsZCk7XG4gIH1cbiAgLyoqXG4gICAqIFdyYXBwZXIgYXJvdW5kIHJlc2l6ZSBldmVudHMgdG8gcHJvdmlkZSBtb3JlIHVzZWZ1bCBkYXRhLlxuICAgKi9cbiAgb25SZXNpemVIYW5kbGVyKGUgLyo6IEV2ZW50Ki8sIF9yZWY0IC8qOjogKi8sXG4gIC8vICdzaXplJyBpcyB1cGRhdGVkIHBvc2l0aW9uXG4gIHBvc2l0aW9uIC8qOiBQb3NpdGlvbiovLFxuICAvLyBleGlzdGluZyBwb3NpdGlvblxuICBoYW5kbGVyTmFtZSAvKjogc3RyaW5nKi8pIC8qOiB2b2lkKi97XG4gICAgbGV0IHtcbiAgICAgIG5vZGUsXG4gICAgICBzaXplLFxuICAgICAgaGFuZGxlXG4gICAgfSAvKjogUmVzaXplQ2FsbGJhY2tEYXRhKi8gPSBfcmVmNCAvKjogUmVzaXplQ2FsbGJhY2tEYXRhKi87XG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMucHJvcHNbaGFuZGxlck5hbWVdO1xuICAgIGlmICghaGFuZGxlcikgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaSxcbiAgICAgIG1heEgsXG4gICAgICBtaW5ILFxuICAgICAgY29udGFpbmVyV2lkdGhcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7XG4gICAgICBtaW5XLFxuICAgICAgbWF4V1xuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gQ2xhbXBpbmcgb2YgZGltZW5zaW9ucyBiYXNlZCBvbiByZXNpemUgZGlyZWN0aW9uXG4gICAgbGV0IHVwZGF0ZWRTaXplID0gc2l6ZTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgdXBkYXRlZFNpemUgPSAoMCwgX3V0aWxzLnJlc2l6ZUl0ZW1JbkRpcmVjdGlvbikoaGFuZGxlLCBwb3NpdGlvbiwgc2l6ZSwgY29udGFpbmVyV2lkdGgpO1xuICAgICAgKDAsIF9yZWFjdERvbS5mbHVzaFN5bmMpKCgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgcmVzaXppbmc6IGhhbmRsZXJOYW1lID09PSBcIm9uUmVzaXplU3RvcFwiID8gbnVsbCA6IHVwZGF0ZWRTaXplXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IG5ldyBYWSBiYXNlZCBvbiBwaXhlbCBzaXplXG4gICAgbGV0IHtcbiAgICAgIHcsXG4gICAgICBoXG4gICAgfSA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY1dIKSh0aGlzLmdldFBvc2l0aW9uUGFyYW1zKCksIHVwZGF0ZWRTaXplLndpZHRoLCB1cGRhdGVkU2l6ZS5oZWlnaHQsIHgsIHksIGhhbmRsZSk7XG5cbiAgICAvLyBNaW4vbWF4IGNhcHBpbmcuXG4gICAgLy8gbWluVyBzaG91bGQgYmUgYXQgbGVhc3QgMSAoVE9ETyBwcm9wVHlwZXMgdmFsaWRhdGlvbj8pXG4gICAgdyA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2xhbXApKHcsIE1hdGgubWF4KG1pblcsIDEpLCBtYXhXKTtcbiAgICBoID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jbGFtcCkoaCwgbWluSCwgbWF4SCk7XG4gICAgaGFuZGxlci5jYWxsKHRoaXMsIGksIHcsIGgsIHtcbiAgICAgIGUsXG4gICAgICBub2RlLFxuICAgICAgc2l6ZTogdXBkYXRlZFNpemUsXG4gICAgICBoYW5kbGVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSAvKjogUmVhY3ROb2RlKi97XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3LFxuICAgICAgaCxcbiAgICAgIGlzRHJhZ2dhYmxlLFxuICAgICAgaXNSZXNpemFibGUsXG4gICAgICBkcm9wcGluZ1Bvc2l0aW9uLFxuICAgICAgdXNlQ1NTVHJhbnNmb3Jtc1xuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHBvcyA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY0dyaWRJdGVtUG9zaXRpb24pKHRoaXMuZ2V0UG9zaXRpb25QYXJhbXMoKSwgeCwgeSwgdywgaCwgdGhpcy5zdGF0ZSk7XG4gICAgY29uc3QgY2hpbGQgPSBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBjaGlsZCBlbGVtZW50LiBXZSBjbG9uZSB0aGUgZXhpc3RpbmcgZWxlbWVudCBidXQgbW9kaWZ5IGl0cyBjbGFzc05hbWUgYW5kIHN0eWxlLlxuICAgIGxldCBuZXdDaGlsZCA9IC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgIHJlZjogdGhpcy5lbGVtZW50UmVmLFxuICAgICAgY2xhc3NOYW1lOiAoMCwgX2Nsc3guZGVmYXVsdCkoXCJyZWFjdC1ncmlkLWl0ZW1cIiwgY2hpbGQucHJvcHMuY2xhc3NOYW1lLCB0aGlzLnByb3BzLmNsYXNzTmFtZSwge1xuICAgICAgICBzdGF0aWM6IHRoaXMucHJvcHMuc3RhdGljLFxuICAgICAgICByZXNpemluZzogQm9vbGVhbih0aGlzLnN0YXRlLnJlc2l6aW5nKSxcbiAgICAgICAgXCJyZWFjdC1kcmFnZ2FibGVcIjogaXNEcmFnZ2FibGUsXG4gICAgICAgIFwicmVhY3QtZHJhZ2dhYmxlLWRyYWdnaW5nXCI6IEJvb2xlYW4odGhpcy5zdGF0ZS5kcmFnZ2luZyksXG4gICAgICAgIGRyb3BwaW5nOiBCb29sZWFuKGRyb3BwaW5nUG9zaXRpb24pLFxuICAgICAgICBjc3NUcmFuc2Zvcm1zOiB1c2VDU1NUcmFuc2Zvcm1zXG4gICAgICB9KSxcbiAgICAgIC8vIFdlIGNhbiBzZXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb24gdGhlIGNoaWxkLCBidXQgdW5mb3J0dW5hdGVseSB3ZSBjYW4ndCBzZXQgdGhlIHBvc2l0aW9uLlxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgLi4udGhpcy5wcm9wcy5zdHlsZSxcbiAgICAgICAgLi4uY2hpbGQucHJvcHMuc3R5bGUsXG4gICAgICAgIC4uLnRoaXMuY3JlYXRlU3R5bGUocG9zKVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVzaXphYmxlIHN1cHBvcnQuIFRoaXMgaXMgdXN1YWxseSBvbiBidXQgdGhlIHVzZXIgY2FuIHRvZ2dsZSBpdCBvZmYuXG4gICAgbmV3Q2hpbGQgPSB0aGlzLm1peGluUmVzaXphYmxlKG5ld0NoaWxkLCBwb3MsIGlzUmVzaXphYmxlKTtcblxuICAgIC8vIERyYWdnYWJsZSBzdXBwb3J0LiBUaGlzIGlzIGFsd2F5cyBvbiwgZXhjZXB0IGZvciB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICBuZXdDaGlsZCA9IHRoaXMubWl4aW5EcmFnZ2FibGUobmV3Q2hpbGQsIGlzRHJhZ2dhYmxlKTtcbiAgICByZXR1cm4gbmV3Q2hpbGQ7XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEdyaWRJdGVtO1xuX2RlZmluZVByb3BlcnR5KEdyaWRJdGVtLCBcInByb3BUeXBlc1wiLCB7XG4gIC8vIENoaWxkcmVuIG11c3QgYmUgb25seSBhIHNpbmdsZSBlbGVtZW50XG4gIGNoaWxkcmVuOiBfcHJvcFR5cGVzLmRlZmF1bHQuZWxlbWVudCxcbiAgLy8gR2VuZXJhbCBncmlkIGF0dHJpYnV0ZXNcbiAgY29sczogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkLFxuICBjb250YWluZXJXaWR0aDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkLFxuICByb3dIZWlnaHQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZCxcbiAgbWFyZ2luOiBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXkuaXNSZXF1aXJlZCxcbiAgbWF4Um93czogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkLFxuICBjb250YWluZXJQYWRkaW5nOiBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXkuaXNSZXF1aXJlZCxcbiAgLy8gVGhlc2UgYXJlIGFsbCBpbiBncmlkIHVuaXRzXG4gIHg6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZCxcbiAgeTogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkLFxuICB3OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGg6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLy8gQWxsIG9wdGlvbmFsXG4gIG1pblc6IGZ1bmN0aW9uIChwcm9wcyAvKjogUHJvcHMqLywgcHJvcE5hbWUgLyo6IHN0cmluZyovKSB7XG4gICAgY29uc3QgdmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikgcmV0dXJuIG5ldyBFcnJvcihcIm1pbldpZHRoIG5vdCBOdW1iZXJcIik7XG4gICAgaWYgKHZhbHVlID4gcHJvcHMudyB8fCB2YWx1ZSA+IHByb3BzLm1heFcpIHJldHVybiBuZXcgRXJyb3IoXCJtaW5XaWR0aCBsYXJnZXIgdGhhbiBpdGVtIHdpZHRoL21heFdpZHRoXCIpO1xuICB9LFxuICBtYXhXOiBmdW5jdGlvbiAocHJvcHMgLyo6IFByb3BzKi8sIHByb3BOYW1lIC8qOiBzdHJpbmcqLykge1xuICAgIGNvbnN0IHZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHJldHVybiBuZXcgRXJyb3IoXCJtYXhXaWR0aCBub3QgTnVtYmVyXCIpO1xuICAgIGlmICh2YWx1ZSA8IHByb3BzLncgfHwgdmFsdWUgPCBwcm9wcy5taW5XKSByZXR1cm4gbmV3IEVycm9yKFwibWF4V2lkdGggc21hbGxlciB0aGFuIGl0ZW0gd2lkdGgvbWluV2lkdGhcIik7XG4gIH0sXG4gIG1pbkg6IGZ1bmN0aW9uIChwcm9wcyAvKjogUHJvcHMqLywgcHJvcE5hbWUgLyo6IHN0cmluZyovKSB7XG4gICAgY29uc3QgdmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikgcmV0dXJuIG5ldyBFcnJvcihcIm1pbkhlaWdodCBub3QgTnVtYmVyXCIpO1xuICAgIGlmICh2YWx1ZSA+IHByb3BzLmggfHwgdmFsdWUgPiBwcm9wcy5tYXhIKSByZXR1cm4gbmV3IEVycm9yKFwibWluSGVpZ2h0IGxhcmdlciB0aGFuIGl0ZW0gaGVpZ2h0L21heEhlaWdodFwiKTtcbiAgfSxcbiAgbWF4SDogZnVuY3Rpb24gKHByb3BzIC8qOiBQcm9wcyovLCBwcm9wTmFtZSAvKjogc3RyaW5nKi8pIHtcbiAgICBjb25zdCB2YWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSByZXR1cm4gbmV3IEVycm9yKFwibWF4SGVpZ2h0IG5vdCBOdW1iZXJcIik7XG4gICAgaWYgKHZhbHVlIDwgcHJvcHMuaCB8fCB2YWx1ZSA8IHByb3BzLm1pbkgpIHJldHVybiBuZXcgRXJyb3IoXCJtYXhIZWlnaHQgc21hbGxlciB0aGFuIGl0ZW0gaGVpZ2h0L21pbkhlaWdodFwiKTtcbiAgfSxcbiAgLy8gSUQgaXMgbmljZSB0byBoYXZlIGZvciBjYWxsYmFja3NcbiAgaTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZy5pc1JlcXVpcmVkLFxuICAvLyBSZXNpemUgaGFuZGxlIG9wdGlvbnNcbiAgcmVzaXplSGFuZGxlczogX1JlYWN0R3JpZExheW91dFByb3BUeXBlcy5yZXNpemVIYW5kbGVBeGVzVHlwZSxcbiAgcmVzaXplSGFuZGxlOiBfUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzLnJlc2l6ZUhhbmRsZVR5cGUsXG4gIC8vIEZ1bmN0aW9uc1xuICBvbkRyYWdTdG9wOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgb25EcmFnU3RhcnQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICBvbkRyYWc6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICBvblJlc2l6ZVN0b3A6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICBvblJlc2l6ZVN0YXJ0OiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgb25SZXNpemU6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAvLyBGbGFnc1xuICBpc0RyYWdnYWJsZTogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wuaXNSZXF1aXJlZCxcbiAgaXNSZXNpemFibGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLmlzUmVxdWlyZWQsXG4gIGlzQm91bmRlZDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wuaXNSZXF1aXJlZCxcbiAgc3RhdGljOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLy8gVXNlIENTUyB0cmFuc2Zvcm1zIGluc3RlYWQgb2YgdG9wL2xlZnRcbiAgdXNlQ1NTVHJhbnNmb3JtczogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wuaXNSZXF1aXJlZCxcbiAgdHJhbnNmb3JtU2NhbGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gIC8vIE90aGVyc1xuICBjbGFzc05hbWU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIC8vIFNlbGVjdG9yIGZvciBkcmFnZ2FibGUgaGFuZGxlXG4gIGhhbmRsZTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgLy8gU2VsZWN0b3IgZm9yIGRyYWdnYWJsZSBjYW5jZWwgKHNlZSByZWFjdC1kcmFnZ2FibGUpXG4gIGNhbmNlbDogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgLy8gQ3VycmVudCBwb3NpdGlvbiBvZiBhIGRyb3BwaW5nIGVsZW1lbnRcbiAgZHJvcHBpbmdQb3NpdGlvbjogX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICBlOiBfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgbGVmdDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkLFxuICAgIHRvcDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkXG4gIH0pXG59KTtcbl9kZWZpbmVQcm9wZXJ0eShHcmlkSXRlbSwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBjbGFzc05hbWU6IFwiXCIsXG4gIGNhbmNlbDogXCJcIixcbiAgaGFuZGxlOiBcIlwiLFxuICBtaW5IOiAxLFxuICBtaW5XOiAxLFxuICBtYXhIOiBJbmZpbml0eSxcbiAgbWF4VzogSW5maW5pdHksXG4gIHRyYW5zZm9ybVNjYWxlOiAxXG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/react-grid-layout/build/GridItem.js\n");

/***/ }),

/***/ "../../node_modules/react-grid-layout/build/ReactGridLayout.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/react-grid-layout/build/ReactGridLayout.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\"));\nvar _fastEquals = __webpack_require__(/*! fast-equals */ \"../../node_modules/fast-equals/dist/fast-equals.js\");\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"../../node_modules/clsx/dist/clsx.js\"));\nvar _utils = __webpack_require__(/*! ./utils */ \"../../node_modules/react-grid-layout/build/utils.js\");\nvar _calculateUtils = __webpack_require__(/*! ./calculateUtils */ \"../../node_modules/react-grid-layout/build/calculateUtils.js\");\nvar _GridItem = _interopRequireDefault(__webpack_require__(/*! ./GridItem */ \"../../node_modules/react-grid-layout/build/GridItem.js\"));\nvar _ReactGridLayoutPropTypes = _interopRequireDefault(__webpack_require__(/*! ./ReactGridLayoutPropTypes */ \"../../node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*:: import type {\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n/*:: import type {\n  CompactType,\n  GridResizeEvent,\n  GridDragEvent,\n  DragOverEvent,\n  Layout,\n  DroppingPosition,\n  LayoutItem\n} from \"./utils\";*/\n// Types\n/*:: import type { PositionParams } from \"./calculateUtils\";*/\n/*:: type State = {\n  activeDrag: ?LayoutItem,\n  layout: Layout,\n  mounted: boolean,\n  oldDragItem: ?LayoutItem,\n  oldLayout: ?Layout,\n  oldResizeItem: ?LayoutItem,\n  resizing: boolean,\n  droppingDOMNode: ?ReactElement<any>,\n  droppingPosition?: DroppingPosition,\n  // Mirrored props\n  children: ReactChildrenArray<ReactElement<any>>,\n  compactType?: CompactType,\n  propsLayout?: Layout\n};*/\n/*:: import type { Props, DefaultProps } from \"./ReactGridLayoutPropTypes\";*/\n// End Types\nconst layoutClassName = \"react-grid-layout\";\nlet isFirefox = false;\n// Try...catch will protect from navigator not existing (e.g. node) or a bad implementation of navigator\ntry {\n  isFirefox = /firefox/i.test(navigator.userAgent);\n} catch (e) {\n  /* Ignore */\n}\n\n/**\n * A reactive, fluid grid layout with draggable, resizable components.\n */\n\nclass ReactGridLayout extends React.Component /*:: <Props, State>*/{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      activeDrag: null,\n      layout: (0, _utils.synchronizeLayoutWithChildren)(this.props.layout, this.props.children, this.props.cols,\n      // Legacy support for verticalCompact: false\n      (0, _utils.compactType)(this.props), this.props.allowOverlap),\n      mounted: false,\n      oldDragItem: null,\n      oldLayout: null,\n      oldResizeItem: null,\n      resizing: false,\n      droppingDOMNode: null,\n      children: []\n    });\n    _defineProperty(this, \"dragEnterCounter\", 0);\n    /**\n     * When dragging starts\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDragStart\", (i /*: string*/, x /*: number*/, y /*: number*/, _ref /*:: */) => {\n      let {\n        e,\n        node\n      } /*: GridDragEvent*/ = _ref /*: GridDragEvent*/;\n      const {\n        layout\n      } = this.state;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n\n      // Create placeholder (display only)\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        placeholder: true,\n        i: i\n      };\n      this.setState({\n        oldDragItem: (0, _utils.cloneLayoutItem)(l),\n        oldLayout: layout,\n        activeDrag: placeholder\n      });\n      return this.props.onDragStart(layout, l, l, null, e, node);\n    });\n    /**\n     * Each drag movement create a new dragelement and move the element to the dragged location\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDrag\", (i, x, y, _ref2) => {\n      let {\n        e,\n        node\n      } = _ref2;\n      const {\n        oldDragItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        allowOverlap,\n        preventCollision\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n\n      // Create placeholder (display only)\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        placeholder: true,\n        i: i\n      };\n\n      // Move the element to the dragged location.\n      const isUserAction = true;\n      layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n      this.props.onDrag(layout, oldDragItem, l, placeholder, e, node);\n      this.setState({\n        layout: allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols),\n        activeDrag: placeholder\n      });\n    });\n    /**\n     * When dragging stops, figure out which position the element is closest to and update its x and y.\n     * @param  {String} i Index of the child.\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDragStop\", (i, x, y, _ref3) => {\n      let {\n        e,\n        node\n      } = _ref3;\n      if (!this.state.activeDrag) return;\n      const {\n        oldDragItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        preventCollision,\n        allowOverlap\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n\n      // Move the element here\n      const isUserAction = true;\n      layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n\n      // Set state\n      const newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols);\n      this.props.onDragStop(newLayout, oldDragItem, l, null, e, node);\n      const {\n        oldLayout\n      } = this.state;\n      this.setState({\n        activeDrag: null,\n        layout: newLayout,\n        oldDragItem: null,\n        oldLayout: null\n      });\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    });\n    _defineProperty(this, \"onResizeStart\", (i, w, h, _ref4) => {\n      let {\n        e,\n        node\n      } = _ref4;\n      const {\n        layout\n      } = this.state;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n      this.setState({\n        oldResizeItem: (0, _utils.cloneLayoutItem)(l),\n        oldLayout: this.state.layout,\n        resizing: true\n      });\n      this.props.onResizeStart(layout, l, l, null, e, node);\n    });\n    _defineProperty(this, \"onResize\", (i, w, h, _ref5) => {\n      let {\n        e,\n        node,\n        size,\n        handle\n      } = _ref5;\n      const {\n        oldResizeItem\n      } = this.state;\n      const {\n        layout\n      } = this.state;\n      const {\n        cols,\n        preventCollision,\n        allowOverlap\n      } = this.props;\n      let shouldMoveItem = false;\n      let finalLayout;\n      let x;\n      let y;\n      const [newLayout, l] = (0, _utils.withLayoutItem)(layout, i, l => {\n        let hasCollisions;\n        x = l.x;\n        y = l.y;\n        if ([\"sw\", \"w\", \"nw\", \"n\", \"ne\"].indexOf(handle) !== -1) {\n          if ([\"sw\", \"nw\", \"w\"].indexOf(handle) !== -1) {\n            x = l.x + (l.w - w);\n            w = l.x !== x && x < 0 ? l.w : w;\n            x = x < 0 ? 0 : x;\n          }\n          if ([\"ne\", \"n\", \"nw\"].indexOf(handle) !== -1) {\n            y = l.y + (l.h - h);\n            h = l.y !== y && y < 0 ? l.h : h;\n            y = y < 0 ? 0 : y;\n          }\n          shouldMoveItem = true;\n        }\n\n        // Something like quad tree should be used\n        // to find collisions faster\n        if (preventCollision && !allowOverlap) {\n          const collisions = (0, _utils.getAllCollisions)(layout, {\n            ...l,\n            w,\n            h,\n            x,\n            y\n          }).filter(layoutItem => layoutItem.i !== l.i);\n          hasCollisions = collisions.length > 0;\n\n          // If we're colliding, we need adjust the placeholder.\n          if (hasCollisions) {\n            // Reset layoutItem dimensions if there were collisions\n            y = l.y;\n            h = l.h;\n            x = l.x;\n            w = l.w;\n            shouldMoveItem = false;\n          }\n        }\n        l.w = w;\n        l.h = h;\n        return l;\n      });\n\n      // Shouldn't ever happen, but typechecking makes it necessary\n      if (!l) return;\n      finalLayout = newLayout;\n      if (shouldMoveItem) {\n        // Move the element to the new position.\n        const isUserAction = true;\n        finalLayout = (0, _utils.moveElement)(newLayout, l, x, y, isUserAction, this.props.preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n      }\n\n      // Create placeholder element (display only)\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        static: true,\n        i: i\n      };\n      this.props.onResize(finalLayout, oldResizeItem, l, placeholder, e, node);\n\n      // Re-compact the newLayout and set the drag placeholder.\n      this.setState({\n        layout: allowOverlap ? finalLayout : (0, _utils.compact)(finalLayout, (0, _utils.compactType)(this.props), cols),\n        activeDrag: placeholder\n      });\n    });\n    _defineProperty(this, \"onResizeStop\", (i, w, h, _ref6) => {\n      let {\n        e,\n        node\n      } = _ref6;\n      const {\n        layout,\n        oldResizeItem\n      } = this.state;\n      const {\n        cols,\n        allowOverlap\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n\n      // Set state\n      const newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols);\n      this.props.onResizeStop(newLayout, oldResizeItem, l, null, e, node);\n      const {\n        oldLayout\n      } = this.state;\n      this.setState({\n        activeDrag: null,\n        layout: newLayout,\n        oldResizeItem: null,\n        oldLayout: null,\n        resizing: false\n      });\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    });\n    // Called while dragging an element. Part of browser native drag/drop API.\n    // Native event target might be the layout itself, or an element within the layout.\n    _defineProperty(this, \"onDragOver\", e => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n\n      // we should ignore events from layout's children in Firefox\n      // to avoid unpredictable jumping of a dropping placeholder\n      // FIXME remove this hack\n      if (isFirefox &&\n      // $FlowIgnore can't figure this out\n      !e.nativeEvent.target?.classList.contains(layoutClassName)) {\n        return false;\n      }\n      const {\n        droppingItem,\n        onDropDragOver,\n        margin,\n        cols,\n        rowHeight,\n        maxRows,\n        width,\n        containerPadding,\n        transformScale\n      } = this.props;\n      // Allow user to customize the dropping item or short-circuit the drop based on the results\n      // of the `onDragOver(e: Event)` callback.\n      const onDragOverResult = onDropDragOver?.(e);\n      if (onDragOverResult === false) {\n        if (this.state.droppingDOMNode) {\n          this.removeDroppingPlaceholder();\n        }\n        return false;\n      }\n      const finalDroppingItem = {\n        ...droppingItem,\n        ...onDragOverResult\n      };\n      const {\n        layout\n      } = this.state;\n\n      // $FlowIgnore missing def\n      const gridRect = e.currentTarget.getBoundingClientRect(); // The grid's position in the viewport\n\n      // Calculate the mouse position relative to the grid\n      const layerX = e.clientX - gridRect.left;\n      const layerY = e.clientY - gridRect.top;\n      const droppingPosition = {\n        left: layerX / transformScale,\n        top: layerY / transformScale,\n        e\n      };\n      if (!this.state.droppingDOMNode) {\n        const positionParams /*: PositionParams*/ = {\n          cols,\n          margin,\n          maxRows,\n          rowHeight,\n          containerWidth: width,\n          containerPadding: containerPadding || margin\n        };\n        const calculatedPosition = (0, _calculateUtils.calcXY)(positionParams, layerY, layerX, finalDroppingItem.w, finalDroppingItem.h);\n        this.setState({\n          droppingDOMNode: /*#__PURE__*/React.createElement(\"div\", {\n            key: finalDroppingItem.i\n          }),\n          droppingPosition,\n          layout: [...layout, {\n            ...finalDroppingItem,\n            x: calculatedPosition.x,\n            y: calculatedPosition.y,\n            static: false,\n            isDraggable: true\n          }]\n        });\n      } else if (this.state.droppingPosition) {\n        const {\n          left,\n          top\n        } = this.state.droppingPosition;\n        const shouldUpdatePosition = left != layerX || top != layerY;\n        if (shouldUpdatePosition) {\n          this.setState({\n            droppingPosition\n          });\n        }\n      }\n    });\n    _defineProperty(this, \"removeDroppingPlaceholder\", () => {\n      const {\n        droppingItem,\n        cols\n      } = this.props;\n      const {\n        layout\n      } = this.state;\n      const newLayout = (0, _utils.compact)(layout.filter(l => l.i !== droppingItem.i), (0, _utils.compactType)(this.props), cols, this.props.allowOverlap);\n      this.setState({\n        layout: newLayout,\n        droppingDOMNode: null,\n        activeDrag: null,\n        droppingPosition: undefined\n      });\n    });\n    _defineProperty(this, \"onDragLeave\", e => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      this.dragEnterCounter--;\n\n      // onDragLeave can be triggered on each layout's child.\n      // But we know that count of dragEnter and dragLeave events\n      // will be balanced after leaving the layout's container\n      // so we can increase and decrease count of dragEnter and\n      // when it'll be equal to 0 we'll remove the placeholder\n      if (this.dragEnterCounter === 0) {\n        this.removeDroppingPlaceholder();\n      }\n    });\n    _defineProperty(this, \"onDragEnter\", e => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      this.dragEnterCounter++;\n    });\n    _defineProperty(this, \"onDrop\", (e /*: Event*/) => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      const {\n        droppingItem\n      } = this.props;\n      const {\n        layout\n      } = this.state;\n      const item = layout.find(l => l.i === droppingItem.i);\n\n      // reset dragEnter counter on drop\n      this.dragEnterCounter = 0;\n      this.removeDroppingPlaceholder();\n      this.props.onDrop(layout, item, e);\n    });\n  }\n  componentDidMount() {\n    this.setState({\n      mounted: true\n    });\n    // Possibly call back with layout on mount. This should be done after correcting the layout width\n    // to ensure we don't rerender with the wrong width.\n    this.onLayoutMaybeChanged(this.state.layout, this.props.layout);\n  }\n  static getDerivedStateFromProps(nextProps /*: Props*/, prevState /*: State*/) /*: $Shape<State> | null*/{\n    let newLayoutBase;\n    if (prevState.activeDrag) {\n      return null;\n    }\n\n    // Legacy support for compactType\n    // Allow parent to set layout directly.\n    if (!(0, _fastEquals.deepEqual)(nextProps.layout, prevState.propsLayout) || nextProps.compactType !== prevState.compactType) {\n      newLayoutBase = nextProps.layout;\n    } else if (!(0, _utils.childrenEqual)(nextProps.children, prevState.children)) {\n      // If children change, also regenerate the layout. Use our state\n      // as the base in case because it may be more up to date than\n      // what is in props.\n      newLayoutBase = prevState.layout;\n    }\n\n    // We need to regenerate the layout.\n    if (newLayoutBase) {\n      const newLayout = (0, _utils.synchronizeLayoutWithChildren)(newLayoutBase, nextProps.children, nextProps.cols, (0, _utils.compactType)(nextProps), nextProps.allowOverlap);\n      return {\n        layout: newLayout,\n        // We need to save these props to state for using\n        // getDerivedStateFromProps instead of componentDidMount (in which we would get extra rerender)\n        compactType: nextProps.compactType,\n        children: nextProps.children,\n        propsLayout: nextProps.layout\n      };\n    }\n    return null;\n  }\n  shouldComponentUpdate(nextProps /*: Props*/, nextState /*: State*/) /*: boolean*/{\n    return (\n      // NOTE: this is almost always unequal. Therefore the only way to get better performance\n      // from SCU is if the user intentionally memoizes children. If they do, and they can\n      // handle changes properly, performance will increase.\n      this.props.children !== nextProps.children || !(0, _utils.fastRGLPropsEqual)(this.props, nextProps, _fastEquals.deepEqual) || this.state.activeDrag !== nextState.activeDrag || this.state.mounted !== nextState.mounted || this.state.droppingPosition !== nextState.droppingPosition\n    );\n  }\n  componentDidUpdate(prevProps /*: Props*/, prevState /*: State*/) {\n    if (!this.state.activeDrag) {\n      const newLayout = this.state.layout;\n      const oldLayout = prevState.layout;\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    }\n  }\n\n  /**\n   * Calculates a pixel value for the container.\n   * @return {String} Container height in pixels.\n   */\n  containerHeight() /*: ?string*/{\n    if (!this.props.autoSize) return;\n    const nbRow = (0, _utils.bottom)(this.state.layout);\n    const containerPaddingY = this.props.containerPadding ? this.props.containerPadding[1] : this.props.margin[1];\n    return nbRow * this.props.rowHeight + (nbRow - 1) * this.props.margin[1] + containerPaddingY * 2 + \"px\";\n  }\n  onLayoutMaybeChanged(newLayout /*: Layout*/, oldLayout /*: ?Layout*/) {\n    if (!oldLayout) oldLayout = this.state.layout;\n    if (!(0, _fastEquals.deepEqual)(oldLayout, newLayout)) {\n      this.props.onLayoutChange(newLayout);\n    }\n  }\n  /**\n   * Create a placeholder object.\n   * @return {Element} Placeholder div.\n   */\n  placeholder() /*: ?ReactElement<any>*/{\n    const {\n      activeDrag\n    } = this.state;\n    if (!activeDrag) return null;\n    const {\n      width,\n      cols,\n      margin,\n      containerPadding,\n      rowHeight,\n      maxRows,\n      useCSSTransforms,\n      transformScale\n    } = this.props;\n\n    // {...this.state.activeDrag} is pretty slow, actually\n    return /*#__PURE__*/React.createElement(_GridItem.default, {\n      w: activeDrag.w,\n      h: activeDrag.h,\n      x: activeDrag.x,\n      y: activeDrag.y,\n      i: activeDrag.i,\n      className: `react-grid-placeholder ${this.state.resizing ? \"placeholder-resizing\" : \"\"}`,\n      containerWidth: width,\n      cols: cols,\n      margin: margin,\n      containerPadding: containerPadding || margin,\n      maxRows: maxRows,\n      rowHeight: rowHeight,\n      isDraggable: false,\n      isResizable: false,\n      isBounded: false,\n      useCSSTransforms: useCSSTransforms,\n      transformScale: transformScale\n    }, /*#__PURE__*/React.createElement(\"div\", null));\n  }\n\n  /**\n   * Given a grid item, set its style attributes & surround in a <Draggable>.\n   * @param  {Element} child React element.\n   * @return {Element}       Element wrapped in draggable and properly placed.\n   */\n  processGridItem(child /*: ReactElement<any>*/, isDroppingItem /*: boolean*/) /*: ?ReactElement<any>*/{\n    if (!child || !child.key) return;\n    const l = (0, _utils.getLayoutItem)(this.state.layout, String(child.key));\n    if (!l) return null;\n    const {\n      width,\n      cols,\n      margin,\n      containerPadding,\n      rowHeight,\n      maxRows,\n      isDraggable,\n      isResizable,\n      isBounded,\n      useCSSTransforms,\n      transformScale,\n      draggableCancel,\n      draggableHandle,\n      resizeHandles,\n      resizeHandle\n    } = this.props;\n    const {\n      mounted,\n      droppingPosition\n    } = this.state;\n\n    // Determine user manipulations possible.\n    // If an item is static, it can't be manipulated by default.\n    // Any properties defined directly on the grid item will take precedence.\n    const draggable = typeof l.isDraggable === \"boolean\" ? l.isDraggable : !l.static && isDraggable;\n    const resizable = typeof l.isResizable === \"boolean\" ? l.isResizable : !l.static && isResizable;\n    const resizeHandlesOptions = l.resizeHandles || resizeHandles;\n\n    // isBounded set on child if set on parent, and child is not explicitly false\n    const bounded = draggable && isBounded && l.isBounded !== false;\n    return /*#__PURE__*/React.createElement(_GridItem.default, {\n      containerWidth: width,\n      cols: cols,\n      margin: margin,\n      containerPadding: containerPadding || margin,\n      maxRows: maxRows,\n      rowHeight: rowHeight,\n      cancel: draggableCancel,\n      handle: draggableHandle,\n      onDragStop: this.onDragStop,\n      onDragStart: this.onDragStart,\n      onDrag: this.onDrag,\n      onResizeStart: this.onResizeStart,\n      onResize: this.onResize,\n      onResizeStop: this.onResizeStop,\n      isDraggable: draggable,\n      isResizable: resizable,\n      isBounded: bounded,\n      useCSSTransforms: useCSSTransforms && mounted,\n      usePercentages: !mounted,\n      transformScale: transformScale,\n      w: l.w,\n      h: l.h,\n      x: l.x,\n      y: l.y,\n      i: l.i,\n      minH: l.minH,\n      minW: l.minW,\n      maxH: l.maxH,\n      maxW: l.maxW,\n      static: l.static,\n      droppingPosition: isDroppingItem ? droppingPosition : undefined,\n      resizeHandles: resizeHandlesOptions,\n      resizeHandle: resizeHandle\n    }, child);\n  }\n  render() /*: React.Element<\"div\">*/{\n    const {\n      className,\n      style,\n      isDroppable,\n      innerRef\n    } = this.props;\n    const mergedClassName = (0, _clsx.default)(layoutClassName, className);\n    const mergedStyle = {\n      height: this.containerHeight(),\n      ...style\n    };\n    return /*#__PURE__*/React.createElement(\"div\", {\n      ref: innerRef,\n      className: mergedClassName,\n      style: mergedStyle,\n      onDrop: isDroppable ? this.onDrop : _utils.noop,\n      onDragLeave: isDroppable ? this.onDragLeave : _utils.noop,\n      onDragEnter: isDroppable ? this.onDragEnter : _utils.noop,\n      onDragOver: isDroppable ? this.onDragOver : _utils.noop\n    }, React.Children.map(this.props.children, child => this.processGridItem(child)), isDroppable && this.state.droppingDOMNode && this.processGridItem(this.state.droppingDOMNode, true), this.placeholder());\n  }\n}\nexports[\"default\"] = ReactGridLayout;\n// TODO publish internal ReactClass displayName transform\n_defineProperty(ReactGridLayout, \"displayName\", \"ReactGridLayout\");\n// Refactored to another module to make way for preval\n_defineProperty(ReactGridLayout, \"propTypes\", _ReactGridLayoutPropTypes.default);\n_defineProperty(ReactGridLayout, \"defaultProps\", {\n  autoSize: true,\n  cols: 12,\n  className: \"\",\n  style: {},\n  draggableHandle: \"\",\n  draggableCancel: \"\",\n  containerPadding: null,\n  rowHeight: 150,\n  maxRows: Infinity,\n  // infinite vertical growth\n  layout: [],\n  margin: [10, 10],\n  isBounded: false,\n  isDraggable: true,\n  isResizable: true,\n  allowOverlap: false,\n  isDroppable: false,\n  useCSSTransforms: true,\n  transformScale: 1,\n  verticalCompact: true,\n  compactType: \"vertical\",\n  preventCollision: false,\n  droppingItem: {\n    i: \"__dropping-elem__\",\n    h: 1,\n    w: 1\n  },\n  resizeHandles: [\"se\"],\n  onLayoutChange: _utils.noop,\n  onDragStart: _utils.noop,\n  onDrag: _utils.noop,\n  onDragStop: _utils.noop,\n  onResizeStart: _utils.noop,\n  onResize: _utils.noop,\n  onResizeStop: _utils.noop,\n  onDrop: _utils.noop,\n  onDropDragOver: _utils.noop\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL1JlYWN0R3JpZExheW91dC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL1JlYWN0R3JpZExheW91dC5qcz85MTMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIFJlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfZmFzdEVxdWFscyA9IHJlcXVpcmUoXCJmYXN0LWVxdWFsc1wiKTtcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIF9jYWxjdWxhdGVVdGlscyA9IHJlcXVpcmUoXCIuL2NhbGN1bGF0ZVV0aWxzXCIpO1xudmFyIF9HcmlkSXRlbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vR3JpZEl0ZW1cIikpO1xudmFyIF9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1JlYWN0R3JpZExheW91dFByb3BUeXBlc1wiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSB0eXBlb2YgZSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IGRlZmF1bHQ6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuLmRlZmF1bHQgPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG4vKjo6IGltcG9ydCB0eXBlIHtcbiAgQ2hpbGRyZW5BcnJheSBhcyBSZWFjdENoaWxkcmVuQXJyYXksXG4gIEVsZW1lbnQgYXMgUmVhY3RFbGVtZW50XG59IGZyb20gXCJyZWFjdFwiOyovXG4vKjo6IGltcG9ydCB0eXBlIHtcbiAgQ29tcGFjdFR5cGUsXG4gIEdyaWRSZXNpemVFdmVudCxcbiAgR3JpZERyYWdFdmVudCxcbiAgRHJhZ092ZXJFdmVudCxcbiAgTGF5b3V0LFxuICBEcm9wcGluZ1Bvc2l0aW9uLFxuICBMYXlvdXRJdGVtXG59IGZyb20gXCIuL3V0aWxzXCI7Ki9cbi8vIFR5cGVzXG4vKjo6IGltcG9ydCB0eXBlIHsgUG9zaXRpb25QYXJhbXMgfSBmcm9tIFwiLi9jYWxjdWxhdGVVdGlsc1wiOyovXG4vKjo6IHR5cGUgU3RhdGUgPSB7XG4gIGFjdGl2ZURyYWc6ID9MYXlvdXRJdGVtLFxuICBsYXlvdXQ6IExheW91dCxcbiAgbW91bnRlZDogYm9vbGVhbixcbiAgb2xkRHJhZ0l0ZW06ID9MYXlvdXRJdGVtLFxuICBvbGRMYXlvdXQ6ID9MYXlvdXQsXG4gIG9sZFJlc2l6ZUl0ZW06ID9MYXlvdXRJdGVtLFxuICByZXNpemluZzogYm9vbGVhbixcbiAgZHJvcHBpbmdET01Ob2RlOiA/UmVhY3RFbGVtZW50PGFueT4sXG4gIGRyb3BwaW5nUG9zaXRpb24/OiBEcm9wcGluZ1Bvc2l0aW9uLFxuICAvLyBNaXJyb3JlZCBwcm9wc1xuICBjaGlsZHJlbjogUmVhY3RDaGlsZHJlbkFycmF5PFJlYWN0RWxlbWVudDxhbnk+PixcbiAgY29tcGFjdFR5cGU/OiBDb21wYWN0VHlwZSxcbiAgcHJvcHNMYXlvdXQ/OiBMYXlvdXRcbn07Ki9cbi8qOjogaW1wb3J0IHR5cGUgeyBQcm9wcywgRGVmYXVsdFByb3BzIH0gZnJvbSBcIi4vUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzXCI7Ki9cbi8vIEVuZCBUeXBlc1xuY29uc3QgbGF5b3V0Q2xhc3NOYW1lID0gXCJyZWFjdC1ncmlkLWxheW91dFwiO1xubGV0IGlzRmlyZWZveCA9IGZhbHNlO1xuLy8gVHJ5Li4uY2F0Y2ggd2lsbCBwcm90ZWN0IGZyb20gbmF2aWdhdG9yIG5vdCBleGlzdGluZyAoZS5nLiBub2RlKSBvciBhIGJhZCBpbXBsZW1lbnRhdGlvbiBvZiBuYXZpZ2F0b3JcbnRyeSB7XG4gIGlzRmlyZWZveCA9IC9maXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn0gY2F0Y2ggKGUpIHtcbiAgLyogSWdub3JlICovXG59XG5cbi8qKlxuICogQSByZWFjdGl2ZSwgZmx1aWQgZ3JpZCBsYXlvdXQgd2l0aCBkcmFnZ2FibGUsIHJlc2l6YWJsZSBjb21wb25lbnRzLlxuICovXG5cbmNsYXNzIFJlYWN0R3JpZExheW91dCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCAvKjo6IDxQcm9wcywgU3RhdGU+Ki97XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwge1xuICAgICAgYWN0aXZlRHJhZzogbnVsbCxcbiAgICAgIGxheW91dDogKDAsIF91dGlscy5zeW5jaHJvbml6ZUxheW91dFdpdGhDaGlsZHJlbikodGhpcy5wcm9wcy5sYXlvdXQsIHRoaXMucHJvcHMuY2hpbGRyZW4sIHRoaXMucHJvcHMuY29scyxcbiAgICAgIC8vIExlZ2FjeSBzdXBwb3J0IGZvciB2ZXJ0aWNhbENvbXBhY3Q6IGZhbHNlXG4gICAgICAoMCwgX3V0aWxzLmNvbXBhY3RUeXBlKSh0aGlzLnByb3BzKSwgdGhpcy5wcm9wcy5hbGxvd092ZXJsYXApLFxuICAgICAgbW91bnRlZDogZmFsc2UsXG4gICAgICBvbGREcmFnSXRlbTogbnVsbCxcbiAgICAgIG9sZExheW91dDogbnVsbCxcbiAgICAgIG9sZFJlc2l6ZUl0ZW06IG51bGwsXG4gICAgICByZXNpemluZzogZmFsc2UsXG4gICAgICBkcm9wcGluZ0RPTU5vZGU6IG51bGwsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkcmFnRW50ZXJDb3VudGVyXCIsIDApO1xuICAgIC8qKlxuICAgICAqIFdoZW4gZHJhZ2dpbmcgc3RhcnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGkgSWQgb2YgdGhlIGNoaWxkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggWCBwb3NpdGlvbiBvZiB0aGUgbW92ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgcG9zaXRpb24gb2YgdGhlIG1vdmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgVGhlIGN1cnJlbnQgZHJhZ2dpbmcgRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdTdGFydFwiLCAoaSAvKjogc3RyaW5nKi8sIHggLyo6IG51bWJlciovLCB5IC8qOiBudW1iZXIqLywgX3JlZiAvKjo6ICovKSA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBlLFxuICAgICAgICBub2RlXG4gICAgICB9IC8qOiBHcmlkRHJhZ0V2ZW50Ki8gPSBfcmVmIC8qOiBHcmlkRHJhZ0V2ZW50Ki87XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxheW91dFxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBsID0gKDAsIF91dGlscy5nZXRMYXlvdXRJdGVtKShsYXlvdXQsIGkpO1xuICAgICAgaWYgKCFsKSByZXR1cm47XG5cbiAgICAgIC8vIENyZWF0ZSBwbGFjZWhvbGRlciAoZGlzcGxheSBvbmx5KVxuICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB7XG4gICAgICAgIHc6IGwudyxcbiAgICAgICAgaDogbC5oLFxuICAgICAgICB4OiBsLngsXG4gICAgICAgIHk6IGwueSxcbiAgICAgICAgcGxhY2Vob2xkZXI6IHRydWUsXG4gICAgICAgIGk6IGlcbiAgICAgIH07XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgb2xkRHJhZ0l0ZW06ICgwLCBfdXRpbHMuY2xvbmVMYXlvdXRJdGVtKShsKSxcbiAgICAgICAgb2xkTGF5b3V0OiBsYXlvdXQsXG4gICAgICAgIGFjdGl2ZURyYWc6IHBsYWNlaG9sZGVyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLm9uRHJhZ1N0YXJ0KGxheW91dCwgbCwgbCwgbnVsbCwgZSwgbm9kZSk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRWFjaCBkcmFnIG1vdmVtZW50IGNyZWF0ZSBhIG5ldyBkcmFnZWxlbWVudCBhbmQgbW92ZSB0aGUgZWxlbWVudCB0byB0aGUgZHJhZ2dlZCBsb2NhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpIElkIG9mIHRoZSBjaGlsZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFggcG9zaXRpb24gb2YgdGhlIG1vdmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBZIHBvc2l0aW9uIG9mIHRoZSBtb3ZlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBUaGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIFRoZSBjdXJyZW50IGRyYWdnaW5nIERPTSBlbGVtZW50XG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25EcmFnXCIsIChpLCB4LCB5LCBfcmVmMikgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgZSxcbiAgICAgICAgbm9kZVxuICAgICAgfSA9IF9yZWYyO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvbGREcmFnSXRlbVxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBsZXQge1xuICAgICAgICBsYXlvdXRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb2xzLFxuICAgICAgICBhbGxvd092ZXJsYXAsXG4gICAgICAgIHByZXZlbnRDb2xsaXNpb25cbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgbCA9ICgwLCBfdXRpbHMuZ2V0TGF5b3V0SXRlbSkobGF5b3V0LCBpKTtcbiAgICAgIGlmICghbCkgcmV0dXJuO1xuXG4gICAgICAvLyBDcmVhdGUgcGxhY2Vob2xkZXIgKGRpc3BsYXkgb25seSlcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0ge1xuICAgICAgICB3OiBsLncsXG4gICAgICAgIGg6IGwuaCxcbiAgICAgICAgeDogbC54LFxuICAgICAgICB5OiBsLnksXG4gICAgICAgIHBsYWNlaG9sZGVyOiB0cnVlLFxuICAgICAgICBpOiBpXG4gICAgICB9O1xuXG4gICAgICAvLyBNb3ZlIHRoZSBlbGVtZW50IHRvIHRoZSBkcmFnZ2VkIGxvY2F0aW9uLlxuICAgICAgY29uc3QgaXNVc2VyQWN0aW9uID0gdHJ1ZTtcbiAgICAgIGxheW91dCA9ICgwLCBfdXRpbHMubW92ZUVsZW1lbnQpKGxheW91dCwgbCwgeCwgeSwgaXNVc2VyQWN0aW9uLCBwcmV2ZW50Q29sbGlzaW9uLCAoMCwgX3V0aWxzLmNvbXBhY3RUeXBlKSh0aGlzLnByb3BzKSwgY29scywgYWxsb3dPdmVybGFwKTtcbiAgICAgIHRoaXMucHJvcHMub25EcmFnKGxheW91dCwgb2xkRHJhZ0l0ZW0sIGwsIHBsYWNlaG9sZGVyLCBlLCBub2RlKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBsYXlvdXQ6IGFsbG93T3ZlcmxhcCA/IGxheW91dCA6ICgwLCBfdXRpbHMuY29tcGFjdCkobGF5b3V0LCAoMCwgX3V0aWxzLmNvbXBhY3RUeXBlKSh0aGlzLnByb3BzKSwgY29scyksXG4gICAgICAgIGFjdGl2ZURyYWc6IHBsYWNlaG9sZGVyXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBXaGVuIGRyYWdnaW5nIHN0b3BzLCBmaWd1cmUgb3V0IHdoaWNoIHBvc2l0aW9uIHRoZSBlbGVtZW50IGlzIGNsb3Nlc3QgdG8gYW5kIHVwZGF0ZSBpdHMgeCBhbmQgeS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGkgSW5kZXggb2YgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFggcG9zaXRpb24gb2YgdGhlIG1vdmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBZIHBvc2l0aW9uIG9mIHRoZSBtb3ZlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBUaGUgbW91c2Vkb3duIGV2ZW50XG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIFRoZSBjdXJyZW50IGRyYWdnaW5nIERPTSBlbGVtZW50XG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25EcmFnU3RvcFwiLCAoaSwgeCwgeSwgX3JlZjMpID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGUsXG4gICAgICAgIG5vZGVcbiAgICAgIH0gPSBfcmVmMztcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5hY3RpdmVEcmFnKSByZXR1cm47XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9sZERyYWdJdGVtXG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGxldCB7XG4gICAgICAgIGxheW91dFxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbHMsXG4gICAgICAgIHByZXZlbnRDb2xsaXNpb24sXG4gICAgICAgIGFsbG93T3ZlcmxhcFxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCBsID0gKDAsIF91dGlscy5nZXRMYXlvdXRJdGVtKShsYXlvdXQsIGkpO1xuICAgICAgaWYgKCFsKSByZXR1cm47XG5cbiAgICAgIC8vIE1vdmUgdGhlIGVsZW1lbnQgaGVyZVxuICAgICAgY29uc3QgaXNVc2VyQWN0aW9uID0gdHJ1ZTtcbiAgICAgIGxheW91dCA9ICgwLCBfdXRpbHMubW92ZUVsZW1lbnQpKGxheW91dCwgbCwgeCwgeSwgaXNVc2VyQWN0aW9uLCBwcmV2ZW50Q29sbGlzaW9uLCAoMCwgX3V0aWxzLmNvbXBhY3RUeXBlKSh0aGlzLnByb3BzKSwgY29scywgYWxsb3dPdmVybGFwKTtcblxuICAgICAgLy8gU2V0IHN0YXRlXG4gICAgICBjb25zdCBuZXdMYXlvdXQgPSBhbGxvd092ZXJsYXAgPyBsYXlvdXQgOiAoMCwgX3V0aWxzLmNvbXBhY3QpKGxheW91dCwgKDAsIF91dGlscy5jb21wYWN0VHlwZSkodGhpcy5wcm9wcyksIGNvbHMpO1xuICAgICAgdGhpcy5wcm9wcy5vbkRyYWdTdG9wKG5ld0xheW91dCwgb2xkRHJhZ0l0ZW0sIGwsIG51bGwsIGUsIG5vZGUpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvbGRMYXlvdXRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGFjdGl2ZURyYWc6IG51bGwsXG4gICAgICAgIGxheW91dDogbmV3TGF5b3V0LFxuICAgICAgICBvbGREcmFnSXRlbTogbnVsbCxcbiAgICAgICAgb2xkTGF5b3V0OiBudWxsXG4gICAgICB9KTtcbiAgICAgIHRoaXMub25MYXlvdXRNYXliZUNoYW5nZWQobmV3TGF5b3V0LCBvbGRMYXlvdXQpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uUmVzaXplU3RhcnRcIiwgKGksIHcsIGgsIF9yZWY0KSA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBlLFxuICAgICAgICBub2RlXG4gICAgICB9ID0gX3JlZjQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxheW91dFxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBsID0gKDAsIF91dGlscy5nZXRMYXlvdXRJdGVtKShsYXlvdXQsIGkpO1xuICAgICAgaWYgKCFsKSByZXR1cm47XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgb2xkUmVzaXplSXRlbTogKDAsIF91dGlscy5jbG9uZUxheW91dEl0ZW0pKGwpLFxuICAgICAgICBvbGRMYXlvdXQ6IHRoaXMuc3RhdGUubGF5b3V0LFxuICAgICAgICByZXNpemluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLnByb3BzLm9uUmVzaXplU3RhcnQobGF5b3V0LCBsLCBsLCBudWxsLCBlLCBub2RlKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvblJlc2l6ZVwiLCAoaSwgdywgaCwgX3JlZjUpID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGUsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIHNpemUsXG4gICAgICAgIGhhbmRsZVxuICAgICAgfSA9IF9yZWY1O1xuICAgICAgY29uc3Qge1xuICAgICAgICBvbGRSZXNpemVJdGVtXG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGF5b3V0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29scyxcbiAgICAgICAgcHJldmVudENvbGxpc2lvbixcbiAgICAgICAgYWxsb3dPdmVybGFwXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGxldCBzaG91bGRNb3ZlSXRlbSA9IGZhbHNlO1xuICAgICAgbGV0IGZpbmFsTGF5b3V0O1xuICAgICAgbGV0IHg7XG4gICAgICBsZXQgeTtcbiAgICAgIGNvbnN0IFtuZXdMYXlvdXQsIGxdID0gKDAsIF91dGlscy53aXRoTGF5b3V0SXRlbSkobGF5b3V0LCBpLCBsID0+IHtcbiAgICAgICAgbGV0IGhhc0NvbGxpc2lvbnM7XG4gICAgICAgIHggPSBsLng7XG4gICAgICAgIHkgPSBsLnk7XG4gICAgICAgIGlmIChbXCJzd1wiLCBcIndcIiwgXCJud1wiLCBcIm5cIiwgXCJuZVwiXS5pbmRleE9mKGhhbmRsZSkgIT09IC0xKSB7XG4gICAgICAgICAgaWYgKFtcInN3XCIsIFwibndcIiwgXCJ3XCJdLmluZGV4T2YoaGFuZGxlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHggPSBsLnggKyAobC53IC0gdyk7XG4gICAgICAgICAgICB3ID0gbC54ICE9PSB4ICYmIHggPCAwID8gbC53IDogdztcbiAgICAgICAgICAgIHggPSB4IDwgMCA/IDAgOiB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoW1wibmVcIiwgXCJuXCIsIFwibndcIl0uaW5kZXhPZihoYW5kbGUpICE9PSAtMSkge1xuICAgICAgICAgICAgeSA9IGwueSArIChsLmggLSBoKTtcbiAgICAgICAgICAgIGggPSBsLnkgIT09IHkgJiYgeSA8IDAgPyBsLmggOiBoO1xuICAgICAgICAgICAgeSA9IHkgPCAwID8gMCA6IHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNob3VsZE1vdmVJdGVtID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvbWV0aGluZyBsaWtlIHF1YWQgdHJlZSBzaG91bGQgYmUgdXNlZFxuICAgICAgICAvLyB0byBmaW5kIGNvbGxpc2lvbnMgZmFzdGVyXG4gICAgICAgIGlmIChwcmV2ZW50Q29sbGlzaW9uICYmICFhbGxvd092ZXJsYXApIHtcbiAgICAgICAgICBjb25zdCBjb2xsaXNpb25zID0gKDAsIF91dGlscy5nZXRBbGxDb2xsaXNpb25zKShsYXlvdXQsIHtcbiAgICAgICAgICAgIC4uLmwsXG4gICAgICAgICAgICB3LFxuICAgICAgICAgICAgaCxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5XG4gICAgICAgICAgfSkuZmlsdGVyKGxheW91dEl0ZW0gPT4gbGF5b3V0SXRlbS5pICE9PSBsLmkpO1xuICAgICAgICAgIGhhc0NvbGxpc2lvbnMgPSBjb2xsaXNpb25zLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBjb2xsaWRpbmcsIHdlIG5lZWQgYWRqdXN0IHRoZSBwbGFjZWhvbGRlci5cbiAgICAgICAgICBpZiAoaGFzQ29sbGlzaW9ucykge1xuICAgICAgICAgICAgLy8gUmVzZXQgbGF5b3V0SXRlbSBkaW1lbnNpb25zIGlmIHRoZXJlIHdlcmUgY29sbGlzaW9uc1xuICAgICAgICAgICAgeSA9IGwueTtcbiAgICAgICAgICAgIGggPSBsLmg7XG4gICAgICAgICAgICB4ID0gbC54O1xuICAgICAgICAgICAgdyA9IGwudztcbiAgICAgICAgICAgIHNob3VsZE1vdmVJdGVtID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGwudyA9IHc7XG4gICAgICAgIGwuaCA9IGg7XG4gICAgICAgIHJldHVybiBsO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNob3VsZG4ndCBldmVyIGhhcHBlbiwgYnV0IHR5cGVjaGVja2luZyBtYWtlcyBpdCBuZWNlc3NhcnlcbiAgICAgIGlmICghbCkgcmV0dXJuO1xuICAgICAgZmluYWxMYXlvdXQgPSBuZXdMYXlvdXQ7XG4gICAgICBpZiAoc2hvdWxkTW92ZUl0ZW0pIHtcbiAgICAgICAgLy8gTW92ZSB0aGUgZWxlbWVudCB0byB0aGUgbmV3IHBvc2l0aW9uLlxuICAgICAgICBjb25zdCBpc1VzZXJBY3Rpb24gPSB0cnVlO1xuICAgICAgICBmaW5hbExheW91dCA9ICgwLCBfdXRpbHMubW92ZUVsZW1lbnQpKG5ld0xheW91dCwgbCwgeCwgeSwgaXNVc2VyQWN0aW9uLCB0aGlzLnByb3BzLnByZXZlbnRDb2xsaXNpb24sICgwLCBfdXRpbHMuY29tcGFjdFR5cGUpKHRoaXMucHJvcHMpLCBjb2xzLCBhbGxvd092ZXJsYXApO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgcGxhY2Vob2xkZXIgZWxlbWVudCAoZGlzcGxheSBvbmx5KVxuICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB7XG4gICAgICAgIHc6IGwudyxcbiAgICAgICAgaDogbC5oLFxuICAgICAgICB4OiBsLngsXG4gICAgICAgIHk6IGwueSxcbiAgICAgICAgc3RhdGljOiB0cnVlLFxuICAgICAgICBpOiBpXG4gICAgICB9O1xuICAgICAgdGhpcy5wcm9wcy5vblJlc2l6ZShmaW5hbExheW91dCwgb2xkUmVzaXplSXRlbSwgbCwgcGxhY2Vob2xkZXIsIGUsIG5vZGUpO1xuXG4gICAgICAvLyBSZS1jb21wYWN0IHRoZSBuZXdMYXlvdXQgYW5kIHNldCB0aGUgZHJhZyBwbGFjZWhvbGRlci5cbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBsYXlvdXQ6IGFsbG93T3ZlcmxhcCA/IGZpbmFsTGF5b3V0IDogKDAsIF91dGlscy5jb21wYWN0KShmaW5hbExheW91dCwgKDAsIF91dGlscy5jb21wYWN0VHlwZSkodGhpcy5wcm9wcyksIGNvbHMpLFxuICAgICAgICBhY3RpdmVEcmFnOiBwbGFjZWhvbGRlclxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25SZXNpemVTdG9wXCIsIChpLCB3LCBoLCBfcmVmNikgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgZSxcbiAgICAgICAgbm9kZVxuICAgICAgfSA9IF9yZWY2O1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYXlvdXQsXG4gICAgICAgIG9sZFJlc2l6ZUl0ZW1cbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb2xzLFxuICAgICAgICBhbGxvd092ZXJsYXBcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgbCA9ICgwLCBfdXRpbHMuZ2V0TGF5b3V0SXRlbSkobGF5b3V0LCBpKTtcblxuICAgICAgLy8gU2V0IHN0YXRlXG4gICAgICBjb25zdCBuZXdMYXlvdXQgPSBhbGxvd092ZXJsYXAgPyBsYXlvdXQgOiAoMCwgX3V0aWxzLmNvbXBhY3QpKGxheW91dCwgKDAsIF91dGlscy5jb21wYWN0VHlwZSkodGhpcy5wcm9wcyksIGNvbHMpO1xuICAgICAgdGhpcy5wcm9wcy5vblJlc2l6ZVN0b3AobmV3TGF5b3V0LCBvbGRSZXNpemVJdGVtLCBsLCBudWxsLCBlLCBub2RlKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2xkTGF5b3V0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBhY3RpdmVEcmFnOiBudWxsLFxuICAgICAgICBsYXlvdXQ6IG5ld0xheW91dCxcbiAgICAgICAgb2xkUmVzaXplSXRlbTogbnVsbCxcbiAgICAgICAgb2xkTGF5b3V0OiBudWxsLFxuICAgICAgICByZXNpemluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbkxheW91dE1heWJlQ2hhbmdlZChuZXdMYXlvdXQsIG9sZExheW91dCk7XG4gICAgfSk7XG4gICAgLy8gQ2FsbGVkIHdoaWxlIGRyYWdnaW5nIGFuIGVsZW1lbnQuIFBhcnQgb2YgYnJvd3NlciBuYXRpdmUgZHJhZy9kcm9wIEFQSS5cbiAgICAvLyBOYXRpdmUgZXZlbnQgdGFyZ2V0IG1pZ2h0IGJlIHRoZSBsYXlvdXQgaXRzZWxmLCBvciBhbiBlbGVtZW50IHdpdGhpbiB0aGUgbGF5b3V0LlxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJhZ092ZXJcIiwgZSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgYW55IGJyb3dzZXIgbmF0aXZlIGFjdGlvblxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgLy8gd2Ugc2hvdWxkIGlnbm9yZSBldmVudHMgZnJvbSBsYXlvdXQncyBjaGlsZHJlbiBpbiBGaXJlZm94XG4gICAgICAvLyB0byBhdm9pZCB1bnByZWRpY3RhYmxlIGp1bXBpbmcgb2YgYSBkcm9wcGluZyBwbGFjZWhvbGRlclxuICAgICAgLy8gRklYTUUgcmVtb3ZlIHRoaXMgaGFja1xuICAgICAgaWYgKGlzRmlyZWZveCAmJlxuICAgICAgLy8gJEZsb3dJZ25vcmUgY2FuJ3QgZmlndXJlIHRoaXMgb3V0XG4gICAgICAhZS5uYXRpdmVFdmVudC50YXJnZXQ/LmNsYXNzTGlzdC5jb250YWlucyhsYXlvdXRDbGFzc05hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZHJvcHBpbmdJdGVtLFxuICAgICAgICBvbkRyb3BEcmFnT3ZlcixcbiAgICAgICAgbWFyZ2luLFxuICAgICAgICBjb2xzLFxuICAgICAgICByb3dIZWlnaHQsXG4gICAgICAgIG1heFJvd3MsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBjb250YWluZXJQYWRkaW5nLFxuICAgICAgICB0cmFuc2Zvcm1TY2FsZVxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAvLyBBbGxvdyB1c2VyIHRvIGN1c3RvbWl6ZSB0aGUgZHJvcHBpbmcgaXRlbSBvciBzaG9ydC1jaXJjdWl0IHRoZSBkcm9wIGJhc2VkIG9uIHRoZSByZXN1bHRzXG4gICAgICAvLyBvZiB0aGUgYG9uRHJhZ092ZXIoZTogRXZlbnQpYCBjYWxsYmFjay5cbiAgICAgIGNvbnN0IG9uRHJhZ092ZXJSZXN1bHQgPSBvbkRyb3BEcmFnT3Zlcj8uKGUpO1xuICAgICAgaWYgKG9uRHJhZ092ZXJSZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRyb3BwaW5nRE9NTm9kZSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRHJvcHBpbmdQbGFjZWhvbGRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbmFsRHJvcHBpbmdJdGVtID0ge1xuICAgICAgICAuLi5kcm9wcGluZ0l0ZW0sXG4gICAgICAgIC4uLm9uRHJhZ092ZXJSZXN1bHRcbiAgICAgIH07XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxheW91dFxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgIC8vICRGbG93SWdub3JlIG1pc3NpbmcgZGVmXG4gICAgICBjb25zdCBncmlkUmVjdCA9IGUuY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gVGhlIGdyaWQncyBwb3NpdGlvbiBpbiB0aGUgdmlld3BvcnRcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBtb3VzZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgZ3JpZFxuICAgICAgY29uc3QgbGF5ZXJYID0gZS5jbGllbnRYIC0gZ3JpZFJlY3QubGVmdDtcbiAgICAgIGNvbnN0IGxheWVyWSA9IGUuY2xpZW50WSAtIGdyaWRSZWN0LnRvcDtcbiAgICAgIGNvbnN0IGRyb3BwaW5nUG9zaXRpb24gPSB7XG4gICAgICAgIGxlZnQ6IGxheWVyWCAvIHRyYW5zZm9ybVNjYWxlLFxuICAgICAgICB0b3A6IGxheWVyWSAvIHRyYW5zZm9ybVNjYWxlLFxuICAgICAgICBlXG4gICAgICB9O1xuICAgICAgaWYgKCF0aGlzLnN0YXRlLmRyb3BwaW5nRE9NTm9kZSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvblBhcmFtcyAvKjogUG9zaXRpb25QYXJhbXMqLyA9IHtcbiAgICAgICAgICBjb2xzLFxuICAgICAgICAgIG1hcmdpbixcbiAgICAgICAgICBtYXhSb3dzLFxuICAgICAgICAgIHJvd0hlaWdodCxcbiAgICAgICAgICBjb250YWluZXJXaWR0aDogd2lkdGgsXG4gICAgICAgICAgY29udGFpbmVyUGFkZGluZzogY29udGFpbmVyUGFkZGluZyB8fCBtYXJnaW5cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZFBvc2l0aW9uID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jYWxjWFkpKHBvc2l0aW9uUGFyYW1zLCBsYXllclksIGxheWVyWCwgZmluYWxEcm9wcGluZ0l0ZW0udywgZmluYWxEcm9wcGluZ0l0ZW0uaCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGRyb3BwaW5nRE9NTm9kZTogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgICAga2V5OiBmaW5hbERyb3BwaW5nSXRlbS5pXG4gICAgICAgICAgfSksXG4gICAgICAgICAgZHJvcHBpbmdQb3NpdGlvbixcbiAgICAgICAgICBsYXlvdXQ6IFsuLi5sYXlvdXQsIHtcbiAgICAgICAgICAgIC4uLmZpbmFsRHJvcHBpbmdJdGVtLFxuICAgICAgICAgICAgeDogY2FsY3VsYXRlZFBvc2l0aW9uLngsXG4gICAgICAgICAgICB5OiBjYWxjdWxhdGVkUG9zaXRpb24ueSxcbiAgICAgICAgICAgIHN0YXRpYzogZmFsc2UsXG4gICAgICAgICAgICBpc0RyYWdnYWJsZTogdHJ1ZVxuICAgICAgICAgIH1dXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmRyb3BwaW5nUG9zaXRpb24pIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgdG9wXG4gICAgICAgIH0gPSB0aGlzLnN0YXRlLmRyb3BwaW5nUG9zaXRpb247XG4gICAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZVBvc2l0aW9uID0gbGVmdCAhPSBsYXllclggfHwgdG9wICE9IGxheWVyWTtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZVBvc2l0aW9uKSB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBkcm9wcGluZ1Bvc2l0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZW1vdmVEcm9wcGluZ1BsYWNlaG9sZGVyXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZHJvcHBpbmdJdGVtLFxuICAgICAgICBjb2xzXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGF5b3V0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IG5ld0xheW91dCA9ICgwLCBfdXRpbHMuY29tcGFjdCkobGF5b3V0LmZpbHRlcihsID0+IGwuaSAhPT0gZHJvcHBpbmdJdGVtLmkpLCAoMCwgX3V0aWxzLmNvbXBhY3RUeXBlKSh0aGlzLnByb3BzKSwgY29scywgdGhpcy5wcm9wcy5hbGxvd092ZXJsYXApO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGxheW91dDogbmV3TGF5b3V0LFxuICAgICAgICBkcm9wcGluZ0RPTU5vZGU6IG51bGwsXG4gICAgICAgIGFjdGl2ZURyYWc6IG51bGwsXG4gICAgICAgIGRyb3BwaW5nUG9zaXRpb246IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25EcmFnTGVhdmVcIiwgZSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgYW55IGJyb3dzZXIgbmF0aXZlIGFjdGlvblxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHRoaXMuZHJhZ0VudGVyQ291bnRlci0tO1xuXG4gICAgICAvLyBvbkRyYWdMZWF2ZSBjYW4gYmUgdHJpZ2dlcmVkIG9uIGVhY2ggbGF5b3V0J3MgY2hpbGQuXG4gICAgICAvLyBCdXQgd2Uga25vdyB0aGF0IGNvdW50IG9mIGRyYWdFbnRlciBhbmQgZHJhZ0xlYXZlIGV2ZW50c1xuICAgICAgLy8gd2lsbCBiZSBiYWxhbmNlZCBhZnRlciBsZWF2aW5nIHRoZSBsYXlvdXQncyBjb250YWluZXJcbiAgICAgIC8vIHNvIHdlIGNhbiBpbmNyZWFzZSBhbmQgZGVjcmVhc2UgY291bnQgb2YgZHJhZ0VudGVyIGFuZFxuICAgICAgLy8gd2hlbiBpdCdsbCBiZSBlcXVhbCB0byAwIHdlJ2xsIHJlbW92ZSB0aGUgcGxhY2Vob2xkZXJcbiAgICAgIGlmICh0aGlzLmRyYWdFbnRlckNvdW50ZXIgPT09IDApIHtcbiAgICAgICAgdGhpcy5yZW1vdmVEcm9wcGluZ1BsYWNlaG9sZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25EcmFnRW50ZXJcIiwgZSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgYW55IGJyb3dzZXIgbmF0aXZlIGFjdGlvblxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHRoaXMuZHJhZ0VudGVyQ291bnRlcisrO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJvcFwiLCAoZSAvKjogRXZlbnQqLykgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGFueSBicm93c2VyIG5hdGl2ZSBhY3Rpb25cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRyb3BwaW5nSXRlbVxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxheW91dFxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBpdGVtID0gbGF5b3V0LmZpbmQobCA9PiBsLmkgPT09IGRyb3BwaW5nSXRlbS5pKTtcblxuICAgICAgLy8gcmVzZXQgZHJhZ0VudGVyIGNvdW50ZXIgb24gZHJvcFxuICAgICAgdGhpcy5kcmFnRW50ZXJDb3VudGVyID0gMDtcbiAgICAgIHRoaXMucmVtb3ZlRHJvcHBpbmdQbGFjZWhvbGRlcigpO1xuICAgICAgdGhpcy5wcm9wcy5vbkRyb3AobGF5b3V0LCBpdGVtLCBlKTtcbiAgICB9KTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG1vdW50ZWQ6IHRydWVcbiAgICB9KTtcbiAgICAvLyBQb3NzaWJseSBjYWxsIGJhY2sgd2l0aCBsYXlvdXQgb24gbW91bnQuIFRoaXMgc2hvdWxkIGJlIGRvbmUgYWZ0ZXIgY29ycmVjdGluZyB0aGUgbGF5b3V0IHdpZHRoXG4gICAgLy8gdG8gZW5zdXJlIHdlIGRvbid0IHJlcmVuZGVyIHdpdGggdGhlIHdyb25nIHdpZHRoLlxuICAgIHRoaXMub25MYXlvdXRNYXliZUNoYW5nZWQodGhpcy5zdGF0ZS5sYXlvdXQsIHRoaXMucHJvcHMubGF5b3V0KTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcyAvKjogUHJvcHMqLywgcHJldlN0YXRlIC8qOiBTdGF0ZSovKSAvKjogJFNoYXBlPFN0YXRlPiB8IG51bGwqL3tcbiAgICBsZXQgbmV3TGF5b3V0QmFzZTtcbiAgICBpZiAocHJldlN0YXRlLmFjdGl2ZURyYWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBzdXBwb3J0IGZvciBjb21wYWN0VHlwZVxuICAgIC8vIEFsbG93IHBhcmVudCB0byBzZXQgbGF5b3V0IGRpcmVjdGx5LlxuICAgIGlmICghKDAsIF9mYXN0RXF1YWxzLmRlZXBFcXVhbCkobmV4dFByb3BzLmxheW91dCwgcHJldlN0YXRlLnByb3BzTGF5b3V0KSB8fCBuZXh0UHJvcHMuY29tcGFjdFR5cGUgIT09IHByZXZTdGF0ZS5jb21wYWN0VHlwZSkge1xuICAgICAgbmV3TGF5b3V0QmFzZSA9IG5leHRQcm9wcy5sYXlvdXQ7XG4gICAgfSBlbHNlIGlmICghKDAsIF91dGlscy5jaGlsZHJlbkVxdWFsKShuZXh0UHJvcHMuY2hpbGRyZW4sIHByZXZTdGF0ZS5jaGlsZHJlbikpIHtcbiAgICAgIC8vIElmIGNoaWxkcmVuIGNoYW5nZSwgYWxzbyByZWdlbmVyYXRlIHRoZSBsYXlvdXQuIFVzZSBvdXIgc3RhdGVcbiAgICAgIC8vIGFzIHRoZSBiYXNlIGluIGNhc2UgYmVjYXVzZSBpdCBtYXkgYmUgbW9yZSB1cCB0byBkYXRlIHRoYW5cbiAgICAgIC8vIHdoYXQgaXMgaW4gcHJvcHMuXG4gICAgICBuZXdMYXlvdXRCYXNlID0gcHJldlN0YXRlLmxheW91dDtcbiAgICB9XG5cbiAgICAvLyBXZSBuZWVkIHRvIHJlZ2VuZXJhdGUgdGhlIGxheW91dC5cbiAgICBpZiAobmV3TGF5b3V0QmFzZSkge1xuICAgICAgY29uc3QgbmV3TGF5b3V0ID0gKDAsIF91dGlscy5zeW5jaHJvbml6ZUxheW91dFdpdGhDaGlsZHJlbikobmV3TGF5b3V0QmFzZSwgbmV4dFByb3BzLmNoaWxkcmVuLCBuZXh0UHJvcHMuY29scywgKDAsIF91dGlscy5jb21wYWN0VHlwZSkobmV4dFByb3BzKSwgbmV4dFByb3BzLmFsbG93T3ZlcmxhcCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYXlvdXQ6IG5ld0xheW91dCxcbiAgICAgICAgLy8gV2UgbmVlZCB0byBzYXZlIHRoZXNlIHByb3BzIHRvIHN0YXRlIGZvciB1c2luZ1xuICAgICAgICAvLyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgaW5zdGVhZCBvZiBjb21wb25lbnREaWRNb3VudCAoaW4gd2hpY2ggd2Ugd291bGQgZ2V0IGV4dHJhIHJlcmVuZGVyKVxuICAgICAgICBjb21wYWN0VHlwZTogbmV4dFByb3BzLmNvbXBhY3RUeXBlLFxuICAgICAgICBjaGlsZHJlbjogbmV4dFByb3BzLmNoaWxkcmVuLFxuICAgICAgICBwcm9wc0xheW91dDogbmV4dFByb3BzLmxheW91dFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcyAvKjogUHJvcHMqLywgbmV4dFN0YXRlIC8qOiBTdGF0ZSovKSAvKjogYm9vbGVhbiove1xuICAgIHJldHVybiAoXG4gICAgICAvLyBOT1RFOiB0aGlzIGlzIGFsbW9zdCBhbHdheXMgdW5lcXVhbC4gVGhlcmVmb3JlIHRoZSBvbmx5IHdheSB0byBnZXQgYmV0dGVyIHBlcmZvcm1hbmNlXG4gICAgICAvLyBmcm9tIFNDVSBpcyBpZiB0aGUgdXNlciBpbnRlbnRpb25hbGx5IG1lbW9pemVzIGNoaWxkcmVuLiBJZiB0aGV5IGRvLCBhbmQgdGhleSBjYW5cbiAgICAgIC8vIGhhbmRsZSBjaGFuZ2VzIHByb3Blcmx5LCBwZXJmb3JtYW5jZSB3aWxsIGluY3JlYXNlLlxuICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlbiAhPT0gbmV4dFByb3BzLmNoaWxkcmVuIHx8ICEoMCwgX3V0aWxzLmZhc3RSR0xQcm9wc0VxdWFsKSh0aGlzLnByb3BzLCBuZXh0UHJvcHMsIF9mYXN0RXF1YWxzLmRlZXBFcXVhbCkgfHwgdGhpcy5zdGF0ZS5hY3RpdmVEcmFnICE9PSBuZXh0U3RhdGUuYWN0aXZlRHJhZyB8fCB0aGlzLnN0YXRlLm1vdW50ZWQgIT09IG5leHRTdGF0ZS5tb3VudGVkIHx8IHRoaXMuc3RhdGUuZHJvcHBpbmdQb3NpdGlvbiAhPT0gbmV4dFN0YXRlLmRyb3BwaW5nUG9zaXRpb25cbiAgICApO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMgLyo6IFByb3BzKi8sIHByZXZTdGF0ZSAvKjogU3RhdGUqLykge1xuICAgIGlmICghdGhpcy5zdGF0ZS5hY3RpdmVEcmFnKSB7XG4gICAgICBjb25zdCBuZXdMYXlvdXQgPSB0aGlzLnN0YXRlLmxheW91dDtcbiAgICAgIGNvbnN0IG9sZExheW91dCA9IHByZXZTdGF0ZS5sYXlvdXQ7XG4gICAgICB0aGlzLm9uTGF5b3V0TWF5YmVDaGFuZ2VkKG5ld0xheW91dCwgb2xkTGF5b3V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBhIHBpeGVsIHZhbHVlIGZvciB0aGUgY29udGFpbmVyLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IENvbnRhaW5lciBoZWlnaHQgaW4gcGl4ZWxzLlxuICAgKi9cbiAgY29udGFpbmVySGVpZ2h0KCkgLyo6ID9zdHJpbmcqL3tcbiAgICBpZiAoIXRoaXMucHJvcHMuYXV0b1NpemUpIHJldHVybjtcbiAgICBjb25zdCBuYlJvdyA9ICgwLCBfdXRpbHMuYm90dG9tKSh0aGlzLnN0YXRlLmxheW91dCk7XG4gICAgY29uc3QgY29udGFpbmVyUGFkZGluZ1kgPSB0aGlzLnByb3BzLmNvbnRhaW5lclBhZGRpbmcgPyB0aGlzLnByb3BzLmNvbnRhaW5lclBhZGRpbmdbMV0gOiB0aGlzLnByb3BzLm1hcmdpblsxXTtcbiAgICByZXR1cm4gbmJSb3cgKiB0aGlzLnByb3BzLnJvd0hlaWdodCArIChuYlJvdyAtIDEpICogdGhpcy5wcm9wcy5tYXJnaW5bMV0gKyBjb250YWluZXJQYWRkaW5nWSAqIDIgKyBcInB4XCI7XG4gIH1cbiAgb25MYXlvdXRNYXliZUNoYW5nZWQobmV3TGF5b3V0IC8qOiBMYXlvdXQqLywgb2xkTGF5b3V0IC8qOiA/TGF5b3V0Ki8pIHtcbiAgICBpZiAoIW9sZExheW91dCkgb2xkTGF5b3V0ID0gdGhpcy5zdGF0ZS5sYXlvdXQ7XG4gICAgaWYgKCEoMCwgX2Zhc3RFcXVhbHMuZGVlcEVxdWFsKShvbGRMYXlvdXQsIG5ld0xheW91dCkpIHtcbiAgICAgIHRoaXMucHJvcHMub25MYXlvdXRDaGFuZ2UobmV3TGF5b3V0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHBsYWNlaG9sZGVyIG9iamVjdC5cbiAgICogQHJldHVybiB7RWxlbWVudH0gUGxhY2Vob2xkZXIgZGl2LlxuICAgKi9cbiAgcGxhY2Vob2xkZXIoKSAvKjogP1JlYWN0RWxlbWVudDxhbnk+Ki97XG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZlRHJhZ1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICghYWN0aXZlRHJhZykgcmV0dXJuIG51bGw7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBjb2xzLFxuICAgICAgbWFyZ2luLFxuICAgICAgY29udGFpbmVyUGFkZGluZyxcbiAgICAgIHJvd0hlaWdodCxcbiAgICAgIG1heFJvd3MsXG4gICAgICB1c2VDU1NUcmFuc2Zvcm1zLFxuICAgICAgdHJhbnNmb3JtU2NhbGVcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIHsuLi50aGlzLnN0YXRlLmFjdGl2ZURyYWd9IGlzIHByZXR0eSBzbG93LCBhY3R1YWxseVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChfR3JpZEl0ZW0uZGVmYXVsdCwge1xuICAgICAgdzogYWN0aXZlRHJhZy53LFxuICAgICAgaDogYWN0aXZlRHJhZy5oLFxuICAgICAgeDogYWN0aXZlRHJhZy54LFxuICAgICAgeTogYWN0aXZlRHJhZy55LFxuICAgICAgaTogYWN0aXZlRHJhZy5pLFxuICAgICAgY2xhc3NOYW1lOiBgcmVhY3QtZ3JpZC1wbGFjZWhvbGRlciAke3RoaXMuc3RhdGUucmVzaXppbmcgPyBcInBsYWNlaG9sZGVyLXJlc2l6aW5nXCIgOiBcIlwifWAsXG4gICAgICBjb250YWluZXJXaWR0aDogd2lkdGgsXG4gICAgICBjb2xzOiBjb2xzLFxuICAgICAgbWFyZ2luOiBtYXJnaW4sXG4gICAgICBjb250YWluZXJQYWRkaW5nOiBjb250YWluZXJQYWRkaW5nIHx8IG1hcmdpbixcbiAgICAgIG1heFJvd3M6IG1heFJvd3MsXG4gICAgICByb3dIZWlnaHQ6IHJvd0hlaWdodCxcbiAgICAgIGlzRHJhZ2dhYmxlOiBmYWxzZSxcbiAgICAgIGlzUmVzaXphYmxlOiBmYWxzZSxcbiAgICAgIGlzQm91bmRlZDogZmFsc2UsXG4gICAgICB1c2VDU1NUcmFuc2Zvcm1zOiB1c2VDU1NUcmFuc2Zvcm1zLFxuICAgICAgdHJhbnNmb3JtU2NhbGU6IHRyYW5zZm9ybVNjYWxlXG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgZ3JpZCBpdGVtLCBzZXQgaXRzIHN0eWxlIGF0dHJpYnV0ZXMgJiBzdXJyb3VuZCBpbiBhIDxEcmFnZ2FibGU+LlxuICAgKiBAcGFyYW0gIHtFbGVtZW50fSBjaGlsZCBSZWFjdCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSAgICAgICBFbGVtZW50IHdyYXBwZWQgaW4gZHJhZ2dhYmxlIGFuZCBwcm9wZXJseSBwbGFjZWQuXG4gICAqL1xuICBwcm9jZXNzR3JpZEl0ZW0oY2hpbGQgLyo6IFJlYWN0RWxlbWVudDxhbnk+Ki8sIGlzRHJvcHBpbmdJdGVtIC8qOiBib29sZWFuKi8pIC8qOiA/UmVhY3RFbGVtZW50PGFueT4qL3tcbiAgICBpZiAoIWNoaWxkIHx8ICFjaGlsZC5rZXkpIHJldHVybjtcbiAgICBjb25zdCBsID0gKDAsIF91dGlscy5nZXRMYXlvdXRJdGVtKSh0aGlzLnN0YXRlLmxheW91dCwgU3RyaW5nKGNoaWxkLmtleSkpO1xuICAgIGlmICghbCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBjb2xzLFxuICAgICAgbWFyZ2luLFxuICAgICAgY29udGFpbmVyUGFkZGluZyxcbiAgICAgIHJvd0hlaWdodCxcbiAgICAgIG1heFJvd3MsXG4gICAgICBpc0RyYWdnYWJsZSxcbiAgICAgIGlzUmVzaXphYmxlLFxuICAgICAgaXNCb3VuZGVkLFxuICAgICAgdXNlQ1NTVHJhbnNmb3JtcyxcbiAgICAgIHRyYW5zZm9ybVNjYWxlLFxuICAgICAgZHJhZ2dhYmxlQ2FuY2VsLFxuICAgICAgZHJhZ2dhYmxlSGFuZGxlLFxuICAgICAgcmVzaXplSGFuZGxlcyxcbiAgICAgIHJlc2l6ZUhhbmRsZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIG1vdW50ZWQsXG4gICAgICBkcm9wcGluZ1Bvc2l0aW9uXG4gICAgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAvLyBEZXRlcm1pbmUgdXNlciBtYW5pcHVsYXRpb25zIHBvc3NpYmxlLlxuICAgIC8vIElmIGFuIGl0ZW0gaXMgc3RhdGljLCBpdCBjYW4ndCBiZSBtYW5pcHVsYXRlZCBieSBkZWZhdWx0LlxuICAgIC8vIEFueSBwcm9wZXJ0aWVzIGRlZmluZWQgZGlyZWN0bHkgb24gdGhlIGdyaWQgaXRlbSB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAgICBjb25zdCBkcmFnZ2FibGUgPSB0eXBlb2YgbC5pc0RyYWdnYWJsZSA9PT0gXCJib29sZWFuXCIgPyBsLmlzRHJhZ2dhYmxlIDogIWwuc3RhdGljICYmIGlzRHJhZ2dhYmxlO1xuICAgIGNvbnN0IHJlc2l6YWJsZSA9IHR5cGVvZiBsLmlzUmVzaXphYmxlID09PSBcImJvb2xlYW5cIiA/IGwuaXNSZXNpemFibGUgOiAhbC5zdGF0aWMgJiYgaXNSZXNpemFibGU7XG4gICAgY29uc3QgcmVzaXplSGFuZGxlc09wdGlvbnMgPSBsLnJlc2l6ZUhhbmRsZXMgfHwgcmVzaXplSGFuZGxlcztcblxuICAgIC8vIGlzQm91bmRlZCBzZXQgb24gY2hpbGQgaWYgc2V0IG9uIHBhcmVudCwgYW5kIGNoaWxkIGlzIG5vdCBleHBsaWNpdGx5IGZhbHNlXG4gICAgY29uc3QgYm91bmRlZCA9IGRyYWdnYWJsZSAmJiBpc0JvdW5kZWQgJiYgbC5pc0JvdW5kZWQgIT09IGZhbHNlO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChfR3JpZEl0ZW0uZGVmYXVsdCwge1xuICAgICAgY29udGFpbmVyV2lkdGg6IHdpZHRoLFxuICAgICAgY29sczogY29scyxcbiAgICAgIG1hcmdpbjogbWFyZ2luLFxuICAgICAgY29udGFpbmVyUGFkZGluZzogY29udGFpbmVyUGFkZGluZyB8fCBtYXJnaW4sXG4gICAgICBtYXhSb3dzOiBtYXhSb3dzLFxuICAgICAgcm93SGVpZ2h0OiByb3dIZWlnaHQsXG4gICAgICBjYW5jZWw6IGRyYWdnYWJsZUNhbmNlbCxcbiAgICAgIGhhbmRsZTogZHJhZ2dhYmxlSGFuZGxlLFxuICAgICAgb25EcmFnU3RvcDogdGhpcy5vbkRyYWdTdG9wLFxuICAgICAgb25EcmFnU3RhcnQ6IHRoaXMub25EcmFnU3RhcnQsXG4gICAgICBvbkRyYWc6IHRoaXMub25EcmFnLFxuICAgICAgb25SZXNpemVTdGFydDogdGhpcy5vblJlc2l6ZVN0YXJ0LFxuICAgICAgb25SZXNpemU6IHRoaXMub25SZXNpemUsXG4gICAgICBvblJlc2l6ZVN0b3A6IHRoaXMub25SZXNpemVTdG9wLFxuICAgICAgaXNEcmFnZ2FibGU6IGRyYWdnYWJsZSxcbiAgICAgIGlzUmVzaXphYmxlOiByZXNpemFibGUsXG4gICAgICBpc0JvdW5kZWQ6IGJvdW5kZWQsXG4gICAgICB1c2VDU1NUcmFuc2Zvcm1zOiB1c2VDU1NUcmFuc2Zvcm1zICYmIG1vdW50ZWQsXG4gICAgICB1c2VQZXJjZW50YWdlczogIW1vdW50ZWQsXG4gICAgICB0cmFuc2Zvcm1TY2FsZTogdHJhbnNmb3JtU2NhbGUsXG4gICAgICB3OiBsLncsXG4gICAgICBoOiBsLmgsXG4gICAgICB4OiBsLngsXG4gICAgICB5OiBsLnksXG4gICAgICBpOiBsLmksXG4gICAgICBtaW5IOiBsLm1pbkgsXG4gICAgICBtaW5XOiBsLm1pblcsXG4gICAgICBtYXhIOiBsLm1heEgsXG4gICAgICBtYXhXOiBsLm1heFcsXG4gICAgICBzdGF0aWM6IGwuc3RhdGljLFxuICAgICAgZHJvcHBpbmdQb3NpdGlvbjogaXNEcm9wcGluZ0l0ZW0gPyBkcm9wcGluZ1Bvc2l0aW9uIDogdW5kZWZpbmVkLFxuICAgICAgcmVzaXplSGFuZGxlczogcmVzaXplSGFuZGxlc09wdGlvbnMsXG4gICAgICByZXNpemVIYW5kbGU6IHJlc2l6ZUhhbmRsZVxuICAgIH0sIGNoaWxkKTtcbiAgfVxuICByZW5kZXIoKSAvKjogUmVhY3QuRWxlbWVudDxcImRpdlwiPiove1xuICAgIGNvbnN0IHtcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIHN0eWxlLFxuICAgICAgaXNEcm9wcGFibGUsXG4gICAgICBpbm5lclJlZlxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IG1lcmdlZENsYXNzTmFtZSA9ICgwLCBfY2xzeC5kZWZhdWx0KShsYXlvdXRDbGFzc05hbWUsIGNsYXNzTmFtZSk7XG4gICAgY29uc3QgbWVyZ2VkU3R5bGUgPSB7XG4gICAgICBoZWlnaHQ6IHRoaXMuY29udGFpbmVySGVpZ2h0KCksXG4gICAgICAuLi5zdHlsZVxuICAgIH07XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIHJlZjogaW5uZXJSZWYsXG4gICAgICBjbGFzc05hbWU6IG1lcmdlZENsYXNzTmFtZSxcbiAgICAgIHN0eWxlOiBtZXJnZWRTdHlsZSxcbiAgICAgIG9uRHJvcDogaXNEcm9wcGFibGUgPyB0aGlzLm9uRHJvcCA6IF91dGlscy5ub29wLFxuICAgICAgb25EcmFnTGVhdmU6IGlzRHJvcHBhYmxlID8gdGhpcy5vbkRyYWdMZWF2ZSA6IF91dGlscy5ub29wLFxuICAgICAgb25EcmFnRW50ZXI6IGlzRHJvcHBhYmxlID8gdGhpcy5vbkRyYWdFbnRlciA6IF91dGlscy5ub29wLFxuICAgICAgb25EcmFnT3ZlcjogaXNEcm9wcGFibGUgPyB0aGlzLm9uRHJhZ092ZXIgOiBfdXRpbHMubm9vcFxuICAgIH0sIFJlYWN0LkNoaWxkcmVuLm1hcCh0aGlzLnByb3BzLmNoaWxkcmVuLCBjaGlsZCA9PiB0aGlzLnByb2Nlc3NHcmlkSXRlbShjaGlsZCkpLCBpc0Ryb3BwYWJsZSAmJiB0aGlzLnN0YXRlLmRyb3BwaW5nRE9NTm9kZSAmJiB0aGlzLnByb2Nlc3NHcmlkSXRlbSh0aGlzLnN0YXRlLmRyb3BwaW5nRE9NTm9kZSwgdHJ1ZSksIHRoaXMucGxhY2Vob2xkZXIoKSk7XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFJlYWN0R3JpZExheW91dDtcbi8vIFRPRE8gcHVibGlzaCBpbnRlcm5hbCBSZWFjdENsYXNzIGRpc3BsYXlOYW1lIHRyYW5zZm9ybVxuX2RlZmluZVByb3BlcnR5KFJlYWN0R3JpZExheW91dCwgXCJkaXNwbGF5TmFtZVwiLCBcIlJlYWN0R3JpZExheW91dFwiKTtcbi8vIFJlZmFjdG9yZWQgdG8gYW5vdGhlciBtb2R1bGUgdG8gbWFrZSB3YXkgZm9yIHByZXZhbFxuX2RlZmluZVByb3BlcnR5KFJlYWN0R3JpZExheW91dCwgXCJwcm9wVHlwZXNcIiwgX1JlYWN0R3JpZExheW91dFByb3BUeXBlcy5kZWZhdWx0KTtcbl9kZWZpbmVQcm9wZXJ0eShSZWFjdEdyaWRMYXlvdXQsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgYXV0b1NpemU6IHRydWUsXG4gIGNvbHM6IDEyLFxuICBjbGFzc05hbWU6IFwiXCIsXG4gIHN0eWxlOiB7fSxcbiAgZHJhZ2dhYmxlSGFuZGxlOiBcIlwiLFxuICBkcmFnZ2FibGVDYW5jZWw6IFwiXCIsXG4gIGNvbnRhaW5lclBhZGRpbmc6IG51bGwsXG4gIHJvd0hlaWdodDogMTUwLFxuICBtYXhSb3dzOiBJbmZpbml0eSxcbiAgLy8gaW5maW5pdGUgdmVydGljYWwgZ3Jvd3RoXG4gIGxheW91dDogW10sXG4gIG1hcmdpbjogWzEwLCAxMF0sXG4gIGlzQm91bmRlZDogZmFsc2UsXG4gIGlzRHJhZ2dhYmxlOiB0cnVlLFxuICBpc1Jlc2l6YWJsZTogdHJ1ZSxcbiAgYWxsb3dPdmVybGFwOiBmYWxzZSxcbiAgaXNEcm9wcGFibGU6IGZhbHNlLFxuICB1c2VDU1NUcmFuc2Zvcm1zOiB0cnVlLFxuICB0cmFuc2Zvcm1TY2FsZTogMSxcbiAgdmVydGljYWxDb21wYWN0OiB0cnVlLFxuICBjb21wYWN0VHlwZTogXCJ2ZXJ0aWNhbFwiLFxuICBwcmV2ZW50Q29sbGlzaW9uOiBmYWxzZSxcbiAgZHJvcHBpbmdJdGVtOiB7XG4gICAgaTogXCJfX2Ryb3BwaW5nLWVsZW1fX1wiLFxuICAgIGg6IDEsXG4gICAgdzogMVxuICB9LFxuICByZXNpemVIYW5kbGVzOiBbXCJzZVwiXSxcbiAgb25MYXlvdXRDaGFuZ2U6IF91dGlscy5ub29wLFxuICBvbkRyYWdTdGFydDogX3V0aWxzLm5vb3AsXG4gIG9uRHJhZzogX3V0aWxzLm5vb3AsXG4gIG9uRHJhZ1N0b3A6IF91dGlscy5ub29wLFxuICBvblJlc2l6ZVN0YXJ0OiBfdXRpbHMubm9vcCxcbiAgb25SZXNpemU6IF91dGlscy5ub29wLFxuICBvblJlc2l6ZVN0b3A6IF91dGlscy5ub29wLFxuICBvbkRyb3A6IF91dGlscy5ub29wLFxuICBvbkRyb3BEcmFnT3ZlcjogX3V0aWxzLm5vb3Bcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/react-grid-layout/build/ReactGridLayout.js\n");

/***/ }),

/***/ "../../node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.resizeHandleType = exports.resizeHandleAxesType = exports[\"default\"] = void 0;\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"../../node_modules/prop-types/index.js\"));\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/*:: import type {\n  Ref,\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n/*:: import type {\n  DragOverEvent,\n  EventCallback,\n  CompactType,\n  Layout,\n  LayoutItem,\n  ResizeHandleAxis\n} from \"./utils\";*/\n/*:: export type ReactRef<T: HTMLElement> = {|\n  +current: T | null\n|};*/\n// util\n/*:: export type ResizeHandle =\n  | ReactElement<any>\n  | ((\n      resizeHandleAxis: ResizeHandleAxis,\n      ref: ReactRef<HTMLElement>\n    ) => ReactElement<any>);*/\n// Defines which resize handles should be rendered (default: 'se')\n// Allows for any combination of:\n// 's' - South handle (bottom-center)\n// 'w' - West handle (left-center)\n// 'e' - East handle (right-center)\n// 'n' - North handle (top-center)\n// 'sw' - Southwest handle (bottom-left)\n// 'nw' - Northwest handle (top-left)\n// 'se' - Southeast handle (bottom-right)\n// 'ne' - Northeast handle (top-right)\nconst resizeHandleAxesType /*: ReactPropsChainableTypeChecker*/ = exports.resizeHandleAxesType = _propTypes.default.arrayOf(_propTypes.default.oneOf([\"s\", \"w\", \"e\", \"n\", \"sw\", \"nw\", \"se\", \"ne\"]));\n// Custom component for resize handles\nconst resizeHandleType /*: ReactPropsChainableTypeChecker*/ = exports.resizeHandleType = _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]);\n/*:: export type Props = {|\n  className: string,\n  style: Object,\n  width: number,\n  autoSize: boolean,\n  cols: number,\n  draggableCancel: string,\n  draggableHandle: string,\n  verticalCompact: boolean,\n  compactType: CompactType,\n  layout: Layout,\n  margin: [number, number],\n  containerPadding: ?[number, number],\n  rowHeight: number,\n  maxRows: number,\n  isBounded: boolean,\n  isDraggable: boolean,\n  isResizable: boolean,\n  isDroppable: boolean,\n  preventCollision: boolean,\n  useCSSTransforms: boolean,\n  transformScale: number,\n  droppingItem: $Shape<LayoutItem>,\n  resizeHandles: ResizeHandleAxis[],\n  resizeHandle?: ResizeHandle,\n  allowOverlap: boolean,\n\n  // Callbacks\n  onLayoutChange: Layout => void,\n  onDrag: EventCallback,\n  onDragStart: EventCallback,\n  onDragStop: EventCallback,\n  onResize: EventCallback,\n  onResizeStart: EventCallback,\n  onResizeStop: EventCallback,\n  onDropDragOver: (e: DragOverEvent) => ?({| w?: number, h?: number |} | false),\n  onDrop: (layout: Layout, item: ?LayoutItem, e: Event) => void,\n  children: ReactChildrenArray<ReactElement<any>>,\n  innerRef?: Ref<\"div\">\n|};*/\n/*:: export type DefaultProps = $Diff<\n  Props,\n  {\n    children: ReactChildrenArray<ReactElement<any>>,\n    width: number\n  }\n>;*/\nvar _default = exports[\"default\"] = {\n  //\n  // Basic props\n  //\n  className: _propTypes.default.string,\n  style: _propTypes.default.object,\n  // This can be set explicitly. If it is not set, it will automatically\n  // be set to the container width. Note that resizes will *not* cause this to adjust.\n  // If you need that behavior, use WidthProvider.\n  width: _propTypes.default.number,\n  // If true, the container height swells and contracts to fit contents\n  autoSize: _propTypes.default.bool,\n  // # of cols.\n  cols: _propTypes.default.number,\n  // A selector that will not be draggable.\n  draggableCancel: _propTypes.default.string,\n  // A selector for the draggable handler\n  draggableHandle: _propTypes.default.string,\n  // Deprecated\n  verticalCompact: function (props /*: Props*/) {\n    if (props.verticalCompact === false && \"development\" !== \"production\") {\n      console.warn(\n      // eslint-disable-line no-console\n      \"`verticalCompact` on <ReactGridLayout> is deprecated and will be removed soon. \" + 'Use `compactType`: \"horizontal\" | \"vertical\" | null.');\n    }\n  },\n  // Choose vertical or hotizontal compaction\n  compactType: (_propTypes.default.oneOf([\"vertical\", \"horizontal\"]) /*: ReactPropsChainableTypeChecker*/),\n  // layout is an array of object with the format:\n  // {x: Number, y: Number, w: Number, h: Number, i: String}\n  layout: function (props /*: Props*/) {\n    var layout = props.layout;\n    // I hope you're setting the data-grid property on the grid items\n    if (layout === undefined) return;\n    (__webpack_require__(/*! ./utils */ \"../../node_modules/react-grid-layout/build/utils.js\").validateLayout)(layout, \"layout\");\n  },\n  //\n  // Grid Dimensions\n  //\n\n  // Margin between items [x, y] in px\n  margin: (_propTypes.default.arrayOf(_propTypes.default.number) /*: ReactPropsChainableTypeChecker*/),\n  // Padding inside the container [x, y] in px\n  containerPadding: (_propTypes.default.arrayOf(_propTypes.default.number) /*: ReactPropsChainableTypeChecker*/),\n  // Rows have a static height, but you can change this based on breakpoints if you like\n  rowHeight: _propTypes.default.number,\n  // Default Infinity, but you can specify a max here if you like.\n  // Note that this isn't fully fleshed out and won't error if you specify a layout that\n  // extends beyond the row capacity. It will, however, not allow users to drag/resize\n  // an item past the barrier. They can push items beyond the barrier, though.\n  // Intentionally not documented for this reason.\n  maxRows: _propTypes.default.number,\n  //\n  // Flags\n  //\n  isBounded: _propTypes.default.bool,\n  isDraggable: _propTypes.default.bool,\n  isResizable: _propTypes.default.bool,\n  // If true, grid can be placed one over the other.\n  allowOverlap: _propTypes.default.bool,\n  // If true, grid items won't change position when being dragged over.\n  preventCollision: _propTypes.default.bool,\n  // Use CSS transforms instead of top/left\n  useCSSTransforms: _propTypes.default.bool,\n  // parent layout transform scale\n  transformScale: _propTypes.default.number,\n  // If true, an external element can trigger onDrop callback with a specific grid position as a parameter\n  isDroppable: _propTypes.default.bool,\n  // Resize handle options\n  resizeHandles: resizeHandleAxesType,\n  resizeHandle: resizeHandleType,\n  //\n  // Callbacks\n  //\n\n  // Callback so you can save the layout. Calls after each drag & resize stops.\n  onLayoutChange: _propTypes.default.func,\n  // Calls when drag starts. Callback is of the signature (layout, oldItem, newItem, placeholder, e, ?node).\n  // All callbacks below have the same signature. 'start' and 'stop' callbacks omit the 'placeholder'.\n  onDragStart: _propTypes.default.func,\n  // Calls on each drag movement.\n  onDrag: _propTypes.default.func,\n  // Calls when drag is complete.\n  onDragStop: _propTypes.default.func,\n  //Calls when resize starts.\n  onResizeStart: _propTypes.default.func,\n  // Calls when resize movement happens.\n  onResize: _propTypes.default.func,\n  // Calls when resize is complete.\n  onResizeStop: _propTypes.default.func,\n  // Calls when some element is dropped.\n  onDrop: _propTypes.default.func,\n  //\n  // Other validations\n  //\n\n  droppingItem: (_propTypes.default.shape({\n    i: _propTypes.default.string.isRequired,\n    w: _propTypes.default.number.isRequired,\n    h: _propTypes.default.number.isRequired\n  }) /*: ReactPropsChainableTypeChecker*/),\n  // Children must not have duplicate keys.\n  children: function (props /*: Props*/, propName /*: string*/) {\n    const children = props[propName];\n\n    // Check children keys for duplicates. Throw if found.\n    const keys = {};\n    _react.default.Children.forEach(children, function (child) {\n      if (child?.key == null) return;\n      if (keys[child.key]) {\n        throw new Error('Duplicate child key \"' + child.key + '\" found! This will cause problems in ReactGridLayout.');\n      }\n      keys[child.key] = true;\n    });\n  },\n  // Optional ref for getting a reference for the wrapping div.\n  innerRef: _propTypes.default.any\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL1JlYWN0R3JpZExheW91dFByb3BUeXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLWxheW91dC9idWlsZC9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXMuanM/YzdhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVzaXplSGFuZGxlVHlwZSA9IGV4cG9ydHMucmVzaXplSGFuZGxlQXhlc1R5cGUgPSBleHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG4vKjo6IGltcG9ydCB0eXBlIHtcbiAgUmVmLFxuICBDaGlsZHJlbkFycmF5IGFzIFJlYWN0Q2hpbGRyZW5BcnJheSxcbiAgRWxlbWVudCBhcyBSZWFjdEVsZW1lbnRcbn0gZnJvbSBcInJlYWN0XCI7Ki9cbi8qOjogaW1wb3J0IHR5cGUge1xuICBEcmFnT3ZlckV2ZW50LFxuICBFdmVudENhbGxiYWNrLFxuICBDb21wYWN0VHlwZSxcbiAgTGF5b3V0LFxuICBMYXlvdXRJdGVtLFxuICBSZXNpemVIYW5kbGVBeGlzXG59IGZyb20gXCIuL3V0aWxzXCI7Ki9cbi8qOjogZXhwb3J0IHR5cGUgUmVhY3RSZWY8VDogSFRNTEVsZW1lbnQ+ID0ge3xcbiAgK2N1cnJlbnQ6IFQgfCBudWxsXG58fTsqL1xuLy8gdXRpbFxuLyo6OiBleHBvcnQgdHlwZSBSZXNpemVIYW5kbGUgPVxuICB8IFJlYWN0RWxlbWVudDxhbnk+XG4gIHwgKChcbiAgICAgIHJlc2l6ZUhhbmRsZUF4aXM6IFJlc2l6ZUhhbmRsZUF4aXMsXG4gICAgICByZWY6IFJlYWN0UmVmPEhUTUxFbGVtZW50PlxuICAgICkgPT4gUmVhY3RFbGVtZW50PGFueT4pOyovXG4vLyBEZWZpbmVzIHdoaWNoIHJlc2l6ZSBoYW5kbGVzIHNob3VsZCBiZSByZW5kZXJlZCAoZGVmYXVsdDogJ3NlJylcbi8vIEFsbG93cyBmb3IgYW55IGNvbWJpbmF0aW9uIG9mOlxuLy8gJ3MnIC0gU291dGggaGFuZGxlIChib3R0b20tY2VudGVyKVxuLy8gJ3cnIC0gV2VzdCBoYW5kbGUgKGxlZnQtY2VudGVyKVxuLy8gJ2UnIC0gRWFzdCBoYW5kbGUgKHJpZ2h0LWNlbnRlcilcbi8vICduJyAtIE5vcnRoIGhhbmRsZSAodG9wLWNlbnRlcilcbi8vICdzdycgLSBTb3V0aHdlc3QgaGFuZGxlIChib3R0b20tbGVmdClcbi8vICdudycgLSBOb3J0aHdlc3QgaGFuZGxlICh0b3AtbGVmdClcbi8vICdzZScgLSBTb3V0aGVhc3QgaGFuZGxlIChib3R0b20tcmlnaHQpXG4vLyAnbmUnIC0gTm9ydGhlYXN0IGhhbmRsZSAodG9wLXJpZ2h0KVxuY29uc3QgcmVzaXplSGFuZGxlQXhlc1R5cGUgLyo6IFJlYWN0UHJvcHNDaGFpbmFibGVUeXBlQ2hlY2tlciovID0gZXhwb3J0cy5yZXNpemVIYW5kbGVBeGVzVHlwZSA9IF9wcm9wVHlwZXMuZGVmYXVsdC5hcnJheU9mKF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbXCJzXCIsIFwid1wiLCBcImVcIiwgXCJuXCIsIFwic3dcIiwgXCJud1wiLCBcInNlXCIsIFwibmVcIl0pKTtcbi8vIEN1c3RvbSBjb21wb25lbnQgZm9yIHJlc2l6ZSBoYW5kbGVzXG5jb25zdCByZXNpemVIYW5kbGVUeXBlIC8qOiBSZWFjdFByb3BzQ2hhaW5hYmxlVHlwZUNoZWNrZXIqLyA9IGV4cG9ydHMucmVzaXplSGFuZGxlVHlwZSA9IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5ub2RlLCBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuY10pO1xuLyo6OiBleHBvcnQgdHlwZSBQcm9wcyA9IHt8XG4gIGNsYXNzTmFtZTogc3RyaW5nLFxuICBzdHlsZTogT2JqZWN0LFxuICB3aWR0aDogbnVtYmVyLFxuICBhdXRvU2l6ZTogYm9vbGVhbixcbiAgY29sczogbnVtYmVyLFxuICBkcmFnZ2FibGVDYW5jZWw6IHN0cmluZyxcbiAgZHJhZ2dhYmxlSGFuZGxlOiBzdHJpbmcsXG4gIHZlcnRpY2FsQ29tcGFjdDogYm9vbGVhbixcbiAgY29tcGFjdFR5cGU6IENvbXBhY3RUeXBlLFxuICBsYXlvdXQ6IExheW91dCxcbiAgbWFyZ2luOiBbbnVtYmVyLCBudW1iZXJdLFxuICBjb250YWluZXJQYWRkaW5nOiA/W251bWJlciwgbnVtYmVyXSxcbiAgcm93SGVpZ2h0OiBudW1iZXIsXG4gIG1heFJvd3M6IG51bWJlcixcbiAgaXNCb3VuZGVkOiBib29sZWFuLFxuICBpc0RyYWdnYWJsZTogYm9vbGVhbixcbiAgaXNSZXNpemFibGU6IGJvb2xlYW4sXG4gIGlzRHJvcHBhYmxlOiBib29sZWFuLFxuICBwcmV2ZW50Q29sbGlzaW9uOiBib29sZWFuLFxuICB1c2VDU1NUcmFuc2Zvcm1zOiBib29sZWFuLFxuICB0cmFuc2Zvcm1TY2FsZTogbnVtYmVyLFxuICBkcm9wcGluZ0l0ZW06ICRTaGFwZTxMYXlvdXRJdGVtPixcbiAgcmVzaXplSGFuZGxlczogUmVzaXplSGFuZGxlQXhpc1tdLFxuICByZXNpemVIYW5kbGU/OiBSZXNpemVIYW5kbGUsXG4gIGFsbG93T3ZlcmxhcDogYm9vbGVhbixcblxuICAvLyBDYWxsYmFja3NcbiAgb25MYXlvdXRDaGFuZ2U6IExheW91dCA9PiB2b2lkLFxuICBvbkRyYWc6IEV2ZW50Q2FsbGJhY2ssXG4gIG9uRHJhZ1N0YXJ0OiBFdmVudENhbGxiYWNrLFxuICBvbkRyYWdTdG9wOiBFdmVudENhbGxiYWNrLFxuICBvblJlc2l6ZTogRXZlbnRDYWxsYmFjayxcbiAgb25SZXNpemVTdGFydDogRXZlbnRDYWxsYmFjayxcbiAgb25SZXNpemVTdG9wOiBFdmVudENhbGxiYWNrLFxuICBvbkRyb3BEcmFnT3ZlcjogKGU6IERyYWdPdmVyRXZlbnQpID0+ID8oe3wgdz86IG51bWJlciwgaD86IG51bWJlciB8fSB8IGZhbHNlKSxcbiAgb25Ecm9wOiAobGF5b3V0OiBMYXlvdXQsIGl0ZW06ID9MYXlvdXRJdGVtLCBlOiBFdmVudCkgPT4gdm9pZCxcbiAgY2hpbGRyZW46IFJlYWN0Q2hpbGRyZW5BcnJheTxSZWFjdEVsZW1lbnQ8YW55Pj4sXG4gIGlubmVyUmVmPzogUmVmPFwiZGl2XCI+XG58fTsqL1xuLyo6OiBleHBvcnQgdHlwZSBEZWZhdWx0UHJvcHMgPSAkRGlmZjxcbiAgUHJvcHMsXG4gIHtcbiAgICBjaGlsZHJlbjogUmVhY3RDaGlsZHJlbkFycmF5PFJlYWN0RWxlbWVudDxhbnk+PixcbiAgICB3aWR0aDogbnVtYmVyXG4gIH1cbj47Ki9cbnZhciBfZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgLy9cbiAgLy8gQmFzaWMgcHJvcHNcbiAgLy9cbiAgY2xhc3NOYW1lOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICBzdHlsZTogX3Byb3BUeXBlcy5kZWZhdWx0Lm9iamVjdCxcbiAgLy8gVGhpcyBjYW4gYmUgc2V0IGV4cGxpY2l0bHkuIElmIGl0IGlzIG5vdCBzZXQsIGl0IHdpbGwgYXV0b21hdGljYWxseVxuICAvLyBiZSBzZXQgdG8gdGhlIGNvbnRhaW5lciB3aWR0aC4gTm90ZSB0aGF0IHJlc2l6ZXMgd2lsbCAqbm90KiBjYXVzZSB0aGlzIHRvIGFkanVzdC5cbiAgLy8gSWYgeW91IG5lZWQgdGhhdCBiZWhhdmlvciwgdXNlIFdpZHRoUHJvdmlkZXIuXG4gIHdpZHRoOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAvLyBJZiB0cnVlLCB0aGUgY29udGFpbmVyIGhlaWdodCBzd2VsbHMgYW5kIGNvbnRyYWN0cyB0byBmaXQgY29udGVudHNcbiAgYXV0b1NpemU6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvLyAjIG9mIGNvbHMuXG4gIGNvbHM6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gIC8vIEEgc2VsZWN0b3IgdGhhdCB3aWxsIG5vdCBiZSBkcmFnZ2FibGUuXG4gIGRyYWdnYWJsZUNhbmNlbDogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgLy8gQSBzZWxlY3RvciBmb3IgdGhlIGRyYWdnYWJsZSBoYW5kbGVyXG4gIGRyYWdnYWJsZUhhbmRsZTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgLy8gRGVwcmVjYXRlZFxuICB2ZXJ0aWNhbENvbXBhY3Q6IGZ1bmN0aW9uIChwcm9wcyAvKjogUHJvcHMqLykge1xuICAgIGlmIChwcm9wcy52ZXJ0aWNhbENvbXBhY3QgPT09IGZhbHNlICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICBcImB2ZXJ0aWNhbENvbXBhY3RgIG9uIDxSZWFjdEdyaWRMYXlvdXQ+IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBzb29uLiBcIiArICdVc2UgYGNvbXBhY3RUeXBlYDogXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCIgfCBudWxsLicpO1xuICAgIH1cbiAgfSxcbiAgLy8gQ2hvb3NlIHZlcnRpY2FsIG9yIGhvdGl6b250YWwgY29tcGFjdGlvblxuICBjb21wYWN0VHlwZTogKF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbXCJ2ZXJ0aWNhbFwiLCBcImhvcml6b250YWxcIl0pIC8qOiBSZWFjdFByb3BzQ2hhaW5hYmxlVHlwZUNoZWNrZXIqLyksXG4gIC8vIGxheW91dCBpcyBhbiBhcnJheSBvZiBvYmplY3Qgd2l0aCB0aGUgZm9ybWF0OlxuICAvLyB7eDogTnVtYmVyLCB5OiBOdW1iZXIsIHc6IE51bWJlciwgaDogTnVtYmVyLCBpOiBTdHJpbmd9XG4gIGxheW91dDogZnVuY3Rpb24gKHByb3BzIC8qOiBQcm9wcyovKSB7XG4gICAgdmFyIGxheW91dCA9IHByb3BzLmxheW91dDtcbiAgICAvLyBJIGhvcGUgeW91J3JlIHNldHRpbmcgdGhlIGRhdGEtZ3JpZCBwcm9wZXJ0eSBvbiB0aGUgZ3JpZCBpdGVtc1xuICAgIGlmIChsYXlvdXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIHJlcXVpcmUoXCIuL3V0aWxzXCIpLnZhbGlkYXRlTGF5b3V0KGxheW91dCwgXCJsYXlvdXRcIik7XG4gIH0sXG4gIC8vXG4gIC8vIEdyaWQgRGltZW5zaW9uc1xuICAvL1xuXG4gIC8vIE1hcmdpbiBiZXR3ZWVuIGl0ZW1zIFt4LCB5XSBpbiBweFxuICBtYXJnaW46IChfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyKSAvKjogUmVhY3RQcm9wc0NoYWluYWJsZVR5cGVDaGVja2VyKi8pLFxuICAvLyBQYWRkaW5nIGluc2lkZSB0aGUgY29udGFpbmVyIFt4LCB5XSBpbiBweFxuICBjb250YWluZXJQYWRkaW5nOiAoX3Byb3BUeXBlcy5kZWZhdWx0LmFycmF5T2YoX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcikgLyo6IFJlYWN0UHJvcHNDaGFpbmFibGVUeXBlQ2hlY2tlciovKSxcbiAgLy8gUm93cyBoYXZlIGEgc3RhdGljIGhlaWdodCwgYnV0IHlvdSBjYW4gY2hhbmdlIHRoaXMgYmFzZWQgb24gYnJlYWtwb2ludHMgaWYgeW91IGxpa2VcbiAgcm93SGVpZ2h0OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAvLyBEZWZhdWx0IEluZmluaXR5LCBidXQgeW91IGNhbiBzcGVjaWZ5IGEgbWF4IGhlcmUgaWYgeW91IGxpa2UuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIGlzbid0IGZ1bGx5IGZsZXNoZWQgb3V0IGFuZCB3b24ndCBlcnJvciBpZiB5b3Ugc3BlY2lmeSBhIGxheW91dCB0aGF0XG4gIC8vIGV4dGVuZHMgYmV5b25kIHRoZSByb3cgY2FwYWNpdHkuIEl0IHdpbGwsIGhvd2V2ZXIsIG5vdCBhbGxvdyB1c2VycyB0byBkcmFnL3Jlc2l6ZVxuICAvLyBhbiBpdGVtIHBhc3QgdGhlIGJhcnJpZXIuIFRoZXkgY2FuIHB1c2ggaXRlbXMgYmV5b25kIHRoZSBiYXJyaWVyLCB0aG91Z2guXG4gIC8vIEludGVudGlvbmFsbHkgbm90IGRvY3VtZW50ZWQgZm9yIHRoaXMgcmVhc29uLlxuICBtYXhSb3dzOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAvL1xuICAvLyBGbGFnc1xuICAvL1xuICBpc0JvdW5kZWQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICBpc0RyYWdnYWJsZTogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gIGlzUmVzaXphYmxlOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLy8gSWYgdHJ1ZSwgZ3JpZCBjYW4gYmUgcGxhY2VkIG9uZSBvdmVyIHRoZSBvdGhlci5cbiAgYWxsb3dPdmVybGFwOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLy8gSWYgdHJ1ZSwgZ3JpZCBpdGVtcyB3b24ndCBjaGFuZ2UgcG9zaXRpb24gd2hlbiBiZWluZyBkcmFnZ2VkIG92ZXIuXG4gIHByZXZlbnRDb2xsaXNpb246IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvLyBVc2UgQ1NTIHRyYW5zZm9ybXMgaW5zdGVhZCBvZiB0b3AvbGVmdFxuICB1c2VDU1NUcmFuc2Zvcm1zOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLy8gcGFyZW50IGxheW91dCB0cmFuc2Zvcm0gc2NhbGVcbiAgdHJhbnNmb3JtU2NhbGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gIC8vIElmIHRydWUsIGFuIGV4dGVybmFsIGVsZW1lbnQgY2FuIHRyaWdnZXIgb25Ecm9wIGNhbGxiYWNrIHdpdGggYSBzcGVjaWZpYyBncmlkIHBvc2l0aW9uIGFzIGEgcGFyYW1ldGVyXG4gIGlzRHJvcHBhYmxlOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLy8gUmVzaXplIGhhbmRsZSBvcHRpb25zXG4gIHJlc2l6ZUhhbmRsZXM6IHJlc2l6ZUhhbmRsZUF4ZXNUeXBlLFxuICByZXNpemVIYW5kbGU6IHJlc2l6ZUhhbmRsZVR5cGUsXG4gIC8vXG4gIC8vIENhbGxiYWNrc1xuICAvL1xuXG4gIC8vIENhbGxiYWNrIHNvIHlvdSBjYW4gc2F2ZSB0aGUgbGF5b3V0LiBDYWxscyBhZnRlciBlYWNoIGRyYWcgJiByZXNpemUgc3RvcHMuXG4gIG9uTGF5b3V0Q2hhbmdlOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLy8gQ2FsbHMgd2hlbiBkcmFnIHN0YXJ0cy4gQ2FsbGJhY2sgaXMgb2YgdGhlIHNpZ25hdHVyZSAobGF5b3V0LCBvbGRJdGVtLCBuZXdJdGVtLCBwbGFjZWhvbGRlciwgZSwgP25vZGUpLlxuICAvLyBBbGwgY2FsbGJhY2tzIGJlbG93IGhhdmUgdGhlIHNhbWUgc2lnbmF0dXJlLiAnc3RhcnQnIGFuZCAnc3RvcCcgY2FsbGJhY2tzIG9taXQgdGhlICdwbGFjZWhvbGRlcicuXG4gIG9uRHJhZ1N0YXJ0OiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLy8gQ2FsbHMgb24gZWFjaCBkcmFnIG1vdmVtZW50LlxuICBvbkRyYWc6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAvLyBDYWxscyB3aGVuIGRyYWcgaXMgY29tcGxldGUuXG4gIG9uRHJhZ1N0b3A6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAvL0NhbGxzIHdoZW4gcmVzaXplIHN0YXJ0cy5cbiAgb25SZXNpemVTdGFydDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8vIENhbGxzIHdoZW4gcmVzaXplIG1vdmVtZW50IGhhcHBlbnMuXG4gIG9uUmVzaXplOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLy8gQ2FsbHMgd2hlbiByZXNpemUgaXMgY29tcGxldGUuXG4gIG9uUmVzaXplU3RvcDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8vIENhbGxzIHdoZW4gc29tZSBlbGVtZW50IGlzIGRyb3BwZWQuXG4gIG9uRHJvcDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8vXG4gIC8vIE90aGVyIHZhbGlkYXRpb25zXG4gIC8vXG5cbiAgZHJvcHBpbmdJdGVtOiAoX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICBpOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgdzogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkLFxuICAgIGg6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZFxuICB9KSAvKjogUmVhY3RQcm9wc0NoYWluYWJsZVR5cGVDaGVja2VyKi8pLFxuICAvLyBDaGlsZHJlbiBtdXN0IG5vdCBoYXZlIGR1cGxpY2F0ZSBrZXlzLlxuICBjaGlsZHJlbjogZnVuY3Rpb24gKHByb3BzIC8qOiBQcm9wcyovLCBwcm9wTmFtZSAvKjogc3RyaW5nKi8pIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHByb3BzW3Byb3BOYW1lXTtcblxuICAgIC8vIENoZWNrIGNoaWxkcmVuIGtleXMgZm9yIGR1cGxpY2F0ZXMuIFRocm93IGlmIGZvdW5kLlxuICAgIGNvbnN0IGtleXMgPSB7fTtcbiAgICBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZD8ua2V5ID09IG51bGwpIHJldHVybjtcbiAgICAgIGlmIChrZXlzW2NoaWxkLmtleV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEdXBsaWNhdGUgY2hpbGQga2V5IFwiJyArIGNoaWxkLmtleSArICdcIiBmb3VuZCEgVGhpcyB3aWxsIGNhdXNlIHByb2JsZW1zIGluIFJlYWN0R3JpZExheW91dC4nKTtcbiAgICAgIH1cbiAgICAgIGtleXNbY2hpbGQua2V5XSA9IHRydWU7XG4gICAgfSk7XG4gIH0sXG4gIC8vIE9wdGlvbmFsIHJlZiBmb3IgZ2V0dGluZyBhIHJlZmVyZW5jZSBmb3IgdGhlIHdyYXBwaW5nIGRpdi5cbiAgaW5uZXJSZWY6IF9wcm9wVHlwZXMuZGVmYXVsdC5hbnlcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js\n");

/***/ }),

/***/ "../../node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"../../node_modules/prop-types/index.js\"));\nvar _fastEquals = __webpack_require__(/*! fast-equals */ \"../../node_modules/fast-equals/dist/fast-equals.js\");\nvar _utils = __webpack_require__(/*! ./utils */ \"../../node_modules/react-grid-layout/build/utils.js\");\nvar _responsiveUtils = __webpack_require__(/*! ./responsiveUtils */ \"../../node_modules/react-grid-layout/build/responsiveUtils.js\");\nvar _ReactGridLayout = _interopRequireDefault(__webpack_require__(/*! ./ReactGridLayout */ \"../../node_modules/react-grid-layout/build/ReactGridLayout.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); } /*:: import { type Layout, type Pick } from \"./utils\";*/ /*:: import { type ResponsiveLayout, type OnLayoutChangeCallback, type Breakpoints } from \"./responsiveUtils\";*/\n// $FlowFixMe[method-unbinding]\nconst type = obj => Object.prototype.toString.call(obj);\n\n/**\n * Get a value of margin or containerPadding.\n *\n * @param  {Array | Object} param Margin | containerPadding, e.g. [10, 10] | {lg: [10, 10], ...}.\n * @param  {String} breakpoint   Breakpoint: lg, md, sm, xs and etc.\n * @return {Array}\n */\nfunction getIndentationValue /*:: <T: ?[number, number]>*/(param /*: { [key: string]: T } | T*/, breakpoint /*: string*/) /*: T*/{\n  // $FlowIgnore TODO fix this typedef\n  if (param == null) return null;\n  // $FlowIgnore TODO fix this typedef\n  return Array.isArray(param) ? param : param[breakpoint];\n}\n/*:: type State = {\n  layout: Layout,\n  breakpoint: string,\n  cols: number,\n  layouts?: ResponsiveLayout<string>\n};*/\n/*:: type Props<Breakpoint: string = string> = {|\n  ...React.ElementConfig<typeof ReactGridLayout>,\n\n  // Responsive config\n  breakpoint?: ?Breakpoint,\n  breakpoints: Breakpoints<Breakpoint>,\n  cols: { [key: Breakpoint]: number },\n  layouts: ResponsiveLayout<Breakpoint>,\n  width: number,\n  margin: { [key: Breakpoint]: [number, number] } | [number, number],\n  /* prettier-ignore *-/\n  containerPadding: { [key: Breakpoint]: ?[number, number] } | ?[number, number],\n\n  // Callbacks\n  onBreakpointChange: (Breakpoint, cols: number) => void,\n  onLayoutChange: OnLayoutChangeCallback,\n  onWidthChange: (\n    containerWidth: number,\n    margin: [number, number],\n    cols: number,\n    containerPadding: ?[number, number]\n  ) => void\n|};*/\n/*:: type DefaultProps = Pick<\n  Props<>,\n  {|\n    allowOverlap: 0,\n    breakpoints: 0,\n    cols: 0,\n    containerPadding: 0,\n    layouts: 0,\n    margin: 0,\n    onBreakpointChange: 0,\n    onLayoutChange: 0,\n    onWidthChange: 0\n  |}\n>;*/\nclass ResponsiveReactGridLayout extends React.Component\n/*:: <\n  Props<>,\n  State\n>*/\n{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", this.generateInitialState());\n    // wrap layouts so we do not need to pass layouts to child\n    _defineProperty(this, \"onLayoutChange\", (layout /*: Layout*/) => {\n      this.props.onLayoutChange(layout, {\n        ...this.props.layouts,\n        [this.state.breakpoint]: layout\n      });\n    });\n  }\n  generateInitialState() /*: State*/{\n    const {\n      width,\n      breakpoints,\n      layouts,\n      cols\n    } = this.props;\n    const breakpoint = (0, _responsiveUtils.getBreakpointFromWidth)(breakpoints, width);\n    const colNo = (0, _responsiveUtils.getColsFromBreakpoint)(breakpoint, cols);\n    // verticalCompact compatibility, now deprecated\n    const compactType = this.props.verticalCompact === false ? null : this.props.compactType;\n    // Get the initial layout. This can tricky; we try to generate one however possible if one doesn't exist\n    // for this layout.\n    const initialLayout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(layouts, breakpoints, breakpoint, breakpoint, colNo, compactType);\n    return {\n      layout: initialLayout,\n      breakpoint: breakpoint,\n      cols: colNo\n    };\n  }\n  static getDerivedStateFromProps(nextProps /*: Props<*>*/, prevState /*: State*/) /*: ?$Shape<State>*/{\n    if (!(0, _fastEquals.deepEqual)(nextProps.layouts, prevState.layouts)) {\n      // Allow parent to set layouts directly.\n      const {\n        breakpoint,\n        cols\n      } = prevState;\n\n      // Since we're setting an entirely new layout object, we must generate a new responsive layout\n      // if one does not exist.\n      const newLayout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(nextProps.layouts, nextProps.breakpoints, breakpoint, breakpoint, cols, nextProps.compactType);\n      return {\n        layout: newLayout,\n        layouts: nextProps.layouts\n      };\n    }\n    return null;\n  }\n  componentDidUpdate(prevProps /*: Props<*>*/) {\n    // Allow parent to set width or breakpoint directly.\n    if (this.props.width != prevProps.width || this.props.breakpoint !== prevProps.breakpoint || !(0, _fastEquals.deepEqual)(this.props.breakpoints, prevProps.breakpoints) || !(0, _fastEquals.deepEqual)(this.props.cols, prevProps.cols)) {\n      this.onWidthChange(prevProps);\n    }\n  }\n  /**\n   * When the width changes work through breakpoints and reset state with the new width & breakpoint.\n   * Width changes are necessary to figure out the widget widths.\n   */\n  onWidthChange(prevProps /*: Props<*>*/) {\n    const {\n      breakpoints,\n      cols,\n      layouts,\n      compactType\n    } = this.props;\n    const newBreakpoint = this.props.breakpoint || (0, _responsiveUtils.getBreakpointFromWidth)(this.props.breakpoints, this.props.width);\n    const lastBreakpoint = this.state.breakpoint;\n    const newCols /*: number*/ = (0, _responsiveUtils.getColsFromBreakpoint)(newBreakpoint, cols);\n    const newLayouts = {\n      ...layouts\n    };\n\n    // Breakpoint change\n    if (lastBreakpoint !== newBreakpoint || prevProps.breakpoints !== breakpoints || prevProps.cols !== cols) {\n      // Preserve the current layout if the current breakpoint is not present in the next layouts.\n      if (!(lastBreakpoint in newLayouts)) newLayouts[lastBreakpoint] = (0, _utils.cloneLayout)(this.state.layout);\n\n      // Find or generate a new layout.\n      let layout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(newLayouts, breakpoints, newBreakpoint, lastBreakpoint, newCols, compactType);\n\n      // This adds missing items.\n      layout = (0, _utils.synchronizeLayoutWithChildren)(layout, this.props.children, newCols, compactType, this.props.allowOverlap);\n\n      // Store the new layout.\n      newLayouts[newBreakpoint] = layout;\n\n      // callbacks\n      this.props.onBreakpointChange(newBreakpoint, newCols);\n      this.props.onLayoutChange(layout, newLayouts);\n      this.setState({\n        breakpoint: newBreakpoint,\n        layout: layout,\n        cols: newCols\n      });\n    }\n    const margin = getIndentationValue(this.props.margin, newBreakpoint);\n    const containerPadding = getIndentationValue(this.props.containerPadding, newBreakpoint);\n\n    //call onWidthChange on every change of width, not only on breakpoint changes\n    this.props.onWidthChange(this.props.width, margin, newCols, containerPadding);\n  }\n  render() /*: React.Element<typeof ReactGridLayout>*/{\n    /* eslint-disable no-unused-vars */\n    const {\n      breakpoint,\n      breakpoints,\n      cols,\n      layouts,\n      margin,\n      containerPadding,\n      onBreakpointChange,\n      onLayoutChange,\n      onWidthChange,\n      ...other\n    } = this.props;\n    /* eslint-enable no-unused-vars */\n\n    return /*#__PURE__*/React.createElement(_ReactGridLayout.default, _extends({}, other, {\n      // $FlowIgnore should allow nullable here due to DefaultProps\n      margin: getIndentationValue(margin, this.state.breakpoint),\n      containerPadding: getIndentationValue(containerPadding, this.state.breakpoint),\n      onLayoutChange: this.onLayoutChange,\n      layout: this.state.layout,\n      cols: this.state.cols\n    }));\n  }\n}\nexports[\"default\"] = ResponsiveReactGridLayout;\n// This should only include propTypes needed in this code; RGL itself\n// will do validation of the rest props passed to it.\n_defineProperty(ResponsiveReactGridLayout, \"propTypes\", {\n  //\n  // Basic props\n  //\n\n  // Optional, but if you are managing width yourself you may want to set the breakpoint\n  // yourself as well.\n  breakpoint: _propTypes.default.string,\n  // {name: pxVal}, e.g. {lg: 1200, md: 996, sm: 768, xs: 480}\n  breakpoints: _propTypes.default.object,\n  allowOverlap: _propTypes.default.bool,\n  // # of cols. This is a breakpoint -> cols map\n  cols: _propTypes.default.object,\n  // # of margin. This is a breakpoint -> margin map\n  // e.g. { lg: [5, 5], md: [10, 10], sm: [15, 15] }\n  // Margin between items [x, y] in px\n  // e.g. [10, 10]\n  margin: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.object]),\n  // # of containerPadding. This is a breakpoint -> containerPadding map\n  // e.g. { lg: [5, 5], md: [10, 10], sm: [15, 15] }\n  // Padding inside the container [x, y] in px\n  // e.g. [10, 10]\n  containerPadding: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.object]),\n  // layouts is an object mapping breakpoints to layouts.\n  // e.g. {lg: Layout, md: Layout, ...}\n  layouts(props /*: Props<>*/, propName /*: string*/) {\n    if (type(props[propName]) !== \"[object Object]\") {\n      throw new Error(\"Layout property must be an object. Received: \" + type(props[propName]));\n    }\n    Object.keys(props[propName]).forEach(key => {\n      if (!(key in props.breakpoints)) {\n        throw new Error(\"Each key in layouts must align with a key in breakpoints.\");\n      }\n      (0, _utils.validateLayout)(props.layouts[key], \"layouts.\" + key);\n    });\n  },\n  // The width of this component.\n  // Required in this propTypes stanza because generateInitialState() will fail without it.\n  width: _propTypes.default.number.isRequired,\n  //\n  // Callbacks\n  //\n\n  // Calls back with breakpoint and new # cols\n  onBreakpointChange: _propTypes.default.func,\n  // Callback so you can save the layout.\n  // Calls back with (currentLayout, allLayouts). allLayouts are keyed by breakpoint.\n  onLayoutChange: _propTypes.default.func,\n  // Calls back with (containerWidth, margin, cols, containerPadding)\n  onWidthChange: _propTypes.default.func\n});\n_defineProperty(ResponsiveReactGridLayout, \"defaultProps\", {\n  breakpoints: {\n    lg: 1200,\n    md: 996,\n    sm: 768,\n    xs: 480,\n    xxs: 0\n  },\n  cols: {\n    lg: 12,\n    md: 10,\n    sm: 6,\n    xs: 4,\n    xxs: 2\n  },\n  containerPadding: {\n    lg: null,\n    md: null,\n    sm: null,\n    xs: null,\n    xxs: null\n  },\n  layouts: {},\n  margin: [10, 10],\n  allowOverlap: false,\n  onBreakpointChange: _utils.noop,\n  onLayoutChange: _utils.noop,\n  onWidthChange: _utils.noop\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL1Jlc3BvbnNpdmVSZWFjdEdyaWRMYXlvdXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLWxheW91dC9idWlsZC9SZXNwb25zaXZlUmVhY3RHcmlkTGF5b3V0LmpzP2Y5YmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbnZhciBfZmFzdEVxdWFscyA9IHJlcXVpcmUoXCJmYXN0LWVxdWFsc1wiKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBfcmVzcG9uc2l2ZVV0aWxzID0gcmVxdWlyZShcIi4vcmVzcG9uc2l2ZVV0aWxzXCIpO1xudmFyIF9SZWFjdEdyaWRMYXlvdXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1JlYWN0R3JpZExheW91dFwiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSB0eXBlb2YgZSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IGRlZmF1bHQ6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuLmRlZmF1bHQgPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH0gLyo6OiBpbXBvcnQgeyB0eXBlIExheW91dCwgdHlwZSBQaWNrIH0gZnJvbSBcIi4vdXRpbHNcIjsqLyAvKjo6IGltcG9ydCB7IHR5cGUgUmVzcG9uc2l2ZUxheW91dCwgdHlwZSBPbkxheW91dENoYW5nZUNhbGxiYWNrLCB0eXBlIEJyZWFrcG9pbnRzIH0gZnJvbSBcIi4vcmVzcG9uc2l2ZVV0aWxzXCI7Ki9cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbmNvbnN0IHR5cGUgPSBvYmogPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG5cbi8qKlxuICogR2V0IGEgdmFsdWUgb2YgbWFyZ2luIG9yIGNvbnRhaW5lclBhZGRpbmcuXG4gKlxuICogQHBhcmFtICB7QXJyYXkgfCBPYmplY3R9IHBhcmFtIE1hcmdpbiB8IGNvbnRhaW5lclBhZGRpbmcsIGUuZy4gWzEwLCAxMF0gfCB7bGc6IFsxMCwgMTBdLCAuLi59LlxuICogQHBhcmFtICB7U3RyaW5nfSBicmVha3BvaW50ICAgQnJlYWtwb2ludDogbGcsIG1kLCBzbSwgeHMgYW5kIGV0Yy5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBnZXRJbmRlbnRhdGlvblZhbHVlIC8qOjogPFQ6ID9bbnVtYmVyLCBudW1iZXJdPiovKHBhcmFtIC8qOiB7IFtrZXk6IHN0cmluZ106IFQgfSB8IFQqLywgYnJlYWtwb2ludCAvKjogc3RyaW5nKi8pIC8qOiBUKi97XG4gIC8vICRGbG93SWdub3JlIFRPRE8gZml4IHRoaXMgdHlwZWRlZlxuICBpZiAocGFyYW0gPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIC8vICRGbG93SWdub3JlIFRPRE8gZml4IHRoaXMgdHlwZWRlZlxuICByZXR1cm4gQXJyYXkuaXNBcnJheShwYXJhbSkgPyBwYXJhbSA6IHBhcmFtW2JyZWFrcG9pbnRdO1xufVxuLyo6OiB0eXBlIFN0YXRlID0ge1xuICBsYXlvdXQ6IExheW91dCxcbiAgYnJlYWtwb2ludDogc3RyaW5nLFxuICBjb2xzOiBudW1iZXIsXG4gIGxheW91dHM/OiBSZXNwb25zaXZlTGF5b3V0PHN0cmluZz5cbn07Ki9cbi8qOjogdHlwZSBQcm9wczxCcmVha3BvaW50OiBzdHJpbmcgPSBzdHJpbmc+ID0ge3xcbiAgLi4uUmVhY3QuRWxlbWVudENvbmZpZzx0eXBlb2YgUmVhY3RHcmlkTGF5b3V0PixcblxuICAvLyBSZXNwb25zaXZlIGNvbmZpZ1xuICBicmVha3BvaW50PzogP0JyZWFrcG9pbnQsXG4gIGJyZWFrcG9pbnRzOiBCcmVha3BvaW50czxCcmVha3BvaW50PixcbiAgY29sczogeyBba2V5OiBCcmVha3BvaW50XTogbnVtYmVyIH0sXG4gIGxheW91dHM6IFJlc3BvbnNpdmVMYXlvdXQ8QnJlYWtwb2ludD4sXG4gIHdpZHRoOiBudW1iZXIsXG4gIG1hcmdpbjogeyBba2V5OiBCcmVha3BvaW50XTogW251bWJlciwgbnVtYmVyXSB9IHwgW251bWJlciwgbnVtYmVyXSxcbiAgLyogcHJldHRpZXItaWdub3JlICotL1xuICBjb250YWluZXJQYWRkaW5nOiB7IFtrZXk6IEJyZWFrcG9pbnRdOiA/W251bWJlciwgbnVtYmVyXSB9IHwgP1tudW1iZXIsIG51bWJlcl0sXG5cbiAgLy8gQ2FsbGJhY2tzXG4gIG9uQnJlYWtwb2ludENoYW5nZTogKEJyZWFrcG9pbnQsIGNvbHM6IG51bWJlcikgPT4gdm9pZCxcbiAgb25MYXlvdXRDaGFuZ2U6IE9uTGF5b3V0Q2hhbmdlQ2FsbGJhY2ssXG4gIG9uV2lkdGhDaGFuZ2U6IChcbiAgICBjb250YWluZXJXaWR0aDogbnVtYmVyLFxuICAgIG1hcmdpbjogW251bWJlciwgbnVtYmVyXSxcbiAgICBjb2xzOiBudW1iZXIsXG4gICAgY29udGFpbmVyUGFkZGluZzogP1tudW1iZXIsIG51bWJlcl1cbiAgKSA9PiB2b2lkXG58fTsqL1xuLyo6OiB0eXBlIERlZmF1bHRQcm9wcyA9IFBpY2s8XG4gIFByb3BzPD4sXG4gIHt8XG4gICAgYWxsb3dPdmVybGFwOiAwLFxuICAgIGJyZWFrcG9pbnRzOiAwLFxuICAgIGNvbHM6IDAsXG4gICAgY29udGFpbmVyUGFkZGluZzogMCxcbiAgICBsYXlvdXRzOiAwLFxuICAgIG1hcmdpbjogMCxcbiAgICBvbkJyZWFrcG9pbnRDaGFuZ2U6IDAsXG4gICAgb25MYXlvdXRDaGFuZ2U6IDAsXG4gICAgb25XaWR0aENoYW5nZTogMFxuICB8fVxuPjsqL1xuY2xhc3MgUmVzcG9uc2l2ZVJlYWN0R3JpZExheW91dCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxuLyo6OiA8XG4gIFByb3BzPD4sXG4gIFN0YXRlXG4+Ki9cbntcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB0aGlzLmdlbmVyYXRlSW5pdGlhbFN0YXRlKCkpO1xuICAgIC8vIHdyYXAgbGF5b3V0cyBzbyB3ZSBkbyBub3QgbmVlZCB0byBwYXNzIGxheW91dHMgdG8gY2hpbGRcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkxheW91dENoYW5nZVwiLCAobGF5b3V0IC8qOiBMYXlvdXQqLykgPT4ge1xuICAgICAgdGhpcy5wcm9wcy5vbkxheW91dENoYW5nZShsYXlvdXQsIHtcbiAgICAgICAgLi4udGhpcy5wcm9wcy5sYXlvdXRzLFxuICAgICAgICBbdGhpcy5zdGF0ZS5icmVha3BvaW50XTogbGF5b3V0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBnZW5lcmF0ZUluaXRpYWxTdGF0ZSgpIC8qOiBTdGF0ZSove1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgYnJlYWtwb2ludHMsXG4gICAgICBsYXlvdXRzLFxuICAgICAgY29sc1xuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGJyZWFrcG9pbnQgPSAoMCwgX3Jlc3BvbnNpdmVVdGlscy5nZXRCcmVha3BvaW50RnJvbVdpZHRoKShicmVha3BvaW50cywgd2lkdGgpO1xuICAgIGNvbnN0IGNvbE5vID0gKDAsIF9yZXNwb25zaXZlVXRpbHMuZ2V0Q29sc0Zyb21CcmVha3BvaW50KShicmVha3BvaW50LCBjb2xzKTtcbiAgICAvLyB2ZXJ0aWNhbENvbXBhY3QgY29tcGF0aWJpbGl0eSwgbm93IGRlcHJlY2F0ZWRcbiAgICBjb25zdCBjb21wYWN0VHlwZSA9IHRoaXMucHJvcHMudmVydGljYWxDb21wYWN0ID09PSBmYWxzZSA/IG51bGwgOiB0aGlzLnByb3BzLmNvbXBhY3RUeXBlO1xuICAgIC8vIEdldCB0aGUgaW5pdGlhbCBsYXlvdXQuIFRoaXMgY2FuIHRyaWNreTsgd2UgdHJ5IHRvIGdlbmVyYXRlIG9uZSBob3dldmVyIHBvc3NpYmxlIGlmIG9uZSBkb2Vzbid0IGV4aXN0XG4gICAgLy8gZm9yIHRoaXMgbGF5b3V0LlxuICAgIGNvbnN0IGluaXRpYWxMYXlvdXQgPSAoMCwgX3Jlc3BvbnNpdmVVdGlscy5maW5kT3JHZW5lcmF0ZVJlc3BvbnNpdmVMYXlvdXQpKGxheW91dHMsIGJyZWFrcG9pbnRzLCBicmVha3BvaW50LCBicmVha3BvaW50LCBjb2xObywgY29tcGFjdFR5cGUpO1xuICAgIHJldHVybiB7XG4gICAgICBsYXlvdXQ6IGluaXRpYWxMYXlvdXQsXG4gICAgICBicmVha3BvaW50OiBicmVha3BvaW50LFxuICAgICAgY29sczogY29sTm9cbiAgICB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzIC8qOiBQcm9wczwqPiovLCBwcmV2U3RhdGUgLyo6IFN0YXRlKi8pIC8qOiA/JFNoYXBlPFN0YXRlPiove1xuICAgIGlmICghKDAsIF9mYXN0RXF1YWxzLmRlZXBFcXVhbCkobmV4dFByb3BzLmxheW91dHMsIHByZXZTdGF0ZS5sYXlvdXRzKSkge1xuICAgICAgLy8gQWxsb3cgcGFyZW50IHRvIHNldCBsYXlvdXRzIGRpcmVjdGx5LlxuICAgICAgY29uc3Qge1xuICAgICAgICBicmVha3BvaW50LFxuICAgICAgICBjb2xzXG4gICAgICB9ID0gcHJldlN0YXRlO1xuXG4gICAgICAvLyBTaW5jZSB3ZSdyZSBzZXR0aW5nIGFuIGVudGlyZWx5IG5ldyBsYXlvdXQgb2JqZWN0LCB3ZSBtdXN0IGdlbmVyYXRlIGEgbmV3IHJlc3BvbnNpdmUgbGF5b3V0XG4gICAgICAvLyBpZiBvbmUgZG9lcyBub3QgZXhpc3QuXG4gICAgICBjb25zdCBuZXdMYXlvdXQgPSAoMCwgX3Jlc3BvbnNpdmVVdGlscy5maW5kT3JHZW5lcmF0ZVJlc3BvbnNpdmVMYXlvdXQpKG5leHRQcm9wcy5sYXlvdXRzLCBuZXh0UHJvcHMuYnJlYWtwb2ludHMsIGJyZWFrcG9pbnQsIGJyZWFrcG9pbnQsIGNvbHMsIG5leHRQcm9wcy5jb21wYWN0VHlwZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYXlvdXQ6IG5ld0xheW91dCxcbiAgICAgICAgbGF5b3V0czogbmV4dFByb3BzLmxheW91dHNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMgLyo6IFByb3BzPCo+Ki8pIHtcbiAgICAvLyBBbGxvdyBwYXJlbnQgdG8gc2V0IHdpZHRoIG9yIGJyZWFrcG9pbnQgZGlyZWN0bHkuXG4gICAgaWYgKHRoaXMucHJvcHMud2lkdGggIT0gcHJldlByb3BzLndpZHRoIHx8IHRoaXMucHJvcHMuYnJlYWtwb2ludCAhPT0gcHJldlByb3BzLmJyZWFrcG9pbnQgfHwgISgwLCBfZmFzdEVxdWFscy5kZWVwRXF1YWwpKHRoaXMucHJvcHMuYnJlYWtwb2ludHMsIHByZXZQcm9wcy5icmVha3BvaW50cykgfHwgISgwLCBfZmFzdEVxdWFscy5kZWVwRXF1YWwpKHRoaXMucHJvcHMuY29scywgcHJldlByb3BzLmNvbHMpKSB7XG4gICAgICB0aGlzLm9uV2lkdGhDaGFuZ2UocHJldlByb3BzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHdpZHRoIGNoYW5nZXMgd29yayB0aHJvdWdoIGJyZWFrcG9pbnRzIGFuZCByZXNldCBzdGF0ZSB3aXRoIHRoZSBuZXcgd2lkdGggJiBicmVha3BvaW50LlxuICAgKiBXaWR0aCBjaGFuZ2VzIGFyZSBuZWNlc3NhcnkgdG8gZmlndXJlIG91dCB0aGUgd2lkZ2V0IHdpZHRocy5cbiAgICovXG4gIG9uV2lkdGhDaGFuZ2UocHJldlByb3BzIC8qOiBQcm9wczwqPiovKSB7XG4gICAgY29uc3Qge1xuICAgICAgYnJlYWtwb2ludHMsXG4gICAgICBjb2xzLFxuICAgICAgbGF5b3V0cyxcbiAgICAgIGNvbXBhY3RUeXBlXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgbmV3QnJlYWtwb2ludCA9IHRoaXMucHJvcHMuYnJlYWtwb2ludCB8fCAoMCwgX3Jlc3BvbnNpdmVVdGlscy5nZXRCcmVha3BvaW50RnJvbVdpZHRoKSh0aGlzLnByb3BzLmJyZWFrcG9pbnRzLCB0aGlzLnByb3BzLndpZHRoKTtcbiAgICBjb25zdCBsYXN0QnJlYWtwb2ludCA9IHRoaXMuc3RhdGUuYnJlYWtwb2ludDtcbiAgICBjb25zdCBuZXdDb2xzIC8qOiBudW1iZXIqLyA9ICgwLCBfcmVzcG9uc2l2ZVV0aWxzLmdldENvbHNGcm9tQnJlYWtwb2ludCkobmV3QnJlYWtwb2ludCwgY29scyk7XG4gICAgY29uc3QgbmV3TGF5b3V0cyA9IHtcbiAgICAgIC4uLmxheW91dHNcbiAgICB9O1xuXG4gICAgLy8gQnJlYWtwb2ludCBjaGFuZ2VcbiAgICBpZiAobGFzdEJyZWFrcG9pbnQgIT09IG5ld0JyZWFrcG9pbnQgfHwgcHJldlByb3BzLmJyZWFrcG9pbnRzICE9PSBicmVha3BvaW50cyB8fCBwcmV2UHJvcHMuY29scyAhPT0gY29scykge1xuICAgICAgLy8gUHJlc2VydmUgdGhlIGN1cnJlbnQgbGF5b3V0IGlmIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQgaXMgbm90IHByZXNlbnQgaW4gdGhlIG5leHQgbGF5b3V0cy5cbiAgICAgIGlmICghKGxhc3RCcmVha3BvaW50IGluIG5ld0xheW91dHMpKSBuZXdMYXlvdXRzW2xhc3RCcmVha3BvaW50XSA9ICgwLCBfdXRpbHMuY2xvbmVMYXlvdXQpKHRoaXMuc3RhdGUubGF5b3V0KTtcblxuICAgICAgLy8gRmluZCBvciBnZW5lcmF0ZSBhIG5ldyBsYXlvdXQuXG4gICAgICBsZXQgbGF5b3V0ID0gKDAsIF9yZXNwb25zaXZlVXRpbHMuZmluZE9yR2VuZXJhdGVSZXNwb25zaXZlTGF5b3V0KShuZXdMYXlvdXRzLCBicmVha3BvaW50cywgbmV3QnJlYWtwb2ludCwgbGFzdEJyZWFrcG9pbnQsIG5ld0NvbHMsIGNvbXBhY3RUeXBlKTtcblxuICAgICAgLy8gVGhpcyBhZGRzIG1pc3NpbmcgaXRlbXMuXG4gICAgICBsYXlvdXQgPSAoMCwgX3V0aWxzLnN5bmNocm9uaXplTGF5b3V0V2l0aENoaWxkcmVuKShsYXlvdXQsIHRoaXMucHJvcHMuY2hpbGRyZW4sIG5ld0NvbHMsIGNvbXBhY3RUeXBlLCB0aGlzLnByb3BzLmFsbG93T3ZlcmxhcCk7XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBuZXcgbGF5b3V0LlxuICAgICAgbmV3TGF5b3V0c1tuZXdCcmVha3BvaW50XSA9IGxheW91dDtcblxuICAgICAgLy8gY2FsbGJhY2tzXG4gICAgICB0aGlzLnByb3BzLm9uQnJlYWtwb2ludENoYW5nZShuZXdCcmVha3BvaW50LCBuZXdDb2xzKTtcbiAgICAgIHRoaXMucHJvcHMub25MYXlvdXRDaGFuZ2UobGF5b3V0LCBuZXdMYXlvdXRzKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBicmVha3BvaW50OiBuZXdCcmVha3BvaW50LFxuICAgICAgICBsYXlvdXQ6IGxheW91dCxcbiAgICAgICAgY29sczogbmV3Q29sc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1hcmdpbiA9IGdldEluZGVudGF0aW9uVmFsdWUodGhpcy5wcm9wcy5tYXJnaW4sIG5ld0JyZWFrcG9pbnQpO1xuICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmcgPSBnZXRJbmRlbnRhdGlvblZhbHVlKHRoaXMucHJvcHMuY29udGFpbmVyUGFkZGluZywgbmV3QnJlYWtwb2ludCk7XG5cbiAgICAvL2NhbGwgb25XaWR0aENoYW5nZSBvbiBldmVyeSBjaGFuZ2Ugb2Ygd2lkdGgsIG5vdCBvbmx5IG9uIGJyZWFrcG9pbnQgY2hhbmdlc1xuICAgIHRoaXMucHJvcHMub25XaWR0aENoYW5nZSh0aGlzLnByb3BzLndpZHRoLCBtYXJnaW4sIG5ld0NvbHMsIGNvbnRhaW5lclBhZGRpbmcpO1xuICB9XG4gIHJlbmRlcigpIC8qOiBSZWFjdC5FbGVtZW50PHR5cGVvZiBSZWFjdEdyaWRMYXlvdXQ+Ki97XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICBjb25zdCB7XG4gICAgICBicmVha3BvaW50LFxuICAgICAgYnJlYWtwb2ludHMsXG4gICAgICBjb2xzLFxuICAgICAgbGF5b3V0cyxcbiAgICAgIG1hcmdpbixcbiAgICAgIGNvbnRhaW5lclBhZGRpbmcsXG4gICAgICBvbkJyZWFrcG9pbnRDaGFuZ2UsXG4gICAgICBvbkxheW91dENoYW5nZSxcbiAgICAgIG9uV2lkdGhDaGFuZ2UsXG4gICAgICAuLi5vdGhlclxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChfUmVhY3RHcmlkTGF5b3V0LmRlZmF1bHQsIF9leHRlbmRzKHt9LCBvdGhlciwge1xuICAgICAgLy8gJEZsb3dJZ25vcmUgc2hvdWxkIGFsbG93IG51bGxhYmxlIGhlcmUgZHVlIHRvIERlZmF1bHRQcm9wc1xuICAgICAgbWFyZ2luOiBnZXRJbmRlbnRhdGlvblZhbHVlKG1hcmdpbiwgdGhpcy5zdGF0ZS5icmVha3BvaW50KSxcbiAgICAgIGNvbnRhaW5lclBhZGRpbmc6IGdldEluZGVudGF0aW9uVmFsdWUoY29udGFpbmVyUGFkZGluZywgdGhpcy5zdGF0ZS5icmVha3BvaW50KSxcbiAgICAgIG9uTGF5b3V0Q2hhbmdlOiB0aGlzLm9uTGF5b3V0Q2hhbmdlLFxuICAgICAgbGF5b3V0OiB0aGlzLnN0YXRlLmxheW91dCxcbiAgICAgIGNvbHM6IHRoaXMuc3RhdGUuY29sc1xuICAgIH0pKTtcbiAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUmVzcG9uc2l2ZVJlYWN0R3JpZExheW91dDtcbi8vIFRoaXMgc2hvdWxkIG9ubHkgaW5jbHVkZSBwcm9wVHlwZXMgbmVlZGVkIGluIHRoaXMgY29kZTsgUkdMIGl0c2VsZlxuLy8gd2lsbCBkbyB2YWxpZGF0aW9uIG9mIHRoZSByZXN0IHByb3BzIHBhc3NlZCB0byBpdC5cbl9kZWZpbmVQcm9wZXJ0eShSZXNwb25zaXZlUmVhY3RHcmlkTGF5b3V0LCBcInByb3BUeXBlc1wiLCB7XG4gIC8vXG4gIC8vIEJhc2ljIHByb3BzXG4gIC8vXG5cbiAgLy8gT3B0aW9uYWwsIGJ1dCBpZiB5b3UgYXJlIG1hbmFnaW5nIHdpZHRoIHlvdXJzZWxmIHlvdSBtYXkgd2FudCB0byBzZXQgdGhlIGJyZWFrcG9pbnRcbiAgLy8geW91cnNlbGYgYXMgd2VsbC5cbiAgYnJlYWtwb2ludDogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgLy8ge25hbWU6IHB4VmFsfSwgZS5nLiB7bGc6IDEyMDAsIG1kOiA5OTYsIHNtOiA3NjgsIHhzOiA0ODB9XG4gIGJyZWFrcG9pbnRzOiBfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0LFxuICBhbGxvd092ZXJsYXA6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvLyAjIG9mIGNvbHMuIFRoaXMgaXMgYSBicmVha3BvaW50IC0+IGNvbHMgbWFwXG4gIGNvbHM6IF9wcm9wVHlwZXMuZGVmYXVsdC5vYmplY3QsXG4gIC8vICMgb2YgbWFyZ2luLiBUaGlzIGlzIGEgYnJlYWtwb2ludCAtPiBtYXJnaW4gbWFwXG4gIC8vIGUuZy4geyBsZzogWzUsIDVdLCBtZDogWzEwLCAxMF0sIHNtOiBbMTUsIDE1XSB9XG4gIC8vIE1hcmdpbiBiZXR3ZWVuIGl0ZW1zIFt4LCB5XSBpbiBweFxuICAvLyBlLmcuIFsxMCwgMTBdXG4gIG1hcmdpbjogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0LmFycmF5LCBfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0XSksXG4gIC8vICMgb2YgY29udGFpbmVyUGFkZGluZy4gVGhpcyBpcyBhIGJyZWFrcG9pbnQgLT4gY29udGFpbmVyUGFkZGluZyBtYXBcbiAgLy8gZS5nLiB7IGxnOiBbNSwgNV0sIG1kOiBbMTAsIDEwXSwgc206IFsxNSwgMTVdIH1cbiAgLy8gUGFkZGluZyBpbnNpZGUgdGhlIGNvbnRhaW5lciBbeCwgeV0gaW4gcHhcbiAgLy8gZS5nLiBbMTAsIDEwXVxuICBjb250YWluZXJQYWRkaW5nOiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXksIF9wcm9wVHlwZXMuZGVmYXVsdC5vYmplY3RdKSxcbiAgLy8gbGF5b3V0cyBpcyBhbiBvYmplY3QgbWFwcGluZyBicmVha3BvaW50cyB0byBsYXlvdXRzLlxuICAvLyBlLmcuIHtsZzogTGF5b3V0LCBtZDogTGF5b3V0LCAuLi59XG4gIGxheW91dHMocHJvcHMgLyo6IFByb3BzPD4qLywgcHJvcE5hbWUgLyo6IHN0cmluZyovKSB7XG4gICAgaWYgKHR5cGUocHJvcHNbcHJvcE5hbWVdKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGF5b3V0IHByb3BlcnR5IG11c3QgYmUgYW4gb2JqZWN0LiBSZWNlaXZlZDogXCIgKyB0eXBlKHByb3BzW3Byb3BOYW1lXSkpO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhwcm9wc1twcm9wTmFtZV0pLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmICghKGtleSBpbiBwcm9wcy5icmVha3BvaW50cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWFjaCBrZXkgaW4gbGF5b3V0cyBtdXN0IGFsaWduIHdpdGggYSBrZXkgaW4gYnJlYWtwb2ludHMuXCIpO1xuICAgICAgfVxuICAgICAgKDAsIF91dGlscy52YWxpZGF0ZUxheW91dCkocHJvcHMubGF5b3V0c1trZXldLCBcImxheW91dHMuXCIgKyBrZXkpO1xuICAgIH0pO1xuICB9LFxuICAvLyBUaGUgd2lkdGggb2YgdGhpcyBjb21wb25lbnQuXG4gIC8vIFJlcXVpcmVkIGluIHRoaXMgcHJvcFR5cGVzIHN0YW56YSBiZWNhdXNlIGdlbmVyYXRlSW5pdGlhbFN0YXRlKCkgd2lsbCBmYWlsIHdpdGhvdXQgaXQuXG4gIHdpZHRoOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8vXG4gIC8vIENhbGxiYWNrc1xuICAvL1xuXG4gIC8vIENhbGxzIGJhY2sgd2l0aCBicmVha3BvaW50IGFuZCBuZXcgIyBjb2xzXG4gIG9uQnJlYWtwb2ludENoYW5nZTogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8vIENhbGxiYWNrIHNvIHlvdSBjYW4gc2F2ZSB0aGUgbGF5b3V0LlxuICAvLyBDYWxscyBiYWNrIHdpdGggKGN1cnJlbnRMYXlvdXQsIGFsbExheW91dHMpLiBhbGxMYXlvdXRzIGFyZSBrZXllZCBieSBicmVha3BvaW50LlxuICBvbkxheW91dENoYW5nZTogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8vIENhbGxzIGJhY2sgd2l0aCAoY29udGFpbmVyV2lkdGgsIG1hcmdpbiwgY29scywgY29udGFpbmVyUGFkZGluZylcbiAgb25XaWR0aENoYW5nZTogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmNcbn0pO1xuX2RlZmluZVByb3BlcnR5KFJlc3BvbnNpdmVSZWFjdEdyaWRMYXlvdXQsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgYnJlYWtwb2ludHM6IHtcbiAgICBsZzogMTIwMCxcbiAgICBtZDogOTk2LFxuICAgIHNtOiA3NjgsXG4gICAgeHM6IDQ4MCxcbiAgICB4eHM6IDBcbiAgfSxcbiAgY29sczoge1xuICAgIGxnOiAxMixcbiAgICBtZDogMTAsXG4gICAgc206IDYsXG4gICAgeHM6IDQsXG4gICAgeHhzOiAyXG4gIH0sXG4gIGNvbnRhaW5lclBhZGRpbmc6IHtcbiAgICBsZzogbnVsbCxcbiAgICBtZDogbnVsbCxcbiAgICBzbTogbnVsbCxcbiAgICB4czogbnVsbCxcbiAgICB4eHM6IG51bGxcbiAgfSxcbiAgbGF5b3V0czoge30sXG4gIG1hcmdpbjogWzEwLCAxMF0sXG4gIGFsbG93T3ZlcmxhcDogZmFsc2UsXG4gIG9uQnJlYWtwb2ludENoYW5nZTogX3V0aWxzLm5vb3AsXG4gIG9uTGF5b3V0Q2hhbmdlOiBfdXRpbHMubm9vcCxcbiAgb25XaWR0aENoYW5nZTogX3V0aWxzLm5vb3Bcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js\n");

/***/ }),

/***/ "../../node_modules/react-grid-layout/build/calculateUtils.js":
/*!********************************************************************!*\
  !*** ../../node_modules/react-grid-layout/build/calculateUtils.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.calcGridColWidth = calcGridColWidth;\nexports.calcGridItemPosition = calcGridItemPosition;\nexports.calcGridItemWHPx = calcGridItemWHPx;\nexports.calcWH = calcWH;\nexports.calcXY = calcXY;\nexports.clamp = clamp;\n/*:: import type { Position } from \"./utils\";*/\n/*:: export type PositionParams = {\n  margin: [number, number],\n  containerPadding: [number, number],\n  containerWidth: number,\n  cols: number,\n  rowHeight: number,\n  maxRows: number\n};*/\n// Helper for generating column width\nfunction calcGridColWidth(positionParams /*: PositionParams*/) /*: number*/{\n  const {\n    margin,\n    containerPadding,\n    containerWidth,\n    cols\n  } = positionParams;\n  return (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols;\n}\n\n// This can either be called:\n// calcGridItemWHPx(w, colWidth, margin[0])\n// or\n// calcGridItemWHPx(h, rowHeight, margin[1])\nfunction calcGridItemWHPx(gridUnits /*: number*/, colOrRowSize /*: number*/, marginPx /*: number*/) /*: number*/{\n  // 0 * Infinity === NaN, which causes problems with resize contraints\n  if (!Number.isFinite(gridUnits)) return gridUnits;\n  return Math.round(colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx);\n}\n\n/**\n * Return position on the page given an x, y, w, h.\n * left, top, width, height are all in pixels.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number}  x                      X coordinate in grid units.\n * @param  {Number}  y                      Y coordinate in grid units.\n * @param  {Number}  w                      W coordinate in grid units.\n * @param  {Number}  h                      H coordinate in grid units.\n * @return {Position}                       Object containing coords.\n */\nfunction calcGridItemPosition(positionParams /*: PositionParams*/, x /*: number*/, y /*: number*/, w /*: number*/, h /*: number*/, state /*: ?Object*/) /*: Position*/{\n  const {\n    margin,\n    containerPadding,\n    rowHeight\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n  const out = {};\n\n  // If resizing, use the exact width and height as returned from resizing callbacks.\n  if (state && state.resizing) {\n    out.width = Math.round(state.resizing.width);\n    out.height = Math.round(state.resizing.height);\n  }\n  // Otherwise, calculate from grid units.\n  else {\n    out.width = calcGridItemWHPx(w, colWidth, margin[0]);\n    out.height = calcGridItemWHPx(h, rowHeight, margin[1]);\n  }\n\n  // If dragging, use the exact width and height as returned from dragging callbacks.\n  if (state && state.dragging) {\n    out.top = Math.round(state.dragging.top);\n    out.left = Math.round(state.dragging.left);\n  } else if (state && state.resizing && typeof state.resizing.top === \"number\" && typeof state.resizing.left === \"number\") {\n    out.top = Math.round(state.resizing.top);\n    out.left = Math.round(state.resizing.left);\n  }\n  // Otherwise, calculate from grid units.\n  else {\n    out.top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);\n    out.left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);\n  }\n  return out;\n}\n\n/**\n * Translate x and y coordinates from pixels to grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number} top                     Top position (relative to parent) in pixels.\n * @param  {Number} left                    Left position (relative to parent) in pixels.\n * @param  {Number} w                       W coordinate in grid units.\n * @param  {Number} h                       H coordinate in grid units.\n * @return {Object}                         x and y in grid units.\n */\nfunction calcXY(positionParams /*: PositionParams*/, top /*: number*/, left /*: number*/, w /*: number*/, h /*: number*/) /*: { x: number, y: number }*/{\n  const {\n    margin,\n    containerPadding,\n    cols,\n    rowHeight,\n    maxRows\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  // left = containerPaddingX + x * (colWidth + marginX)\n  // x * (colWidth + marginX) = left - containerPaddingX\n  // x = (left - containerPaddingX) / (colWidth + marginX)\n  let x = Math.round((left - containerPadding[0]) / (colWidth + margin[0]));\n  let y = Math.round((top - containerPadding[1]) / (rowHeight + margin[1]));\n\n  // Capping\n  x = clamp(x, 0, cols - w);\n  y = clamp(y, 0, maxRows - h);\n  return {\n    x,\n    y\n  };\n}\n\n/**\n * Given a height and width in pixel values, calculate grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calcluations.\n * @param  {Number} height                  Height in pixels.\n * @param  {Number} width                   Width in pixels.\n * @param  {Number} x                       X coordinate in grid units.\n * @param  {Number} y                       Y coordinate in grid units.\n * @param {String} handle Resize Handle.\n * @return {Object}                         w, h as grid units.\n */\nfunction calcWH(positionParams /*: PositionParams*/, width /*: number*/, height /*: number*/, x /*: number*/, y /*: number*/, handle /*: string*/) /*: { w: number, h: number }*/{\n  const {\n    margin,\n    maxRows,\n    cols,\n    rowHeight\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  // width = colWidth * w - (margin * (w - 1))\n  // ...\n  // w = (width + margin) / (colWidth + margin)\n  let w = Math.round((width + margin[0]) / (colWidth + margin[0]));\n  let h = Math.round((height + margin[1]) / (rowHeight + margin[1]));\n\n  // Capping\n  let _w = clamp(w, 0, cols - x);\n  let _h = clamp(h, 0, maxRows - y);\n  if ([\"sw\", \"w\", \"nw\"].indexOf(handle) !== -1) {\n    _w = clamp(w, 0, cols);\n  }\n  if ([\"nw\", \"n\", \"ne\"].indexOf(handle) !== -1) {\n    _h = clamp(h, 0, maxRows);\n  }\n  return {\n    w: _w,\n    h: _h\n  };\n}\n\n// Similar to _.clamp\nfunction clamp(num /*: number*/, lowerBound /*: number*/, upperBound /*: number*/) /*: number*/{\n  return Math.max(Math.min(num, upperBound), lowerBound);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL2NhbGN1bGF0ZVV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL2NhbGN1bGF0ZVV0aWxzLmpzPzMyNGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNhbGNHcmlkQ29sV2lkdGggPSBjYWxjR3JpZENvbFdpZHRoO1xuZXhwb3J0cy5jYWxjR3JpZEl0ZW1Qb3NpdGlvbiA9IGNhbGNHcmlkSXRlbVBvc2l0aW9uO1xuZXhwb3J0cy5jYWxjR3JpZEl0ZW1XSFB4ID0gY2FsY0dyaWRJdGVtV0hQeDtcbmV4cG9ydHMuY2FsY1dIID0gY2FsY1dIO1xuZXhwb3J0cy5jYWxjWFkgPSBjYWxjWFk7XG5leHBvcnRzLmNsYW1wID0gY2xhbXA7XG4vKjo6IGltcG9ydCB0eXBlIHsgUG9zaXRpb24gfSBmcm9tIFwiLi91dGlsc1wiOyovXG4vKjo6IGV4cG9ydCB0eXBlIFBvc2l0aW9uUGFyYW1zID0ge1xuICBtYXJnaW46IFtudW1iZXIsIG51bWJlcl0sXG4gIGNvbnRhaW5lclBhZGRpbmc6IFtudW1iZXIsIG51bWJlcl0sXG4gIGNvbnRhaW5lcldpZHRoOiBudW1iZXIsXG4gIGNvbHM6IG51bWJlcixcbiAgcm93SGVpZ2h0OiBudW1iZXIsXG4gIG1heFJvd3M6IG51bWJlclxufTsqL1xuLy8gSGVscGVyIGZvciBnZW5lcmF0aW5nIGNvbHVtbiB3aWR0aFxuZnVuY3Rpb24gY2FsY0dyaWRDb2xXaWR0aChwb3NpdGlvblBhcmFtcyAvKjogUG9zaXRpb25QYXJhbXMqLykgLyo6IG51bWJlciove1xuICBjb25zdCB7XG4gICAgbWFyZ2luLFxuICAgIGNvbnRhaW5lclBhZGRpbmcsXG4gICAgY29udGFpbmVyV2lkdGgsXG4gICAgY29sc1xuICB9ID0gcG9zaXRpb25QYXJhbXM7XG4gIHJldHVybiAoY29udGFpbmVyV2lkdGggLSBtYXJnaW5bMF0gKiAoY29scyAtIDEpIC0gY29udGFpbmVyUGFkZGluZ1swXSAqIDIpIC8gY29scztcbn1cblxuLy8gVGhpcyBjYW4gZWl0aGVyIGJlIGNhbGxlZDpcbi8vIGNhbGNHcmlkSXRlbVdIUHgodywgY29sV2lkdGgsIG1hcmdpblswXSlcbi8vIG9yXG4vLyBjYWxjR3JpZEl0ZW1XSFB4KGgsIHJvd0hlaWdodCwgbWFyZ2luWzFdKVxuZnVuY3Rpb24gY2FsY0dyaWRJdGVtV0hQeChncmlkVW5pdHMgLyo6IG51bWJlciovLCBjb2xPclJvd1NpemUgLyo6IG51bWJlciovLCBtYXJnaW5QeCAvKjogbnVtYmVyKi8pIC8qOiBudW1iZXIqL3tcbiAgLy8gMCAqIEluZmluaXR5ID09PSBOYU4sIHdoaWNoIGNhdXNlcyBwcm9ibGVtcyB3aXRoIHJlc2l6ZSBjb250cmFpbnRzXG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGdyaWRVbml0cykpIHJldHVybiBncmlkVW5pdHM7XG4gIHJldHVybiBNYXRoLnJvdW5kKGNvbE9yUm93U2l6ZSAqIGdyaWRVbml0cyArIE1hdGgubWF4KDAsIGdyaWRVbml0cyAtIDEpICogbWFyZ2luUHgpO1xufVxuXG4vKipcbiAqIFJldHVybiBwb3NpdGlvbiBvbiB0aGUgcGFnZSBnaXZlbiBhbiB4LCB5LCB3LCBoLlxuICogbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IGFyZSBhbGwgaW4gcGl4ZWxzLlxuICogQHBhcmFtICB7UG9zaXRpb25QYXJhbXN9IHBvc2l0aW9uUGFyYW1zICBQYXJhbWV0ZXJzIG9mIGdyaWQgbmVlZGVkIGZvciBjb29yZGluYXRlcyBjYWxjdWxhdGlvbnMuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICB4ICAgICAgICAgICAgICAgICAgICAgIFggY29vcmRpbmF0ZSBpbiBncmlkIHVuaXRzLlxuICogQHBhcmFtICB7TnVtYmVyfSAgeSAgICAgICAgICAgICAgICAgICAgICBZIGNvb3JkaW5hdGUgaW4gZ3JpZCB1bml0cy5cbiAqIEBwYXJhbSAge051bWJlcn0gIHcgICAgICAgICAgICAgICAgICAgICAgVyBjb29yZGluYXRlIGluIGdyaWQgdW5pdHMuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBoICAgICAgICAgICAgICAgICAgICAgIEggY29vcmRpbmF0ZSBpbiBncmlkIHVuaXRzLlxuICogQHJldHVybiB7UG9zaXRpb259ICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyBjb29yZHMuXG4gKi9cbmZ1bmN0aW9uIGNhbGNHcmlkSXRlbVBvc2l0aW9uKHBvc2l0aW9uUGFyYW1zIC8qOiBQb3NpdGlvblBhcmFtcyovLCB4IC8qOiBudW1iZXIqLywgeSAvKjogbnVtYmVyKi8sIHcgLyo6IG51bWJlciovLCBoIC8qOiBudW1iZXIqLywgc3RhdGUgLyo6ID9PYmplY3QqLykgLyo6IFBvc2l0aW9uKi97XG4gIGNvbnN0IHtcbiAgICBtYXJnaW4sXG4gICAgY29udGFpbmVyUGFkZGluZyxcbiAgICByb3dIZWlnaHRcbiAgfSA9IHBvc2l0aW9uUGFyYW1zO1xuICBjb25zdCBjb2xXaWR0aCA9IGNhbGNHcmlkQ29sV2lkdGgocG9zaXRpb25QYXJhbXMpO1xuICBjb25zdCBvdXQgPSB7fTtcblxuICAvLyBJZiByZXNpemluZywgdXNlIHRoZSBleGFjdCB3aWR0aCBhbmQgaGVpZ2h0IGFzIHJldHVybmVkIGZyb20gcmVzaXppbmcgY2FsbGJhY2tzLlxuICBpZiAoc3RhdGUgJiYgc3RhdGUucmVzaXppbmcpIHtcbiAgICBvdXQud2lkdGggPSBNYXRoLnJvdW5kKHN0YXRlLnJlc2l6aW5nLndpZHRoKTtcbiAgICBvdXQuaGVpZ2h0ID0gTWF0aC5yb3VuZChzdGF0ZS5yZXNpemluZy5oZWlnaHQpO1xuICB9XG4gIC8vIE90aGVyd2lzZSwgY2FsY3VsYXRlIGZyb20gZ3JpZCB1bml0cy5cbiAgZWxzZSB7XG4gICAgb3V0LndpZHRoID0gY2FsY0dyaWRJdGVtV0hQeCh3LCBjb2xXaWR0aCwgbWFyZ2luWzBdKTtcbiAgICBvdXQuaGVpZ2h0ID0gY2FsY0dyaWRJdGVtV0hQeChoLCByb3dIZWlnaHQsIG1hcmdpblsxXSk7XG4gIH1cblxuICAvLyBJZiBkcmFnZ2luZywgdXNlIHRoZSBleGFjdCB3aWR0aCBhbmQgaGVpZ2h0IGFzIHJldHVybmVkIGZyb20gZHJhZ2dpbmcgY2FsbGJhY2tzLlxuICBpZiAoc3RhdGUgJiYgc3RhdGUuZHJhZ2dpbmcpIHtcbiAgICBvdXQudG9wID0gTWF0aC5yb3VuZChzdGF0ZS5kcmFnZ2luZy50b3ApO1xuICAgIG91dC5sZWZ0ID0gTWF0aC5yb3VuZChzdGF0ZS5kcmFnZ2luZy5sZWZ0KTtcbiAgfSBlbHNlIGlmIChzdGF0ZSAmJiBzdGF0ZS5yZXNpemluZyAmJiB0eXBlb2Ygc3RhdGUucmVzaXppbmcudG9wID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBzdGF0ZS5yZXNpemluZy5sZWZ0ID09PSBcIm51bWJlclwiKSB7XG4gICAgb3V0LnRvcCA9IE1hdGgucm91bmQoc3RhdGUucmVzaXppbmcudG9wKTtcbiAgICBvdXQubGVmdCA9IE1hdGgucm91bmQoc3RhdGUucmVzaXppbmcubGVmdCk7XG4gIH1cbiAgLy8gT3RoZXJ3aXNlLCBjYWxjdWxhdGUgZnJvbSBncmlkIHVuaXRzLlxuICBlbHNlIHtcbiAgICBvdXQudG9wID0gTWF0aC5yb3VuZCgocm93SGVpZ2h0ICsgbWFyZ2luWzFdKSAqIHkgKyBjb250YWluZXJQYWRkaW5nWzFdKTtcbiAgICBvdXQubGVmdCA9IE1hdGgucm91bmQoKGNvbFdpZHRoICsgbWFyZ2luWzBdKSAqIHggKyBjb250YWluZXJQYWRkaW5nWzBdKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGZyb20gcGl4ZWxzIHRvIGdyaWQgdW5pdHMuXG4gKiBAcGFyYW0gIHtQb3NpdGlvblBhcmFtc30gcG9zaXRpb25QYXJhbXMgIFBhcmFtZXRlcnMgb2YgZ3JpZCBuZWVkZWQgZm9yIGNvb3JkaW5hdGVzIGNhbGN1bGF0aW9ucy5cbiAqIEBwYXJhbSAge051bWJlcn0gdG9wICAgICAgICAgICAgICAgICAgICAgVG9wIHBvc2l0aW9uIChyZWxhdGl2ZSB0byBwYXJlbnQpIGluIHBpeGVscy5cbiAqIEBwYXJhbSAge051bWJlcn0gbGVmdCAgICAgICAgICAgICAgICAgICAgTGVmdCBwb3NpdGlvbiAocmVsYXRpdmUgdG8gcGFyZW50KSBpbiBwaXhlbHMuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHcgICAgICAgICAgICAgICAgICAgICAgIFcgY29vcmRpbmF0ZSBpbiBncmlkIHVuaXRzLlxuICogQHBhcmFtICB7TnVtYmVyfSBoICAgICAgICAgICAgICAgICAgICAgICBIIGNvb3JkaW5hdGUgaW4gZ3JpZCB1bml0cy5cbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgeCBhbmQgeSBpbiBncmlkIHVuaXRzLlxuICovXG5mdW5jdGlvbiBjYWxjWFkocG9zaXRpb25QYXJhbXMgLyo6IFBvc2l0aW9uUGFyYW1zKi8sIHRvcCAvKjogbnVtYmVyKi8sIGxlZnQgLyo6IG51bWJlciovLCB3IC8qOiBudW1iZXIqLywgaCAvKjogbnVtYmVyKi8pIC8qOiB7IHg6IG51bWJlciwgeTogbnVtYmVyIH0qL3tcbiAgY29uc3Qge1xuICAgIG1hcmdpbixcbiAgICBjb250YWluZXJQYWRkaW5nLFxuICAgIGNvbHMsXG4gICAgcm93SGVpZ2h0LFxuICAgIG1heFJvd3NcbiAgfSA9IHBvc2l0aW9uUGFyYW1zO1xuICBjb25zdCBjb2xXaWR0aCA9IGNhbGNHcmlkQ29sV2lkdGgocG9zaXRpb25QYXJhbXMpO1xuXG4gIC8vIGxlZnQgPSBjb250YWluZXJQYWRkaW5nWCArIHggKiAoY29sV2lkdGggKyBtYXJnaW5YKVxuICAvLyB4ICogKGNvbFdpZHRoICsgbWFyZ2luWCkgPSBsZWZ0IC0gY29udGFpbmVyUGFkZGluZ1hcbiAgLy8geCA9IChsZWZ0IC0gY29udGFpbmVyUGFkZGluZ1gpIC8gKGNvbFdpZHRoICsgbWFyZ2luWClcbiAgbGV0IHggPSBNYXRoLnJvdW5kKChsZWZ0IC0gY29udGFpbmVyUGFkZGluZ1swXSkgLyAoY29sV2lkdGggKyBtYXJnaW5bMF0pKTtcbiAgbGV0IHkgPSBNYXRoLnJvdW5kKCh0b3AgLSBjb250YWluZXJQYWRkaW5nWzFdKSAvIChyb3dIZWlnaHQgKyBtYXJnaW5bMV0pKTtcblxuICAvLyBDYXBwaW5nXG4gIHggPSBjbGFtcCh4LCAwLCBjb2xzIC0gdyk7XG4gIHkgPSBjbGFtcCh5LCAwLCBtYXhSb3dzIC0gaCk7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbi8qKlxuICogR2l2ZW4gYSBoZWlnaHQgYW5kIHdpZHRoIGluIHBpeGVsIHZhbHVlcywgY2FsY3VsYXRlIGdyaWQgdW5pdHMuXG4gKiBAcGFyYW0gIHtQb3NpdGlvblBhcmFtc30gcG9zaXRpb25QYXJhbXMgIFBhcmFtZXRlcnMgb2YgZ3JpZCBuZWVkZWQgZm9yIGNvb3JkaW5hdGVzIGNhbGNsdWF0aW9ucy5cbiAqIEBwYXJhbSAge051bWJlcn0gaGVpZ2h0ICAgICAgICAgICAgICAgICAgSGVpZ2h0IGluIHBpeGVscy5cbiAqIEBwYXJhbSAge051bWJlcn0gd2lkdGggICAgICAgICAgICAgICAgICAgV2lkdGggaW4gcGl4ZWxzLlxuICogQHBhcmFtICB7TnVtYmVyfSB4ICAgICAgICAgICAgICAgICAgICAgICBYIGNvb3JkaW5hdGUgaW4gZ3JpZCB1bml0cy5cbiAqIEBwYXJhbSAge051bWJlcn0geSAgICAgICAgICAgICAgICAgICAgICAgWSBjb29yZGluYXRlIGluIGdyaWQgdW5pdHMuXG4gKiBAcGFyYW0ge1N0cmluZ30gaGFuZGxlIFJlc2l6ZSBIYW5kbGUuXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgIHcsIGggYXMgZ3JpZCB1bml0cy5cbiAqL1xuZnVuY3Rpb24gY2FsY1dIKHBvc2l0aW9uUGFyYW1zIC8qOiBQb3NpdGlvblBhcmFtcyovLCB3aWR0aCAvKjogbnVtYmVyKi8sIGhlaWdodCAvKjogbnVtYmVyKi8sIHggLyo6IG51bWJlciovLCB5IC8qOiBudW1iZXIqLywgaGFuZGxlIC8qOiBzdHJpbmcqLykgLyo6IHsgdzogbnVtYmVyLCBoOiBudW1iZXIgfSove1xuICBjb25zdCB7XG4gICAgbWFyZ2luLFxuICAgIG1heFJvd3MsXG4gICAgY29scyxcbiAgICByb3dIZWlnaHRcbiAgfSA9IHBvc2l0aW9uUGFyYW1zO1xuICBjb25zdCBjb2xXaWR0aCA9IGNhbGNHcmlkQ29sV2lkdGgocG9zaXRpb25QYXJhbXMpO1xuXG4gIC8vIHdpZHRoID0gY29sV2lkdGggKiB3IC0gKG1hcmdpbiAqICh3IC0gMSkpXG4gIC8vIC4uLlxuICAvLyB3ID0gKHdpZHRoICsgbWFyZ2luKSAvIChjb2xXaWR0aCArIG1hcmdpbilcbiAgbGV0IHcgPSBNYXRoLnJvdW5kKCh3aWR0aCArIG1hcmdpblswXSkgLyAoY29sV2lkdGggKyBtYXJnaW5bMF0pKTtcbiAgbGV0IGggPSBNYXRoLnJvdW5kKChoZWlnaHQgKyBtYXJnaW5bMV0pIC8gKHJvd0hlaWdodCArIG1hcmdpblsxXSkpO1xuXG4gIC8vIENhcHBpbmdcbiAgbGV0IF93ID0gY2xhbXAodywgMCwgY29scyAtIHgpO1xuICBsZXQgX2ggPSBjbGFtcChoLCAwLCBtYXhSb3dzIC0geSk7XG4gIGlmIChbXCJzd1wiLCBcIndcIiwgXCJud1wiXS5pbmRleE9mKGhhbmRsZSkgIT09IC0xKSB7XG4gICAgX3cgPSBjbGFtcCh3LCAwLCBjb2xzKTtcbiAgfVxuICBpZiAoW1wibndcIiwgXCJuXCIsIFwibmVcIl0uaW5kZXhPZihoYW5kbGUpICE9PSAtMSkge1xuICAgIF9oID0gY2xhbXAoaCwgMCwgbWF4Um93cyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3OiBfdyxcbiAgICBoOiBfaFxuICB9O1xufVxuXG4vLyBTaW1pbGFyIHRvIF8uY2xhbXBcbmZ1bmN0aW9uIGNsYW1wKG51bSAvKjogbnVtYmVyKi8sIGxvd2VyQm91bmQgLyo6IG51bWJlciovLCB1cHBlckJvdW5kIC8qOiBudW1iZXIqLykgLyo6IG51bWJlciove1xuICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obnVtLCB1cHBlckJvdW5kKSwgbG93ZXJCb3VuZCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/react-grid-layout/build/calculateUtils.js\n");

/***/ }),

/***/ "../../node_modules/react-grid-layout/build/components/WidthProvider.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/react-grid-layout/build/components/WidthProvider.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = WidthProvideRGL;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"../../node_modules/prop-types/index.js\"));\nvar _resizeObserverPolyfill = _interopRequireDefault(__webpack_require__(/*! resize-observer-polyfill */ \"../../node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"../../node_modules/clsx/dist/clsx.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*:: import type { ReactRef } from \"../ReactGridLayoutPropTypes\";*/\n/*:: type WPDefaultProps = {|\n  measureBeforeMount: boolean\n|};*/\n/*:: type WPProps = {|\n  className?: string,\n  style?: Object,\n  ...WPDefaultProps\n|};*/\n// eslint-disable-next-line no-unused-vars\n/*:: type WPState = {|\n  width: number\n|};*/\n/*:: type ComposedProps<Config> = {|\n  ...Config,\n  measureBeforeMount?: boolean,\n  className?: string,\n  style?: Object,\n  width?: number\n|};*/\nconst layoutClassName = \"react-grid-layout\";\n\n/*\n * A simple HOC that provides facility for listening to container resizes.\n *\n * The Flow type is pretty janky here. I can't just spread `WPProps` into this returned object - I wish I could - but it triggers\n * a flow bug of some sort that causes it to stop typechecking.\n */\nfunction WidthProvideRGL /*:: <Config>*/(ComposedComponent /*: React.AbstractComponent<Config>*/) /*: React.AbstractComponent<ComposedProps<Config>>*/{\n  var _class;\n  return _class = class WidthProvider extends React.Component\n  /*:: <\n      ComposedProps<Config>,\n      WPState\n    >*/\n  {\n    constructor() {\n      super(...arguments);\n      _defineProperty(this, \"state\", {\n        width: 1280\n      });\n      _defineProperty(this, \"elementRef\", /*#__PURE__*/React.createRef());\n      _defineProperty(this, \"mounted\", false);\n      _defineProperty(this, \"resizeObserver\", void 0);\n    }\n    componentDidMount() {\n      this.mounted = true;\n      this.resizeObserver = new _resizeObserverPolyfill.default(entries => {\n        const node = this.elementRef.current;\n        if (node instanceof HTMLElement) {\n          const width = entries[0].contentRect.width;\n          this.setState({\n            width\n          });\n        }\n      });\n      const node = this.elementRef.current;\n      if (node instanceof HTMLElement) {\n        this.resizeObserver.observe(node);\n      }\n    }\n    componentWillUnmount() {\n      this.mounted = false;\n      const node = this.elementRef.current;\n      if (node instanceof HTMLElement) {\n        this.resizeObserver.unobserve(node);\n      }\n      this.resizeObserver.disconnect();\n    }\n    render() {\n      const {\n        measureBeforeMount,\n        ...rest\n      } = this.props;\n      if (measureBeforeMount && !this.mounted) {\n        return /*#__PURE__*/React.createElement(\"div\", {\n          className: (0, _clsx.default)(this.props.className, layoutClassName),\n          style: this.props.style\n          // $FlowIgnore ref types\n          ,\n          ref: this.elementRef\n        });\n      }\n      return /*#__PURE__*/React.createElement(ComposedComponent, _extends({\n        innerRef: this.elementRef\n      }, rest, this.state));\n    }\n  }, _defineProperty(_class, \"defaultProps\", {\n    measureBeforeMount: false\n  }), _defineProperty(_class, \"propTypes\", {\n    // If true, will not render children until mounted. Useful for getting the exact width before\n    // rendering, to prevent any unsightly resizing.\n    measureBeforeMount: _propTypes.default.bool\n  }), _class;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL2NvbXBvbmVudHMvV2lkdGhQcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL2NvbXBvbmVudHMvV2lkdGhQcm92aWRlci5qcz84YTAxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gV2lkdGhQcm92aWRlUkdMO1xudmFyIFJlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG52YXIgX3Jlc2l6ZU9ic2VydmVyUG9seWZpbGwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGxcIikpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSB0eXBlb2YgZSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IGRlZmF1bHQ6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgdSkpIHsgdmFyIGkgPSBhID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB1KSA6IG51bGw7IGkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB1LCBpKSA6IG5bdV0gPSBlW3VdOyB9IHJldHVybiBuLmRlZmF1bHQgPSBlLCB0ICYmIHQuc2V0KGUsIG4pLCBuOyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbi8qOjogaW1wb3J0IHR5cGUgeyBSZWFjdFJlZiB9IGZyb20gXCIuLi9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXNcIjsqL1xuLyo6OiB0eXBlIFdQRGVmYXVsdFByb3BzID0ge3xcbiAgbWVhc3VyZUJlZm9yZU1vdW50OiBib29sZWFuXG58fTsqL1xuLyo6OiB0eXBlIFdQUHJvcHMgPSB7fFxuICBjbGFzc05hbWU/OiBzdHJpbmcsXG4gIHN0eWxlPzogT2JqZWN0LFxuICAuLi5XUERlZmF1bHRQcm9wc1xufH07Ki9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuLyo6OiB0eXBlIFdQU3RhdGUgPSB7fFxuICB3aWR0aDogbnVtYmVyXG58fTsqL1xuLyo6OiB0eXBlIENvbXBvc2VkUHJvcHM8Q29uZmlnPiA9IHt8XG4gIC4uLkNvbmZpZyxcbiAgbWVhc3VyZUJlZm9yZU1vdW50PzogYm9vbGVhbixcbiAgY2xhc3NOYW1lPzogc3RyaW5nLFxuICBzdHlsZT86IE9iamVjdCxcbiAgd2lkdGg/OiBudW1iZXJcbnx9OyovXG5jb25zdCBsYXlvdXRDbGFzc05hbWUgPSBcInJlYWN0LWdyaWQtbGF5b3V0XCI7XG5cbi8qXG4gKiBBIHNpbXBsZSBIT0MgdGhhdCBwcm92aWRlcyBmYWNpbGl0eSBmb3IgbGlzdGVuaW5nIHRvIGNvbnRhaW5lciByZXNpemVzLlxuICpcbiAqIFRoZSBGbG93IHR5cGUgaXMgcHJldHR5IGphbmt5IGhlcmUuIEkgY2FuJ3QganVzdCBzcHJlYWQgYFdQUHJvcHNgIGludG8gdGhpcyByZXR1cm5lZCBvYmplY3QgLSBJIHdpc2ggSSBjb3VsZCAtIGJ1dCBpdCB0cmlnZ2Vyc1xuICogYSBmbG93IGJ1ZyBvZiBzb21lIHNvcnQgdGhhdCBjYXVzZXMgaXQgdG8gc3RvcCB0eXBlY2hlY2tpbmcuXG4gKi9cbmZ1bmN0aW9uIFdpZHRoUHJvdmlkZVJHTCAvKjo6IDxDb25maWc+Ki8oQ29tcG9zZWRDb21wb25lbnQgLyo6IFJlYWN0LkFic3RyYWN0Q29tcG9uZW50PENvbmZpZz4qLykgLyo6IFJlYWN0LkFic3RyYWN0Q29tcG9uZW50PENvbXBvc2VkUHJvcHM8Q29uZmlnPj4qL3tcbiAgdmFyIF9jbGFzcztcbiAgcmV0dXJuIF9jbGFzcyA9IGNsYXNzIFdpZHRoUHJvdmlkZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnRcbiAgLyo6OiA8XG4gICAgICBDb21wb3NlZFByb3BzPENvbmZpZz4sXG4gICAgICBXUFN0YXRlXG4gICAgPiovXG4gIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICAgIHdpZHRoOiAxMjgwXG4gICAgICB9KTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVsZW1lbnRSZWZcIiwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZVJlZigpKTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1vdW50ZWRcIiwgZmFsc2UpO1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzaXplT2JzZXJ2ZXJcIiwgdm9pZCAwKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBfcmVzaXplT2JzZXJ2ZXJQb2x5ZmlsbC5kZWZhdWx0KGVudHJpZXMgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5lbGVtZW50UmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IGVudHJpZXNbMF0uY29udGVudFJlY3Qud2lkdGg7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB3aWR0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmVsZW1lbnRSZWYuY3VycmVudDtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZWxlbWVudFJlZi5jdXJyZW50O1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShub2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1lYXN1cmVCZWZvcmVNb3VudCxcbiAgICAgICAgLi4ucmVzdFxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAobWVhc3VyZUJlZm9yZU1vdW50ICYmICF0aGlzLm1vdW50ZWQpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeC5kZWZhdWx0KSh0aGlzLnByb3BzLmNsYXNzTmFtZSwgbGF5b3V0Q2xhc3NOYW1lKSxcbiAgICAgICAgICBzdHlsZTogdGhpcy5wcm9wcy5zdHlsZVxuICAgICAgICAgIC8vICRGbG93SWdub3JlIHJlZiB0eXBlc1xuICAgICAgICAgICxcbiAgICAgICAgICByZWY6IHRoaXMuZWxlbWVudFJlZlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb3NlZENvbXBvbmVudCwgX2V4dGVuZHMoe1xuICAgICAgICBpbm5lclJlZjogdGhpcy5lbGVtZW50UmVmXG4gICAgICB9LCByZXN0LCB0aGlzLnN0YXRlKSk7XG4gICAgfVxuICB9LCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gICAgbWVhc3VyZUJlZm9yZU1vdW50OiBmYWxzZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9jbGFzcywgXCJwcm9wVHlwZXNcIiwge1xuICAgIC8vIElmIHRydWUsIHdpbGwgbm90IHJlbmRlciBjaGlsZHJlbiB1bnRpbCBtb3VudGVkLiBVc2VmdWwgZm9yIGdldHRpbmcgdGhlIGV4YWN0IHdpZHRoIGJlZm9yZVxuICAgIC8vIHJlbmRlcmluZywgdG8gcHJldmVudCBhbnkgdW5zaWdodGx5IHJlc2l6aW5nLlxuICAgIG1lYXN1cmVCZWZvcmVNb3VudDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2xcbiAgfSksIF9jbGFzcztcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/react-grid-layout/build/components/WidthProvider.js\n");

/***/ }),

/***/ "../../node_modules/react-grid-layout/build/fastRGLPropsEqual.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/react-grid-layout/build/fastRGLPropsEqual.js ***!
  \***********************************************************************/
/***/ ((module) => {

eval("// this file was prevaled\nmodule.exports = function fastRGLPropsEqual(a, b, isEqualImpl) {\n  if (a === b) return true;\n  return a.className === b.className && isEqualImpl(a.style, b.style) && a.width === b.width && a.autoSize === b.autoSize && a.cols === b.cols && a.draggableCancel === b.draggableCancel && a.draggableHandle === b.draggableHandle && isEqualImpl(a.verticalCompact, b.verticalCompact) && isEqualImpl(a.compactType, b.compactType) && isEqualImpl(a.layout, b.layout) && isEqualImpl(a.margin, b.margin) && isEqualImpl(a.containerPadding, b.containerPadding) && a.rowHeight === b.rowHeight && a.maxRows === b.maxRows && a.isBounded === b.isBounded && a.isDraggable === b.isDraggable && a.isResizable === b.isResizable && a.allowOverlap === b.allowOverlap && a.preventCollision === b.preventCollision && a.useCSSTransforms === b.useCSSTransforms && a.transformScale === b.transformScale && a.isDroppable === b.isDroppable && isEqualImpl(a.resizeHandles, b.resizeHandles) && isEqualImpl(a.resizeHandle, b.resizeHandle) && a.onLayoutChange === b.onLayoutChange && a.onDragStart === b.onDragStart && a.onDrag === b.onDrag && a.onDragStop === b.onDragStop && a.onResizeStart === b.onResizeStart && a.onResize === b.onResize && a.onResizeStop === b.onResizeStop && a.onDrop === b.onDrop && isEqualImpl(a.droppingItem, b.droppingItem) && isEqualImpl(a.innerRef, b.innerRef);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL2Zhc3RSR0xQcm9wc0VxdWFsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLWxheW91dC9idWlsZC9mYXN0UkdMUHJvcHNFcXVhbC5qcz82YWQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRoaXMgZmlsZSB3YXMgcHJldmFsZWRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmFzdFJHTFByb3BzRXF1YWwoYSwgYiwgaXNFcXVhbEltcGwpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICByZXR1cm4gYS5jbGFzc05hbWUgPT09IGIuY2xhc3NOYW1lICYmIGlzRXF1YWxJbXBsKGEuc3R5bGUsIGIuc3R5bGUpICYmIGEud2lkdGggPT09IGIud2lkdGggJiYgYS5hdXRvU2l6ZSA9PT0gYi5hdXRvU2l6ZSAmJiBhLmNvbHMgPT09IGIuY29scyAmJiBhLmRyYWdnYWJsZUNhbmNlbCA9PT0gYi5kcmFnZ2FibGVDYW5jZWwgJiYgYS5kcmFnZ2FibGVIYW5kbGUgPT09IGIuZHJhZ2dhYmxlSGFuZGxlICYmIGlzRXF1YWxJbXBsKGEudmVydGljYWxDb21wYWN0LCBiLnZlcnRpY2FsQ29tcGFjdCkgJiYgaXNFcXVhbEltcGwoYS5jb21wYWN0VHlwZSwgYi5jb21wYWN0VHlwZSkgJiYgaXNFcXVhbEltcGwoYS5sYXlvdXQsIGIubGF5b3V0KSAmJiBpc0VxdWFsSW1wbChhLm1hcmdpbiwgYi5tYXJnaW4pICYmIGlzRXF1YWxJbXBsKGEuY29udGFpbmVyUGFkZGluZywgYi5jb250YWluZXJQYWRkaW5nKSAmJiBhLnJvd0hlaWdodCA9PT0gYi5yb3dIZWlnaHQgJiYgYS5tYXhSb3dzID09PSBiLm1heFJvd3MgJiYgYS5pc0JvdW5kZWQgPT09IGIuaXNCb3VuZGVkICYmIGEuaXNEcmFnZ2FibGUgPT09IGIuaXNEcmFnZ2FibGUgJiYgYS5pc1Jlc2l6YWJsZSA9PT0gYi5pc1Jlc2l6YWJsZSAmJiBhLmFsbG93T3ZlcmxhcCA9PT0gYi5hbGxvd092ZXJsYXAgJiYgYS5wcmV2ZW50Q29sbGlzaW9uID09PSBiLnByZXZlbnRDb2xsaXNpb24gJiYgYS51c2VDU1NUcmFuc2Zvcm1zID09PSBiLnVzZUNTU1RyYW5zZm9ybXMgJiYgYS50cmFuc2Zvcm1TY2FsZSA9PT0gYi50cmFuc2Zvcm1TY2FsZSAmJiBhLmlzRHJvcHBhYmxlID09PSBiLmlzRHJvcHBhYmxlICYmIGlzRXF1YWxJbXBsKGEucmVzaXplSGFuZGxlcywgYi5yZXNpemVIYW5kbGVzKSAmJiBpc0VxdWFsSW1wbChhLnJlc2l6ZUhhbmRsZSwgYi5yZXNpemVIYW5kbGUpICYmIGEub25MYXlvdXRDaGFuZ2UgPT09IGIub25MYXlvdXRDaGFuZ2UgJiYgYS5vbkRyYWdTdGFydCA9PT0gYi5vbkRyYWdTdGFydCAmJiBhLm9uRHJhZyA9PT0gYi5vbkRyYWcgJiYgYS5vbkRyYWdTdG9wID09PSBiLm9uRHJhZ1N0b3AgJiYgYS5vblJlc2l6ZVN0YXJ0ID09PSBiLm9uUmVzaXplU3RhcnQgJiYgYS5vblJlc2l6ZSA9PT0gYi5vblJlc2l6ZSAmJiBhLm9uUmVzaXplU3RvcCA9PT0gYi5vblJlc2l6ZVN0b3AgJiYgYS5vbkRyb3AgPT09IGIub25Ecm9wICYmIGlzRXF1YWxJbXBsKGEuZHJvcHBpbmdJdGVtLCBiLmRyb3BwaW5nSXRlbSkgJiYgaXNFcXVhbEltcGwoYS5pbm5lclJlZiwgYi5pbm5lclJlZik7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/react-grid-layout/build/fastRGLPropsEqual.js\n");

/***/ }),

/***/ "../../node_modules/react-grid-layout/build/responsiveUtils.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/react-grid-layout/build/responsiveUtils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.findOrGenerateResponsiveLayout = findOrGenerateResponsiveLayout;\nexports.getBreakpointFromWidth = getBreakpointFromWidth;\nexports.getColsFromBreakpoint = getColsFromBreakpoint;\nexports.sortBreakpoints = sortBreakpoints;\nvar _utils = __webpack_require__(/*! ./utils */ \"../../node_modules/react-grid-layout/build/utils.js\");\n/*:: import type { CompactType, Layout } from \"./utils\";*/\n/*:: export type Breakpoint = string;*/\n/*:: export type DefaultBreakpoints = \"lg\" | \"md\" | \"sm\" | \"xs\" | \"xxs\";*/\n/*:: export type ResponsiveLayout<T: Breakpoint> = {\n  +[breakpoint: T]: Layout\n};*/\n// + indicates read-only\n/*:: export type Breakpoints<T: Breakpoint> = {\n  +[breakpoint: T]: number\n};*/\n/*:: export type OnLayoutChangeCallback = (\n  Layout,\n  { [key: Breakpoint]: Layout }\n) => void;*/\n/**\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\n *\n * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\n * @param  {Number} width Screen width.\n * @return {String}       Highest breakpoint that is less than width.\n */\nfunction getBreakpointFromWidth(breakpoints /*: Breakpoints<Breakpoint>*/, width /*: number*/) /*: Breakpoint*/{\n  const sorted = sortBreakpoints(breakpoints);\n  let matching = sorted[0];\n  for (let i = 1, len = sorted.length; i < len; i++) {\n    const breakpointName = sorted[i];\n    if (width > breakpoints[breakpointName]) matching = breakpointName;\n  }\n  return matching;\n}\n\n/**\n * Given a breakpoint, get the # of cols set for it.\n * @param  {String} breakpoint Breakpoint name.\n * @param  {Object} cols       Map of breakpoints to cols.\n * @return {Number}            Number of cols.\n */\nfunction getColsFromBreakpoint(breakpoint /*: Breakpoint*/, cols /*: Breakpoints<Breakpoint>*/) /*: number*/{\n  if (!cols[breakpoint]) {\n    throw new Error(\"ResponsiveReactGridLayout: `cols` entry for breakpoint \" + breakpoint + \" is missing!\");\n  }\n  return cols[breakpoint];\n}\n\n/**\n * Given existing layouts and a new breakpoint, find or generate a new layout.\n *\n * This finds the layout above the new one and generates from it, if it exists.\n *\n * @param  {Object} layouts     Existing layouts.\n * @param  {Array} breakpoints All breakpoints.\n * @param  {String} breakpoint New breakpoint.\n * @param  {String} breakpoint Last breakpoint (for fallback).\n * @param  {Number} cols       Column count at new breakpoint.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}             New layout.\n */\nfunction findOrGenerateResponsiveLayout(layouts /*: ResponsiveLayout<Breakpoint>*/, breakpoints /*: Breakpoints<Breakpoint>*/, breakpoint /*: Breakpoint*/, lastBreakpoint /*: Breakpoint*/, cols /*: number*/, compactType /*: CompactType*/) /*: Layout*/{\n  // If it already exists, just return it.\n  if (layouts[breakpoint]) return (0, _utils.cloneLayout)(layouts[breakpoint]);\n  // Find or generate the next layout\n  let layout = layouts[lastBreakpoint];\n  const breakpointsSorted = sortBreakpoints(breakpoints);\n  const breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\n  for (let i = 0, len = breakpointsAbove.length; i < len; i++) {\n    const b = breakpointsAbove[i];\n    if (layouts[b]) {\n      layout = layouts[b];\n      break;\n    }\n  }\n  layout = (0, _utils.cloneLayout)(layout || []); // clone layout so we don't modify existing items\n  return (0, _utils.compact)((0, _utils.correctBounds)(layout, {\n    cols: cols\n  }), compactType, cols);\n}\n\n/**\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\n * e.g. ['xxs', 'xs', 'sm', ...]\n *\n * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.\n * @return {Array}              Sorted breakpoints.\n */\nfunction sortBreakpoints(breakpoints /*: Breakpoints<Breakpoint>*/) /*: Array<Breakpoint>*/{\n  const keys /*: Array<string>*/ = Object.keys(breakpoints);\n  return keys.sort(function (a, b) {\n    return breakpoints[a] - breakpoints[b];\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL3Jlc3BvbnNpdmVVdGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9zdC8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvcmVzcG9uc2l2ZVV0aWxzLmpzPzgyMDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZpbmRPckdlbmVyYXRlUmVzcG9uc2l2ZUxheW91dCA9IGZpbmRPckdlbmVyYXRlUmVzcG9uc2l2ZUxheW91dDtcbmV4cG9ydHMuZ2V0QnJlYWtwb2ludEZyb21XaWR0aCA9IGdldEJyZWFrcG9pbnRGcm9tV2lkdGg7XG5leHBvcnRzLmdldENvbHNGcm9tQnJlYWtwb2ludCA9IGdldENvbHNGcm9tQnJlYWtwb2ludDtcbmV4cG9ydHMuc29ydEJyZWFrcG9pbnRzID0gc29ydEJyZWFrcG9pbnRzO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyo6OiBpbXBvcnQgdHlwZSB7IENvbXBhY3RUeXBlLCBMYXlvdXQgfSBmcm9tIFwiLi91dGlsc1wiOyovXG4vKjo6IGV4cG9ydCB0eXBlIEJyZWFrcG9pbnQgPSBzdHJpbmc7Ki9cbi8qOjogZXhwb3J0IHR5cGUgRGVmYXVsdEJyZWFrcG9pbnRzID0gXCJsZ1wiIHwgXCJtZFwiIHwgXCJzbVwiIHwgXCJ4c1wiIHwgXCJ4eHNcIjsqL1xuLyo6OiBleHBvcnQgdHlwZSBSZXNwb25zaXZlTGF5b3V0PFQ6IEJyZWFrcG9pbnQ+ID0ge1xuICArW2JyZWFrcG9pbnQ6IFRdOiBMYXlvdXRcbn07Ki9cbi8vICsgaW5kaWNhdGVzIHJlYWQtb25seVxuLyo6OiBleHBvcnQgdHlwZSBCcmVha3BvaW50czxUOiBCcmVha3BvaW50PiA9IHtcbiAgK1ticmVha3BvaW50OiBUXTogbnVtYmVyXG59OyovXG4vKjo6IGV4cG9ydCB0eXBlIE9uTGF5b3V0Q2hhbmdlQ2FsbGJhY2sgPSAoXG4gIExheW91dCxcbiAgeyBba2V5OiBCcmVha3BvaW50XTogTGF5b3V0IH1cbikgPT4gdm9pZDsqL1xuLyoqXG4gKiBHaXZlbiBhIHdpZHRoLCBmaW5kIHRoZSBoaWdoZXN0IGJyZWFrcG9pbnQgdGhhdCBtYXRjaGVzIGlzIHZhbGlkIGZvciBpdCAod2lkdGggPiBicmVha3BvaW50KS5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGJyZWFrcG9pbnRzIEJyZWFrcG9pbnRzIG9iamVjdCAoZS5nLiB7bGc6IDEyMDAsIG1kOiA5NjAsIC4uLn0pXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHdpZHRoIFNjcmVlbiB3aWR0aC5cbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgSGlnaGVzdCBicmVha3BvaW50IHRoYXQgaXMgbGVzcyB0aGFuIHdpZHRoLlxuICovXG5mdW5jdGlvbiBnZXRCcmVha3BvaW50RnJvbVdpZHRoKGJyZWFrcG9pbnRzIC8qOiBCcmVha3BvaW50czxCcmVha3BvaW50PiovLCB3aWR0aCAvKjogbnVtYmVyKi8pIC8qOiBCcmVha3BvaW50Ki97XG4gIGNvbnN0IHNvcnRlZCA9IHNvcnRCcmVha3BvaW50cyhicmVha3BvaW50cyk7XG4gIGxldCBtYXRjaGluZyA9IHNvcnRlZFswXTtcbiAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IHNvcnRlZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGJyZWFrcG9pbnROYW1lID0gc29ydGVkW2ldO1xuICAgIGlmICh3aWR0aCA+IGJyZWFrcG9pbnRzW2JyZWFrcG9pbnROYW1lXSkgbWF0Y2hpbmcgPSBicmVha3BvaW50TmFtZTtcbiAgfVxuICByZXR1cm4gbWF0Y2hpbmc7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBicmVha3BvaW50LCBnZXQgdGhlICMgb2YgY29scyBzZXQgZm9yIGl0LlxuICogQHBhcmFtICB7U3RyaW5nfSBicmVha3BvaW50IEJyZWFrcG9pbnQgbmFtZS5cbiAqIEBwYXJhbSAge09iamVjdH0gY29scyAgICAgICBNYXAgb2YgYnJlYWtwb2ludHMgdG8gY29scy5cbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICBOdW1iZXIgb2YgY29scy5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29sc0Zyb21CcmVha3BvaW50KGJyZWFrcG9pbnQgLyo6IEJyZWFrcG9pbnQqLywgY29scyAvKjogQnJlYWtwb2ludHM8QnJlYWtwb2ludD4qLykgLyo6IG51bWJlciove1xuICBpZiAoIWNvbHNbYnJlYWtwb2ludF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zaXZlUmVhY3RHcmlkTGF5b3V0OiBgY29sc2AgZW50cnkgZm9yIGJyZWFrcG9pbnQgXCIgKyBicmVha3BvaW50ICsgXCIgaXMgbWlzc2luZyFcIik7XG4gIH1cbiAgcmV0dXJuIGNvbHNbYnJlYWtwb2ludF07XG59XG5cbi8qKlxuICogR2l2ZW4gZXhpc3RpbmcgbGF5b3V0cyBhbmQgYSBuZXcgYnJlYWtwb2ludCwgZmluZCBvciBnZW5lcmF0ZSBhIG5ldyBsYXlvdXQuXG4gKlxuICogVGhpcyBmaW5kcyB0aGUgbGF5b3V0IGFib3ZlIHRoZSBuZXcgb25lIGFuZCBnZW5lcmF0ZXMgZnJvbSBpdCwgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gbGF5b3V0cyAgICAgRXhpc3RpbmcgbGF5b3V0cy5cbiAqIEBwYXJhbSAge0FycmF5fSBicmVha3BvaW50cyBBbGwgYnJlYWtwb2ludHMuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGJyZWFrcG9pbnQgTmV3IGJyZWFrcG9pbnQuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGJyZWFrcG9pbnQgTGFzdCBicmVha3BvaW50IChmb3IgZmFsbGJhY2spLlxuICogQHBhcmFtICB7TnVtYmVyfSBjb2xzICAgICAgIENvbHVtbiBjb3VudCBhdCBuZXcgYnJlYWtwb2ludC5cbiAqIEBwYXJhbSAge0Jvb2xlYW59IHZlcnRpY2FsQ29tcGFjdCBXaGV0aGVyIG9yIG5vdCB0byBjb21wYWN0IHRoZSBsYXlvdXRcbiAqICAgdmVydGljYWxseS5cbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICBOZXcgbGF5b3V0LlxuICovXG5mdW5jdGlvbiBmaW5kT3JHZW5lcmF0ZVJlc3BvbnNpdmVMYXlvdXQobGF5b3V0cyAvKjogUmVzcG9uc2l2ZUxheW91dDxCcmVha3BvaW50PiovLCBicmVha3BvaW50cyAvKjogQnJlYWtwb2ludHM8QnJlYWtwb2ludD4qLywgYnJlYWtwb2ludCAvKjogQnJlYWtwb2ludCovLCBsYXN0QnJlYWtwb2ludCAvKjogQnJlYWtwb2ludCovLCBjb2xzIC8qOiBudW1iZXIqLywgY29tcGFjdFR5cGUgLyo6IENvbXBhY3RUeXBlKi8pIC8qOiBMYXlvdXQqL3tcbiAgLy8gSWYgaXQgYWxyZWFkeSBleGlzdHMsIGp1c3QgcmV0dXJuIGl0LlxuICBpZiAobGF5b3V0c1ticmVha3BvaW50XSkgcmV0dXJuICgwLCBfdXRpbHMuY2xvbmVMYXlvdXQpKGxheW91dHNbYnJlYWtwb2ludF0pO1xuICAvLyBGaW5kIG9yIGdlbmVyYXRlIHRoZSBuZXh0IGxheW91dFxuICBsZXQgbGF5b3V0ID0gbGF5b3V0c1tsYXN0QnJlYWtwb2ludF07XG4gIGNvbnN0IGJyZWFrcG9pbnRzU29ydGVkID0gc29ydEJyZWFrcG9pbnRzKGJyZWFrcG9pbnRzKTtcbiAgY29uc3QgYnJlYWtwb2ludHNBYm92ZSA9IGJyZWFrcG9pbnRzU29ydGVkLnNsaWNlKGJyZWFrcG9pbnRzU29ydGVkLmluZGV4T2YoYnJlYWtwb2ludCkpO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gYnJlYWtwb2ludHNBYm92ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGIgPSBicmVha3BvaW50c0Fib3ZlW2ldO1xuICAgIGlmIChsYXlvdXRzW2JdKSB7XG4gICAgICBsYXlvdXQgPSBsYXlvdXRzW2JdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGxheW91dCA9ICgwLCBfdXRpbHMuY2xvbmVMYXlvdXQpKGxheW91dCB8fCBbXSk7IC8vIGNsb25lIGxheW91dCBzbyB3ZSBkb24ndCBtb2RpZnkgZXhpc3RpbmcgaXRlbXNcbiAgcmV0dXJuICgwLCBfdXRpbHMuY29tcGFjdCkoKDAsIF91dGlscy5jb3JyZWN0Qm91bmRzKShsYXlvdXQsIHtcbiAgICBjb2xzOiBjb2xzXG4gIH0pLCBjb21wYWN0VHlwZSwgY29scyk7XG59XG5cbi8qKlxuICogR2l2ZW4gYnJlYWtwb2ludHMsIHJldHVybiBhbiBhcnJheSBvZiBicmVha3BvaW50cyBzb3J0ZWQgYnkgd2lkdGguIFRoaXMgaXMgdXN1YWxseVxuICogZS5nLiBbJ3h4cycsICd4cycsICdzbScsIC4uLl1cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGJyZWFrcG9pbnRzIEtleS92YWx1ZSBwYWlyIG9mIGJyZWFrcG9pbnQgbmFtZXMgdG8gd2lkdGhzLlxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICBTb3J0ZWQgYnJlYWtwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHNvcnRCcmVha3BvaW50cyhicmVha3BvaW50cyAvKjogQnJlYWtwb2ludHM8QnJlYWtwb2ludD4qLykgLyo6IEFycmF5PEJyZWFrcG9pbnQ+Ki97XG4gIGNvbnN0IGtleXMgLyo6IEFycmF5PHN0cmluZz4qLyA9IE9iamVjdC5rZXlzKGJyZWFrcG9pbnRzKTtcbiAgcmV0dXJuIGtleXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBicmVha3BvaW50c1thXSAtIGJyZWFrcG9pbnRzW2JdO1xuICB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/react-grid-layout/build/responsiveUtils.js\n");

/***/ }),

/***/ "../../node_modules/react-grid-layout/build/utils.js":
/*!***********************************************************!*\
  !*** ../../node_modules/react-grid-layout/build/utils.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.bottom = bottom;\nexports.childrenEqual = childrenEqual;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.compactType = compactType;\nexports.correctBounds = correctBounds;\nexports.fastPositionEqual = fastPositionEqual;\nexports.fastRGLPropsEqual = void 0;\nexports.getAllCollisions = getAllCollisions;\nexports.getFirstCollision = getFirstCollision;\nexports.getLayoutItem = getLayoutItem;\nexports.getStatics = getStatics;\nexports.modifyLayout = modifyLayout;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.noop = void 0;\nexports.perc = perc;\nexports.resizeItemInDirection = resizeItemInDirection;\nexports.setTopLeft = setTopLeft;\nexports.setTransform = setTransform;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.withLayoutItem = withLayoutItem;\nvar _fastEquals = __webpack_require__(/*! fast-equals */ \"../../node_modules/fast-equals/dist/fast-equals.js\");\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/*:: import type {\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n/*:: export type ResizeHandleAxis =\n  | \"s\"\n  | \"w\"\n  | \"e\"\n  | \"n\"\n  | \"sw\"\n  | \"nw\"\n  | \"se\"\n  | \"ne\";*/\n/*:: export type LayoutItem = {\n  w: number,\n  h: number,\n  x: number,\n  y: number,\n  i: string,\n  minW?: number,\n  minH?: number,\n  maxW?: number,\n  maxH?: number,\n  moved?: boolean,\n  static?: boolean,\n  isDraggable?: ?boolean,\n  isResizable?: ?boolean,\n  resizeHandles?: Array<ResizeHandleAxis>,\n  isBounded?: ?boolean\n};*/\n/*:: export type Layout = $ReadOnlyArray<LayoutItem>;*/\n/*:: export type Position = {\n  left: number,\n  top: number,\n  width: number,\n  height: number\n};*/\n/*:: export type ReactDraggableCallbackData = {\n  node: HTMLElement,\n  x?: number,\n  y?: number,\n  deltaX: number,\n  deltaY: number,\n  lastX?: number,\n  lastY?: number\n};*/\n/*:: export type PartialPosition = { left: number, top: number };*/\n/*:: export type DroppingPosition = { left: number, top: number, e: Event };*/\n/*:: export type Size = { width: number, height: number };*/\n/*:: export type GridDragEvent = {\n  e: Event,\n  node: HTMLElement,\n  newPosition: PartialPosition\n};*/\n/*:: export type GridResizeEvent = {\n  e: Event,\n  node: HTMLElement,\n  size: Size,\n  handle: string\n};*/\n/*:: export type DragOverEvent = MouseEvent & {\n  nativeEvent: {\n    layerX: number,\n    layerY: number,\n    ...Event\n  }\n};*/\n/*:: export type Pick<FromType, Properties: { [string]: 0 }> = $Exact<\n  $ObjMapi<Properties, <K, V>(k: K, v: V) => $ElementType<FromType, K>>\n>;*/\n// Helpful port from TS\n/*:: type REl = ReactElement<any>;*/\n/*:: export type ReactChildren = ReactChildrenArray<REl>;*/\n/*:: export type EventCallback = (\n  Layout,\n  oldItem: ?LayoutItem,\n  newItem: ?LayoutItem,\n  placeholder: ?LayoutItem,\n  Event,\n  ?HTMLElement\n) => void;*/\n// All callbacks are of the signature (layout, oldItem, newItem, placeholder, e).\n/*:: export type CompactType = ?(\"horizontal\" | \"vertical\");*/\nconst isProduction = \"development\" === \"production\";\nconst DEBUG = false;\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nfunction bottom(layout /*: Layout*/) /*: number*/{\n  let max = 0,\n    bottomY;\n  for (let i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n  return max;\n}\nfunction cloneLayout(layout /*: Layout*/) /*: Layout*/{\n  const newLayout = Array(layout.length);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n  return newLayout;\n}\n\n// Modify a layoutItem inside a layout. Returns a new Layout,\n// does not mutate. Carries over all other LayoutItems unmodified.\nfunction modifyLayout(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: Layout*/{\n  const newLayout = Array(layout.length);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layoutItem.i === layout[i].i) {\n      newLayout[i] = layoutItem;\n    } else {\n      newLayout[i] = layout[i];\n    }\n  }\n  return newLayout;\n}\n\n// Function to be called to modify a layout item.\n// Does defensive clones to ensure the layout is not modified.\nfunction withLayoutItem(layout /*: Layout*/, itemKey /*: string*/, cb /*: LayoutItem => LayoutItem*/) /*: [Layout, ?LayoutItem]*/{\n  let item = getLayoutItem(layout, itemKey);\n  if (!item) return [layout, null];\n  item = cb(cloneLayoutItem(item)); // defensive clone then modify\n  // FIXME could do this faster if we already knew the index\n  layout = modifyLayout(layout, item);\n  return [layout, item];\n}\n\n// Fast path to cloning, since this is monomorphic\nfunction cloneLayoutItem(layoutItem /*: LayoutItem*/) /*: LayoutItem*/{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null/undefined\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    isBounded: layoutItem.isBounded\n  };\n}\n\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\nfunction childrenEqual(a /*: ReactChildren*/, b /*: ReactChildren*/) /*: boolean*/{\n  return (0, _fastEquals.deepEqual)(_react.default.Children.map(a, c => c?.key), _react.default.Children.map(b, c => c?.key)) && (0, _fastEquals.deepEqual)(_react.default.Children.map(a, c => c?.props[\"data-grid\"]), _react.default.Children.map(b, c => c?.props[\"data-grid\"]));\n}\n\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\nconst fastRGLPropsEqual /*: FastRGLPropsEqual*/ = exports.fastRGLPropsEqual = __webpack_require__(/*! ./fastRGLPropsEqual */ \"../../node_modules/react-grid-layout/build/fastRGLPropsEqual.js\");\n\n// Like the above, but a lot simpler.\nfunction fastPositionEqual(a /*: Position*/, b /*: Position*/) /*: boolean*/{\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n\n/**\n * Given two layoutitems, check if they collide.\n */\nfunction collides(l1 /*: LayoutItem*/, l2 /*: LayoutItem*/) /*: boolean*/{\n  if (l1.i === l2.i) return false; // same element\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n  return true; // boxes overlap\n}\n\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @param  {Boolean} allowOverlap When `true`, allows overlapping grid items.\n * @return {Array}       Compacted Layout.\n */\nfunction compact(layout /*: Layout*/, compactType /*: CompactType*/, cols /*: number*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  // Statics go in the compareWith array right away so items flow around them.\n  const compareWith = getStatics(layout);\n  // We go through the items by row and column.\n  const sorted = sortLayoutItems(layout, compactType);\n  // Holding for new items.\n  const out = Array(layout.length);\n  for (let i = 0, len = sorted.length; i < len; i++) {\n    let l = cloneLayoutItem(sorted[i]);\n\n    // Don't move static elements\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted, allowOverlap);\n\n      // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n      compareWith.push(l);\n    }\n\n    // Add to output array to make sure they still come out in the right order.\n    out[layout.indexOf(sorted[i])] = l;\n\n    // Clear moved flag, if it exists.\n    l.moved = false;\n  }\n  return out;\n}\nconst heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\nfunction resolveCompactionCollision(layout /*: Layout*/, item /*: LayoutItem*/, moveToCoord /*: number*/, axis /*: \"x\" | \"y\"*/) {\n  const sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  const itemIndex = layout.map(layoutItem => {\n    return layoutItem.i;\n  }).indexOf(item.i);\n\n  // Go through each item we collide with.\n  for (let i = itemIndex + 1; i < layout.length; i++) {\n    const otherItem = layout[i];\n    // Ignore static items\n    if (otherItem.static) continue;\n\n    // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n    if (otherItem.y > item.y + item.h) break;\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n  item[axis] = moveToCoord;\n}\n\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\nfunction compactItem(compareWith /*: Layout*/, l /*: LayoutItem*/, compactType /*: CompactType*/, cols /*: number*/, fullLayout /*: Layout*/, allowOverlap /*: ?boolean*/) /*: LayoutItem*/{\n  const compactV = compactType === \"vertical\";\n  const compactH = compactType === \"horizontal\";\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y);\n    // Move the element up as far as it can go without colliding.\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  }\n\n  // Move it down, and keep moving it down if it's colliding.\n  let collides;\n  // Checking the compactType null value to avoid breaking the layout when overlapping is allowed.\n  while ((collides = getFirstCollision(compareWith, l)) && !(compactType === null && allowOverlap)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    }\n    // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n      // ALso move element as left as we can\n      while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n        l.x--;\n      }\n    }\n  }\n\n  // Ensure that there are no negative positions\n  l.y = Math.max(l.y, 0);\n  l.x = Math.max(l.x, 0);\n  return l;\n}\n\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\nfunction correctBounds(layout /*: Layout*/, bounds /*: { cols: number }*/) /*: Layout*/{\n  const collidesWith = getStatics(layout);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const l = layout[i];\n    // Overflows right\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w;\n    // Overflows left\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n  return layout;\n}\n\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\nfunction getLayoutItem(layout /*: Layout*/, id /*: string*/) /*: ?LayoutItem*/{\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\nfunction getFirstCollision(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: ?LayoutItem*/{\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\nfunction getAllCollisions(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: Array<LayoutItem>*/{\n  return layout.filter(l => collides(l, layoutItem));\n}\n\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\nfunction getStatics(layout /*: Layout*/) /*: Array<LayoutItem>*/{\n  return layout.filter(l => l.static);\n}\n\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\nfunction moveElement(layout /*: Layout*/, l /*: LayoutItem*/, x /*: ?number*/, y /*: ?number*/, isUserAction /*: ?boolean*/, preventCollision /*: ?boolean*/, compactType /*: CompactType*/, cols /*: number*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout;\n\n  // Short-circuit if nothing to do.\n  if (l.y === y && l.x === x) return layout;\n  log(`Moving element ${l.i} to [${String(x)},${String(y)}] from [${l.x},${l.y}]`);\n  const oldX = l.x;\n  const oldY = l.y;\n\n  // This is quite a bit faster than extending the object\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true;\n\n  // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n  let sorted = sortLayoutItems(layout, compactType);\n  const movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false;\n  // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n  if (movingUp) sorted = sorted.reverse();\n  const collisions = getAllCollisions(sorted, l);\n  const hasCollisions = collisions.length > 0;\n\n  // We may have collisions. We can short-circuit if we've turned off collisions or\n  // allowed overlap.\n  if (hasCollisions && allowOverlap) {\n    // Easy, we don't need to resolve collisions. But we *did* change the layout,\n    // so clone it on the way out.\n    return cloneLayout(layout);\n  } else if (hasCollisions && preventCollision) {\n    // If we are preventing collision but not allowing overlap, we need to\n    // revert the position of this element so it goes to where it came from, rather\n    // than the user's desired location.\n    log(`Collision prevented on ${l.i}, reverting.`);\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout; // did not change so don't clone\n  }\n\n  // Move each item that collides away from this element.\n  for (let i = 0, len = collisions.length; i < len; i++) {\n    const collision = collisions[i];\n    log(`Resolving collision between ${l.i} at [${l.x},${l.y}] and ${collision.i} at [${collision.x},${collision.y}]`);\n\n    // Short circuit so we can't infinite loop\n    if (collision.moved) continue;\n\n    // Don't move static items - we have to move *this* element away\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n  return layout;\n}\n\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\nfunction moveElementAwayFromCollision(layout /*: Layout*/, collidesWith /*: LayoutItem*/, itemToMove /*: LayoutItem*/, isUserAction /*: ?boolean*/, compactType /*: CompactType*/, cols /*: number*/) /*: Layout*/{\n  const compactH = compactType === \"horizontal\";\n  // Compact vertically if not set to horizontal\n  const compactV = compactType === \"vertical\";\n  const preventCollision = collidesWith.static; // we're already colliding (not for static items)\n\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false;\n\n    // Make a mock item so we don't modify the item here, only modify in moveElement.\n    const fakeItem /*: LayoutItem*/ = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    };\n    const firstCollision = getFirstCollision(layout, fakeItem);\n    const collisionNorth = firstCollision && firstCollision.y + firstCollision.h > collidesWith.y;\n    const collisionWest = firstCollision && collidesWith.x + collidesWith.w > firstCollision.x;\n\n    // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n    if (!firstCollision) {\n      log(`Doing reverse collision on ${itemToMove.i} up to [${fakeItem.x},${fakeItem.y}].`);\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    } else if (collisionNorth && compactV) {\n      return moveElement(layout, itemToMove, undefined, collidesWith.y + 1, isUserAction, preventCollision, compactType, cols);\n    } else if (collisionNorth && compactType == null) {\n      collidesWith.y = itemToMove.y;\n      itemToMove.y = itemToMove.y + itemToMove.h;\n      return layout;\n    } else if (collisionWest && compactH) {\n      return moveElement(layout, collidesWith, itemToMove.x, undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n  const newX = compactH ? itemToMove.x + 1 : undefined;\n  const newY = compactV ? itemToMove.y + 1 : undefined;\n  if (newX == null && newY == null) {\n    return layout;\n  }\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\nfunction perc(num /*: number*/) /*: string*/{\n  return num * 100 + \"%\";\n}\n\n/**\n * Helper functions to constrain dimensions of a GridItem\n */\nconst constrainWidth = (left /*: number*/, currentWidth /*: number*/, newWidth /*: number*/, containerWidth /*: number*/) => {\n  return left + newWidth > containerWidth ? currentWidth : newWidth;\n};\nconst constrainHeight = (top /*: number*/, currentHeight /*: number*/, newHeight /*: number*/) => {\n  return top < 0 ? currentHeight : newHeight;\n};\nconst constrainLeft = (left /*: number*/) => Math.max(0, left);\nconst constrainTop = (top /*: number*/) => Math.max(0, top);\nconst resizeNorth = (currentSize, _ref, _containerWidth) => {\n  let {\n    left,\n    height,\n    width\n  } = _ref;\n  const top = currentSize.top - (height - currentSize.height);\n  return {\n    left,\n    width,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\nconst resizeEast = (currentSize, _ref2, containerWidth) => {\n  let {\n    top,\n    left,\n    height,\n    width\n  } = _ref2;\n  return {\n    top,\n    height,\n    width: constrainWidth(currentSize.left, currentSize.width, width, containerWidth),\n    left: constrainLeft(left)\n  };\n};\nconst resizeWest = (currentSize, _ref3, containerWidth) => {\n  let {\n    top,\n    height,\n    width\n  } = _ref3;\n  const left = currentSize.left - (width - currentSize.width);\n  return {\n    height,\n    width: left < 0 ? currentSize.width : constrainWidth(currentSize.left, currentSize.width, width, containerWidth),\n    top: constrainTop(top),\n    left: constrainLeft(left)\n  };\n};\nconst resizeSouth = (currentSize, _ref4, containerWidth) => {\n  let {\n    top,\n    left,\n    height,\n    width\n  } = _ref4;\n  return {\n    width,\n    left,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\nconst resizeNorthEast = function () {\n  return resizeNorth(arguments.length <= 0 ? undefined : arguments[0], resizeEast(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeNorthWest = function () {\n  return resizeNorth(arguments.length <= 0 ? undefined : arguments[0], resizeWest(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeSouthEast = function () {\n  return resizeSouth(arguments.length <= 0 ? undefined : arguments[0], resizeEast(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeSouthWest = function () {\n  return resizeSouth(arguments.length <= 0 ? undefined : arguments[0], resizeWest(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst ordinalResizeHandlerMap = {\n  n: resizeNorth,\n  ne: resizeNorthEast,\n  e: resizeEast,\n  se: resizeSouthEast,\n  s: resizeSouth,\n  sw: resizeSouthWest,\n  w: resizeWest,\n  nw: resizeNorthWest\n};\n\n/**\n * Helper for clamping width and position when resizing an item.\n */\nfunction resizeItemInDirection(direction /*: ResizeHandleAxis*/, currentSize /*: Position*/, newSize /*: Position*/, containerWidth /*: number*/) /*: Position*/{\n  const ordinalHandler = ordinalResizeHandlerMap[direction];\n  // Shouldn't be possible given types; that said, don't fail hard\n  if (!ordinalHandler) return newSize;\n  return ordinalHandler(currentSize, {\n    ...currentSize,\n    ...newSize\n  }, containerWidth);\n}\nfunction setTransform(_ref5 /*:: */) /*: Object*/{\n  let {\n    top,\n    left,\n    width,\n    height\n  } /*: Position*/ = _ref5 /*: Position*/;\n  // Replace unitless items with px\n  const translate = `translate(${left}px,${top}px)`;\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\nfunction setTopLeft(_ref6 /*:: */) /*: Object*/{\n  let {\n    top,\n    left,\n    width,\n    height\n  } /*: Position*/ = _ref6 /*: Position*/;\n  return {\n    top: `${top}px`,\n    left: `${left}px`,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\n\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\nfunction sortLayoutItems(layout /*: Layout*/, compactType /*: CompactType*/) /*: Layout*/{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);\n  if (compactType === \"vertical\") return sortLayoutItemsByRowCol(layout);else return layout;\n}\n\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\nfunction sortLayoutItemsByRowCol(layout /*: Layout*/) /*: Layout*/{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n    return -1;\n  });\n}\n\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\nfunction sortLayoutItemsByColRow(layout /*: Layout*/) /*: Layout*/{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n    return -1;\n  });\n}\n\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\nfunction synchronizeLayoutWithChildren(initialLayout /*: Layout*/, children /*: ReactChildren*/, cols /*: number*/, compactType /*: CompactType*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  initialLayout = initialLayout || [];\n\n  // Generate one layout item per child.\n  const layout /*: LayoutItem[]*/ = [];\n  _react.default.Children.forEach(children, (child /*: ReactElement<any>*/) => {\n    // Child may not exist\n    if (child?.key == null) return;\n    const exists = getLayoutItem(initialLayout, String(child.key));\n    const g = child.props[\"data-grid\"];\n    // Don't overwrite the layout item if it's already in the initial layout.\n    // If it has a `data-grid` property, prefer that over what's in the layout.\n    if (exists && g == null) {\n      layout.push(cloneLayoutItem(exists));\n    } else {\n      // Hey, this item has a data-grid property, use it.\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        }\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          ...g,\n          i: child.key\n        }));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        }));\n      }\n    }\n  });\n\n  // Correct the layout.\n  const correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return allowOverlap ? correctedLayout : compact(correctedLayout, compactType, cols);\n}\n\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\nfunction validateLayout(layout /*: Layout*/) /*: void*/{\n  let contextName /*: string*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  const subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const item = layout[i];\n    for (let j = 0; j < subProps.length; j++) {\n      const key = subProps[j];\n      const value = item[key];\n      if (typeof value !== \"number\" || Number.isNaN(value)) {\n        throw new Error(`ReactGridLayout: ${contextName}[${i}].${key} must be a number! Received: ${value} (${typeof value})`);\n      }\n    }\n    if (typeof item.i !== \"undefined\" && typeof item.i !== \"string\") {\n      throw new Error(`ReactGridLayout: ${contextName}[${i}].i must be a string! Received: ${item.i} (${typeof item.i})`);\n    }\n  }\n}\n\n// Legacy support for verticalCompact: false\nfunction compactType(props /*: ?{ verticalCompact: boolean, compactType: CompactType }*/) /*: CompactType*/{\n  const {\n    verticalCompact,\n    compactType\n  } = props || {};\n  return verticalCompact === false ? null : compactType;\n}\nfunction log() {\n  if (!DEBUG) return;\n  // eslint-disable-next-line no-console\n  console.log(...arguments);\n}\nconst noop = () => {};\nexports.noop = noop;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL3V0aWxzLmpzP2EwOGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmJvdHRvbSA9IGJvdHRvbTtcbmV4cG9ydHMuY2hpbGRyZW5FcXVhbCA9IGNoaWxkcmVuRXF1YWw7XG5leHBvcnRzLmNsb25lTGF5b3V0ID0gY2xvbmVMYXlvdXQ7XG5leHBvcnRzLmNsb25lTGF5b3V0SXRlbSA9IGNsb25lTGF5b3V0SXRlbTtcbmV4cG9ydHMuY29sbGlkZXMgPSBjb2xsaWRlcztcbmV4cG9ydHMuY29tcGFjdCA9IGNvbXBhY3Q7XG5leHBvcnRzLmNvbXBhY3RJdGVtID0gY29tcGFjdEl0ZW07XG5leHBvcnRzLmNvbXBhY3RUeXBlID0gY29tcGFjdFR5cGU7XG5leHBvcnRzLmNvcnJlY3RCb3VuZHMgPSBjb3JyZWN0Qm91bmRzO1xuZXhwb3J0cy5mYXN0UG9zaXRpb25FcXVhbCA9IGZhc3RQb3NpdGlvbkVxdWFsO1xuZXhwb3J0cy5mYXN0UkdMUHJvcHNFcXVhbCA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0QWxsQ29sbGlzaW9ucyA9IGdldEFsbENvbGxpc2lvbnM7XG5leHBvcnRzLmdldEZpcnN0Q29sbGlzaW9uID0gZ2V0Rmlyc3RDb2xsaXNpb247XG5leHBvcnRzLmdldExheW91dEl0ZW0gPSBnZXRMYXlvdXRJdGVtO1xuZXhwb3J0cy5nZXRTdGF0aWNzID0gZ2V0U3RhdGljcztcbmV4cG9ydHMubW9kaWZ5TGF5b3V0ID0gbW9kaWZ5TGF5b3V0O1xuZXhwb3J0cy5tb3ZlRWxlbWVudCA9IG1vdmVFbGVtZW50O1xuZXhwb3J0cy5tb3ZlRWxlbWVudEF3YXlGcm9tQ29sbGlzaW9uID0gbW92ZUVsZW1lbnRBd2F5RnJvbUNvbGxpc2lvbjtcbmV4cG9ydHMubm9vcCA9IHZvaWQgMDtcbmV4cG9ydHMucGVyYyA9IHBlcmM7XG5leHBvcnRzLnJlc2l6ZUl0ZW1JbkRpcmVjdGlvbiA9IHJlc2l6ZUl0ZW1JbkRpcmVjdGlvbjtcbmV4cG9ydHMuc2V0VG9wTGVmdCA9IHNldFRvcExlZnQ7XG5leHBvcnRzLnNldFRyYW5zZm9ybSA9IHNldFRyYW5zZm9ybTtcbmV4cG9ydHMuc29ydExheW91dEl0ZW1zID0gc29ydExheW91dEl0ZW1zO1xuZXhwb3J0cy5zb3J0TGF5b3V0SXRlbXNCeUNvbFJvdyA9IHNvcnRMYXlvdXRJdGVtc0J5Q29sUm93O1xuZXhwb3J0cy5zb3J0TGF5b3V0SXRlbXNCeVJvd0NvbCA9IHNvcnRMYXlvdXRJdGVtc0J5Um93Q29sO1xuZXhwb3J0cy5zeW5jaHJvbml6ZUxheW91dFdpdGhDaGlsZHJlbiA9IHN5bmNocm9uaXplTGF5b3V0V2l0aENoaWxkcmVuO1xuZXhwb3J0cy52YWxpZGF0ZUxheW91dCA9IHZhbGlkYXRlTGF5b3V0O1xuZXhwb3J0cy53aXRoTGF5b3V0SXRlbSA9IHdpdGhMYXlvdXRJdGVtO1xudmFyIF9mYXN0RXF1YWxzID0gcmVxdWlyZShcImZhc3QtZXF1YWxzXCIpO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG4vKjo6IGltcG9ydCB0eXBlIHtcbiAgQ2hpbGRyZW5BcnJheSBhcyBSZWFjdENoaWxkcmVuQXJyYXksXG4gIEVsZW1lbnQgYXMgUmVhY3RFbGVtZW50XG59IGZyb20gXCJyZWFjdFwiOyovXG4vKjo6IGV4cG9ydCB0eXBlIFJlc2l6ZUhhbmRsZUF4aXMgPVxuICB8IFwic1wiXG4gIHwgXCJ3XCJcbiAgfCBcImVcIlxuICB8IFwiblwiXG4gIHwgXCJzd1wiXG4gIHwgXCJud1wiXG4gIHwgXCJzZVwiXG4gIHwgXCJuZVwiOyovXG4vKjo6IGV4cG9ydCB0eXBlIExheW91dEl0ZW0gPSB7XG4gIHc6IG51bWJlcixcbiAgaDogbnVtYmVyLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgaTogc3RyaW5nLFxuICBtaW5XPzogbnVtYmVyLFxuICBtaW5IPzogbnVtYmVyLFxuICBtYXhXPzogbnVtYmVyLFxuICBtYXhIPzogbnVtYmVyLFxuICBtb3ZlZD86IGJvb2xlYW4sXG4gIHN0YXRpYz86IGJvb2xlYW4sXG4gIGlzRHJhZ2dhYmxlPzogP2Jvb2xlYW4sXG4gIGlzUmVzaXphYmxlPzogP2Jvb2xlYW4sXG4gIHJlc2l6ZUhhbmRsZXM/OiBBcnJheTxSZXNpemVIYW5kbGVBeGlzPixcbiAgaXNCb3VuZGVkPzogP2Jvb2xlYW5cbn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgTGF5b3V0ID0gJFJlYWRPbmx5QXJyYXk8TGF5b3V0SXRlbT47Ki9cbi8qOjogZXhwb3J0IHR5cGUgUG9zaXRpb24gPSB7XG4gIGxlZnQ6IG51bWJlcixcbiAgdG9wOiBudW1iZXIsXG4gIHdpZHRoOiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyXG59OyovXG4vKjo6IGV4cG9ydCB0eXBlIFJlYWN0RHJhZ2dhYmxlQ2FsbGJhY2tEYXRhID0ge1xuICBub2RlOiBIVE1MRWxlbWVudCxcbiAgeD86IG51bWJlcixcbiAgeT86IG51bWJlcixcbiAgZGVsdGFYOiBudW1iZXIsXG4gIGRlbHRhWTogbnVtYmVyLFxuICBsYXN0WD86IG51bWJlcixcbiAgbGFzdFk/OiBudW1iZXJcbn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgUGFydGlhbFBvc2l0aW9uID0geyBsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyIH07Ki9cbi8qOjogZXhwb3J0IHR5cGUgRHJvcHBpbmdQb3NpdGlvbiA9IHsgbGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgZTogRXZlbnQgfTsqL1xuLyo6OiBleHBvcnQgdHlwZSBTaXplID0geyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9OyovXG4vKjo6IGV4cG9ydCB0eXBlIEdyaWREcmFnRXZlbnQgPSB7XG4gIGU6IEV2ZW50LFxuICBub2RlOiBIVE1MRWxlbWVudCxcbiAgbmV3UG9zaXRpb246IFBhcnRpYWxQb3NpdGlvblxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBHcmlkUmVzaXplRXZlbnQgPSB7XG4gIGU6IEV2ZW50LFxuICBub2RlOiBIVE1MRWxlbWVudCxcbiAgc2l6ZTogU2l6ZSxcbiAgaGFuZGxlOiBzdHJpbmdcbn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgRHJhZ092ZXJFdmVudCA9IE1vdXNlRXZlbnQgJiB7XG4gIG5hdGl2ZUV2ZW50OiB7XG4gICAgbGF5ZXJYOiBudW1iZXIsXG4gICAgbGF5ZXJZOiBudW1iZXIsXG4gICAgLi4uRXZlbnRcbiAgfVxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBQaWNrPEZyb21UeXBlLCBQcm9wZXJ0aWVzOiB7IFtzdHJpbmddOiAwIH0+ID0gJEV4YWN0PFxuICAkT2JqTWFwaTxQcm9wZXJ0aWVzLCA8SywgVj4oazogSywgdjogVikgPT4gJEVsZW1lbnRUeXBlPEZyb21UeXBlLCBLPj5cbj47Ki9cbi8vIEhlbHBmdWwgcG9ydCBmcm9tIFRTXG4vKjo6IHR5cGUgUkVsID0gUmVhY3RFbGVtZW50PGFueT47Ki9cbi8qOjogZXhwb3J0IHR5cGUgUmVhY3RDaGlsZHJlbiA9IFJlYWN0Q2hpbGRyZW5BcnJheTxSRWw+OyovXG4vKjo6IGV4cG9ydCB0eXBlIEV2ZW50Q2FsbGJhY2sgPSAoXG4gIExheW91dCxcbiAgb2xkSXRlbTogP0xheW91dEl0ZW0sXG4gIG5ld0l0ZW06ID9MYXlvdXRJdGVtLFxuICBwbGFjZWhvbGRlcjogP0xheW91dEl0ZW0sXG4gIEV2ZW50LFxuICA/SFRNTEVsZW1lbnRcbikgPT4gdm9pZDsqL1xuLy8gQWxsIGNhbGxiYWNrcyBhcmUgb2YgdGhlIHNpZ25hdHVyZSAobGF5b3V0LCBvbGRJdGVtLCBuZXdJdGVtLCBwbGFjZWhvbGRlciwgZSkuXG4vKjo6IGV4cG9ydCB0eXBlIENvbXBhY3RUeXBlID0gPyhcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcIik7Ki9cbmNvbnN0IGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcbmNvbnN0IERFQlVHID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBib3R0b20gY29vcmRpbmF0ZSBvZiB0aGUgbGF5b3V0LlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBsYXlvdXQgTGF5b3V0IGFycmF5LlxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICBCb3R0b20gY29vcmRpbmF0ZS5cbiAqL1xuZnVuY3Rpb24gYm90dG9tKGxheW91dCAvKjogTGF5b3V0Ki8pIC8qOiBudW1iZXIqL3tcbiAgbGV0IG1heCA9IDAsXG4gICAgYm90dG9tWTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxheW91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJvdHRvbVkgPSBsYXlvdXRbaV0ueSArIGxheW91dFtpXS5oO1xuICAgIGlmIChib3R0b21ZID4gbWF4KSBtYXggPSBib3R0b21ZO1xuICB9XG4gIHJldHVybiBtYXg7XG59XG5mdW5jdGlvbiBjbG9uZUxheW91dChsYXlvdXQgLyo6IExheW91dCovKSAvKjogTGF5b3V0Ki97XG4gIGNvbnN0IG5ld0xheW91dCA9IEFycmF5KGxheW91dC5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmV3TGF5b3V0W2ldID0gY2xvbmVMYXlvdXRJdGVtKGxheW91dFtpXSk7XG4gIH1cbiAgcmV0dXJuIG5ld0xheW91dDtcbn1cblxuLy8gTW9kaWZ5IGEgbGF5b3V0SXRlbSBpbnNpZGUgYSBsYXlvdXQuIFJldHVybnMgYSBuZXcgTGF5b3V0LFxuLy8gZG9lcyBub3QgbXV0YXRlLiBDYXJyaWVzIG92ZXIgYWxsIG90aGVyIExheW91dEl0ZW1zIHVubW9kaWZpZWQuXG5mdW5jdGlvbiBtb2RpZnlMYXlvdXQobGF5b3V0IC8qOiBMYXlvdXQqLywgbGF5b3V0SXRlbSAvKjogTGF5b3V0SXRlbSovKSAvKjogTGF5b3V0Ki97XG4gIGNvbnN0IG5ld0xheW91dCA9IEFycmF5KGxheW91dC5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGxheW91dEl0ZW0uaSA9PT0gbGF5b3V0W2ldLmkpIHtcbiAgICAgIG5ld0xheW91dFtpXSA9IGxheW91dEl0ZW07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0xheW91dFtpXSA9IGxheW91dFtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0xheW91dDtcbn1cblxuLy8gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHRvIG1vZGlmeSBhIGxheW91dCBpdGVtLlxuLy8gRG9lcyBkZWZlbnNpdmUgY2xvbmVzIHRvIGVuc3VyZSB0aGUgbGF5b3V0IGlzIG5vdCBtb2RpZmllZC5cbmZ1bmN0aW9uIHdpdGhMYXlvdXRJdGVtKGxheW91dCAvKjogTGF5b3V0Ki8sIGl0ZW1LZXkgLyo6IHN0cmluZyovLCBjYiAvKjogTGF5b3V0SXRlbSA9PiBMYXlvdXRJdGVtKi8pIC8qOiBbTGF5b3V0LCA/TGF5b3V0SXRlbV0qL3tcbiAgbGV0IGl0ZW0gPSBnZXRMYXlvdXRJdGVtKGxheW91dCwgaXRlbUtleSk7XG4gIGlmICghaXRlbSkgcmV0dXJuIFtsYXlvdXQsIG51bGxdO1xuICBpdGVtID0gY2IoY2xvbmVMYXlvdXRJdGVtKGl0ZW0pKTsgLy8gZGVmZW5zaXZlIGNsb25lIHRoZW4gbW9kaWZ5XG4gIC8vIEZJWE1FIGNvdWxkIGRvIHRoaXMgZmFzdGVyIGlmIHdlIGFscmVhZHkga25ldyB0aGUgaW5kZXhcbiAgbGF5b3V0ID0gbW9kaWZ5TGF5b3V0KGxheW91dCwgaXRlbSk7XG4gIHJldHVybiBbbGF5b3V0LCBpdGVtXTtcbn1cblxuLy8gRmFzdCBwYXRoIHRvIGNsb25pbmcsIHNpbmNlIHRoaXMgaXMgbW9ub21vcnBoaWNcbmZ1bmN0aW9uIGNsb25lTGF5b3V0SXRlbShsYXlvdXRJdGVtIC8qOiBMYXlvdXRJdGVtKi8pIC8qOiBMYXlvdXRJdGVtKi97XG4gIHJldHVybiB7XG4gICAgdzogbGF5b3V0SXRlbS53LFxuICAgIGg6IGxheW91dEl0ZW0uaCxcbiAgICB4OiBsYXlvdXRJdGVtLngsXG4gICAgeTogbGF5b3V0SXRlbS55LFxuICAgIGk6IGxheW91dEl0ZW0uaSxcbiAgICBtaW5XOiBsYXlvdXRJdGVtLm1pblcsXG4gICAgbWF4VzogbGF5b3V0SXRlbS5tYXhXLFxuICAgIG1pbkg6IGxheW91dEl0ZW0ubWluSCxcbiAgICBtYXhIOiBsYXlvdXRJdGVtLm1heEgsXG4gICAgbW92ZWQ6IEJvb2xlYW4obGF5b3V0SXRlbS5tb3ZlZCksXG4gICAgc3RhdGljOiBCb29sZWFuKGxheW91dEl0ZW0uc3RhdGljKSxcbiAgICAvLyBUaGVzZSBjYW4gYmUgbnVsbC91bmRlZmluZWRcbiAgICBpc0RyYWdnYWJsZTogbGF5b3V0SXRlbS5pc0RyYWdnYWJsZSxcbiAgICBpc1Jlc2l6YWJsZTogbGF5b3V0SXRlbS5pc1Jlc2l6YWJsZSxcbiAgICByZXNpemVIYW5kbGVzOiBsYXlvdXRJdGVtLnJlc2l6ZUhhbmRsZXMsXG4gICAgaXNCb3VuZGVkOiBsYXlvdXRJdGVtLmlzQm91bmRlZFxuICB9O1xufVxuXG4vKipcbiAqIENvbXBhcmluZyBSZWFjdCBgY2hpbGRyZW5gIGlzIGEgYml0IGRpZmZpY3VsdC4gVGhpcyBpcyBhIGdvb2Qgd2F5IHRvIGNvbXBhcmUgdGhlbS5cbiAqIFRoaXMgd2lsbCBjYXRjaCBkaWZmZXJlbmNlcyBpbiBrZXlzLCBvcmRlciwgYW5kIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gY2hpbGRyZW5FcXVhbChhIC8qOiBSZWFjdENoaWxkcmVuKi8sIGIgLyo6IFJlYWN0Q2hpbGRyZW4qLykgLyo6IGJvb2xlYW4qL3tcbiAgcmV0dXJuICgwLCBfZmFzdEVxdWFscy5kZWVwRXF1YWwpKF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm1hcChhLCBjID0+IGM/LmtleSksIF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm1hcChiLCBjID0+IGM/LmtleSkpICYmICgwLCBfZmFzdEVxdWFscy5kZWVwRXF1YWwpKF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm1hcChhLCBjID0+IGM/LnByb3BzW1wiZGF0YS1ncmlkXCJdKSwgX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ubWFwKGIsIGMgPT4gYz8ucHJvcHNbXCJkYXRhLWdyaWRcIl0pKTtcbn1cblxuLyoqXG4gKiBTZWUgYGZhc3RSR0xQcm9wc0VxdWFsLmpzYC5cbiAqIFdlIHdhbnQgdGhpcyB0byBydW4gYXMgZmFzdCBhcyBwb3NzaWJsZSAtIGl0IGlzIGNhbGxlZCBvZnRlbiAtIGFuZCB0byBiZVxuICogcmVzaWxpZW50IHRvIG5ldyBwcm9wcyB0aGF0IHdlIGFkZC4gU28gcmF0aGVyIHRoYW4gY2FsbCBsb2Rhc2guaXNFcXVhbCxcbiAqIHdoaWNoIGlzbid0IHN1aXRlZCB0byBjb21wYXJpbmcgcHJvcHMgdmVyeSB3ZWxsLCB3ZSB1c2UgdGhpcyBzcGVjaWFsaXplZFxuICogZnVuY3Rpb24gaW4gY29uanVuY3Rpb24gd2l0aCBwcmV2YWwgdG8gZ2VuZXJhdGUgdGhlIGZhc3Rlc3QgcG9zc2libGUgY29tcGFyaXNvblxuICogZnVuY3Rpb24sIHR1bmVkIGZvciBleGFjdGx5IG91ciBwcm9wcy5cbiAqL1xuLyo6OiB0eXBlIEZhc3RSR0xQcm9wc0VxdWFsID0gKE9iamVjdCwgT2JqZWN0LCBGdW5jdGlvbikgPT4gYm9vbGVhbjsqL1xuY29uc3QgZmFzdFJHTFByb3BzRXF1YWwgLyo6IEZhc3RSR0xQcm9wc0VxdWFsKi8gPSBleHBvcnRzLmZhc3RSR0xQcm9wc0VxdWFsID0gcmVxdWlyZShcIi4vZmFzdFJHTFByb3BzRXF1YWxcIik7XG5cbi8vIExpa2UgdGhlIGFib3ZlLCBidXQgYSBsb3Qgc2ltcGxlci5cbmZ1bmN0aW9uIGZhc3RQb3NpdGlvbkVxdWFsKGEgLyo6IFBvc2l0aW9uKi8sIGIgLyo6IFBvc2l0aW9uKi8pIC8qOiBib29sZWFuKi97XG4gIHJldHVybiBhLmxlZnQgPT09IGIubGVmdCAmJiBhLnRvcCA9PT0gYi50b3AgJiYgYS53aWR0aCA9PT0gYi53aWR0aCAmJiBhLmhlaWdodCA9PT0gYi5oZWlnaHQ7XG59XG5cbi8qKlxuICogR2l2ZW4gdHdvIGxheW91dGl0ZW1zLCBjaGVjayBpZiB0aGV5IGNvbGxpZGUuXG4gKi9cbmZ1bmN0aW9uIGNvbGxpZGVzKGwxIC8qOiBMYXlvdXRJdGVtKi8sIGwyIC8qOiBMYXlvdXRJdGVtKi8pIC8qOiBib29sZWFuKi97XG4gIGlmIChsMS5pID09PSBsMi5pKSByZXR1cm4gZmFsc2U7IC8vIHNhbWUgZWxlbWVudFxuICBpZiAobDEueCArIGwxLncgPD0gbDIueCkgcmV0dXJuIGZhbHNlOyAvLyBsMSBpcyBsZWZ0IG9mIGwyXG4gIGlmIChsMS54ID49IGwyLnggKyBsMi53KSByZXR1cm4gZmFsc2U7IC8vIGwxIGlzIHJpZ2h0IG9mIGwyXG4gIGlmIChsMS55ICsgbDEuaCA8PSBsMi55KSByZXR1cm4gZmFsc2U7IC8vIGwxIGlzIGFib3ZlIGwyXG4gIGlmIChsMS55ID49IGwyLnkgKyBsMi5oKSByZXR1cm4gZmFsc2U7IC8vIGwxIGlzIGJlbG93IGwyXG4gIHJldHVybiB0cnVlOyAvLyBib3hlcyBvdmVybGFwXG59XG5cbi8qKlxuICogR2l2ZW4gYSBsYXlvdXQsIGNvbXBhY3QgaXQuIFRoaXMgaW52b2x2ZXMgZ29pbmcgZG93biBlYWNoIHkgY29vcmRpbmF0ZSBhbmQgcmVtb3ZpbmcgZ2Fwc1xuICogYmV0d2VlbiBpdGVtcy5cbiAqXG4gKiBEb2VzIG5vdCBtb2RpZnkgbGF5b3V0IGl0ZW1zIChjbG9uZXMpLiBDcmVhdGVzIGEgbmV3IGxheW91dCBhcnJheS5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gbGF5b3V0IExheW91dC5cbiAqIEBwYXJhbSAge0Jvb2xlYW59IHZlcnRpY2FsQ29tcGFjdCBXaGV0aGVyIG9yIG5vdCB0byBjb21wYWN0IHRoZSBsYXlvdXRcbiAqICAgdmVydGljYWxseS5cbiAqIEBwYXJhbSAge0Jvb2xlYW59IGFsbG93T3ZlcmxhcCBXaGVuIGB0cnVlYCwgYWxsb3dzIG92ZXJsYXBwaW5nIGdyaWQgaXRlbXMuXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgQ29tcGFjdGVkIExheW91dC5cbiAqL1xuZnVuY3Rpb24gY29tcGFjdChsYXlvdXQgLyo6IExheW91dCovLCBjb21wYWN0VHlwZSAvKjogQ29tcGFjdFR5cGUqLywgY29scyAvKjogbnVtYmVyKi8sIGFsbG93T3ZlcmxhcCAvKjogP2Jvb2xlYW4qLykgLyo6IExheW91dCove1xuICAvLyBTdGF0aWNzIGdvIGluIHRoZSBjb21wYXJlV2l0aCBhcnJheSByaWdodCBhd2F5IHNvIGl0ZW1zIGZsb3cgYXJvdW5kIHRoZW0uXG4gIGNvbnN0IGNvbXBhcmVXaXRoID0gZ2V0U3RhdGljcyhsYXlvdXQpO1xuICAvLyBXZSBnbyB0aHJvdWdoIHRoZSBpdGVtcyBieSByb3cgYW5kIGNvbHVtbi5cbiAgY29uc3Qgc29ydGVkID0gc29ydExheW91dEl0ZW1zKGxheW91dCwgY29tcGFjdFR5cGUpO1xuICAvLyBIb2xkaW5nIGZvciBuZXcgaXRlbXMuXG4gIGNvbnN0IG91dCA9IEFycmF5KGxheW91dC5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gc29ydGVkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbGV0IGwgPSBjbG9uZUxheW91dEl0ZW0oc29ydGVkW2ldKTtcblxuICAgIC8vIERvbid0IG1vdmUgc3RhdGljIGVsZW1lbnRzXG4gICAgaWYgKCFsLnN0YXRpYykge1xuICAgICAgbCA9IGNvbXBhY3RJdGVtKGNvbXBhcmVXaXRoLCBsLCBjb21wYWN0VHlwZSwgY29scywgc29ydGVkLCBhbGxvd092ZXJsYXApO1xuXG4gICAgICAvLyBBZGQgdG8gY29tcGFyaXNvbiBhcnJheS4gV2Ugb25seSBjb2xsaWRlIHdpdGggaXRlbXMgYmVmb3JlIHRoaXMgb25lLlxuICAgICAgLy8gU3RhdGljcyBhcmUgYWxyZWFkeSBpbiB0aGlzIGFycmF5LlxuICAgICAgY29tcGFyZVdpdGgucHVzaChsKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdG8gb3V0cHV0IGFycmF5IHRvIG1ha2Ugc3VyZSB0aGV5IHN0aWxsIGNvbWUgb3V0IGluIHRoZSByaWdodCBvcmRlci5cbiAgICBvdXRbbGF5b3V0LmluZGV4T2Yoc29ydGVkW2ldKV0gPSBsO1xuXG4gICAgLy8gQ2xlYXIgbW92ZWQgZmxhZywgaWYgaXQgZXhpc3RzLlxuICAgIGwubW92ZWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuY29uc3QgaGVpZ2h0V2lkdGggPSB7XG4gIHg6IFwid1wiLFxuICB5OiBcImhcIlxufTtcbi8qKlxuICogQmVmb3JlIG1vdmluZyBpdGVtIGRvd24sIGl0IHdpbGwgY2hlY2sgaWYgdGhlIG1vdmVtZW50IHdpbGwgY2F1c2UgY29sbGlzaW9ucyBhbmQgbW92ZSB0aG9zZSBpdGVtcyBkb3duIGJlZm9yZS5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUNvbXBhY3Rpb25Db2xsaXNpb24obGF5b3V0IC8qOiBMYXlvdXQqLywgaXRlbSAvKjogTGF5b3V0SXRlbSovLCBtb3ZlVG9Db29yZCAvKjogbnVtYmVyKi8sIGF4aXMgLyo6IFwieFwiIHwgXCJ5XCIqLykge1xuICBjb25zdCBzaXplUHJvcCA9IGhlaWdodFdpZHRoW2F4aXNdO1xuICBpdGVtW2F4aXNdICs9IDE7XG4gIGNvbnN0IGl0ZW1JbmRleCA9IGxheW91dC5tYXAobGF5b3V0SXRlbSA9PiB7XG4gICAgcmV0dXJuIGxheW91dEl0ZW0uaTtcbiAgfSkuaW5kZXhPZihpdGVtLmkpO1xuXG4gIC8vIEdvIHRocm91Z2ggZWFjaCBpdGVtIHdlIGNvbGxpZGUgd2l0aC5cbiAgZm9yIChsZXQgaSA9IGl0ZW1JbmRleCArIDE7IGkgPCBsYXlvdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBvdGhlckl0ZW0gPSBsYXlvdXRbaV07XG4gICAgLy8gSWdub3JlIHN0YXRpYyBpdGVtc1xuICAgIGlmIChvdGhlckl0ZW0uc3RhdGljKSBjb250aW51ZTtcblxuICAgIC8vIE9wdGltaXphdGlvbjogd2UgY2FuIGJyZWFrIGVhcmx5IGlmIHdlIGtub3cgd2UncmUgcGFzdCB0aGlzIGVsXG4gICAgLy8gV2UgY2FuIGRvIHRoaXMgYi9jIGl0J3MgYSBzb3J0ZWQgbGF5b3V0XG4gICAgaWYgKG90aGVySXRlbS55ID4gaXRlbS55ICsgaXRlbS5oKSBicmVhaztcbiAgICBpZiAoY29sbGlkZXMoaXRlbSwgb3RoZXJJdGVtKSkge1xuICAgICAgcmVzb2x2ZUNvbXBhY3Rpb25Db2xsaXNpb24obGF5b3V0LCBvdGhlckl0ZW0sIG1vdmVUb0Nvb3JkICsgaXRlbVtzaXplUHJvcF0sIGF4aXMpO1xuICAgIH1cbiAgfVxuICBpdGVtW2F4aXNdID0gbW92ZVRvQ29vcmQ7XG59XG5cbi8qKlxuICogQ29tcGFjdCBhbiBpdGVtIGluIHRoZSBsYXlvdXQuXG4gKlxuICogTW9kaWZpZXMgaXRlbS5cbiAqXG4gKi9cbmZ1bmN0aW9uIGNvbXBhY3RJdGVtKGNvbXBhcmVXaXRoIC8qOiBMYXlvdXQqLywgbCAvKjogTGF5b3V0SXRlbSovLCBjb21wYWN0VHlwZSAvKjogQ29tcGFjdFR5cGUqLywgY29scyAvKjogbnVtYmVyKi8sIGZ1bGxMYXlvdXQgLyo6IExheW91dCovLCBhbGxvd092ZXJsYXAgLyo6ID9ib29sZWFuKi8pIC8qOiBMYXlvdXRJdGVtKi97XG4gIGNvbnN0IGNvbXBhY3RWID0gY29tcGFjdFR5cGUgPT09IFwidmVydGljYWxcIjtcbiAgY29uc3QgY29tcGFjdEggPSBjb21wYWN0VHlwZSA9PT0gXCJob3Jpem9udGFsXCI7XG4gIGlmIChjb21wYWN0Vikge1xuICAgIC8vIEJvdHRvbSAneScgcG9zc2libGUgaXMgdGhlIGJvdHRvbSBvZiB0aGUgbGF5b3V0LlxuICAgIC8vIFRoaXMgYWxsb3dzIHlvdSB0byBkbyBuaWNlIHN0dWZmIGxpa2Ugc3BlY2lmeSB7eTogSW5maW5pdHl9XG4gICAgLy8gVGhpcyBpcyBoZXJlIGJlY2F1c2UgdGhlIGxheW91dCBtdXN0IGJlIHNvcnRlZCBpbiBvcmRlciB0byBnZXQgdGhlIGNvcnJlY3QgYm90dG9tIGB5YC5cbiAgICBsLnkgPSBNYXRoLm1pbihib3R0b20oY29tcGFyZVdpdGgpLCBsLnkpO1xuICAgIC8vIE1vdmUgdGhlIGVsZW1lbnQgdXAgYXMgZmFyIGFzIGl0IGNhbiBnbyB3aXRob3V0IGNvbGxpZGluZy5cbiAgICB3aGlsZSAobC55ID4gMCAmJiAhZ2V0Rmlyc3RDb2xsaXNpb24oY29tcGFyZVdpdGgsIGwpKSB7XG4gICAgICBsLnktLTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29tcGFjdEgpIHtcbiAgICAvLyBNb3ZlIHRoZSBlbGVtZW50IGxlZnQgYXMgZmFyIGFzIGl0IGNhbiBnbyB3aXRob3V0IGNvbGxpZGluZy5cbiAgICB3aGlsZSAobC54ID4gMCAmJiAhZ2V0Rmlyc3RDb2xsaXNpb24oY29tcGFyZVdpdGgsIGwpKSB7XG4gICAgICBsLngtLTtcbiAgICB9XG4gIH1cblxuICAvLyBNb3ZlIGl0IGRvd24sIGFuZCBrZWVwIG1vdmluZyBpdCBkb3duIGlmIGl0J3MgY29sbGlkaW5nLlxuICBsZXQgY29sbGlkZXM7XG4gIC8vIENoZWNraW5nIHRoZSBjb21wYWN0VHlwZSBudWxsIHZhbHVlIHRvIGF2b2lkIGJyZWFraW5nIHRoZSBsYXlvdXQgd2hlbiBvdmVybGFwcGluZyBpcyBhbGxvd2VkLlxuICB3aGlsZSAoKGNvbGxpZGVzID0gZ2V0Rmlyc3RDb2xsaXNpb24oY29tcGFyZVdpdGgsIGwpKSAmJiAhKGNvbXBhY3RUeXBlID09PSBudWxsICYmIGFsbG93T3ZlcmxhcCkpIHtcbiAgICBpZiAoY29tcGFjdEgpIHtcbiAgICAgIHJlc29sdmVDb21wYWN0aW9uQ29sbGlzaW9uKGZ1bGxMYXlvdXQsIGwsIGNvbGxpZGVzLnggKyBjb2xsaWRlcy53LCBcInhcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVDb21wYWN0aW9uQ29sbGlzaW9uKGZ1bGxMYXlvdXQsIGwsIGNvbGxpZGVzLnkgKyBjb2xsaWRlcy5oLCBcInlcIik7XG4gICAgfVxuICAgIC8vIFNpbmNlIHdlIGNhbid0IGdyb3cgd2l0aG91dCBib3VuZHMgaG9yaXpvbnRhbGx5LCBpZiB3ZSd2ZSBvdmVyZmxvd24sIGxldCdzIG1vdmUgaXQgZG93biBhbmQgdHJ5IGFnYWluLlxuICAgIGlmIChjb21wYWN0SCAmJiBsLnggKyBsLncgPiBjb2xzKSB7XG4gICAgICBsLnggPSBjb2xzIC0gbC53O1xuICAgICAgbC55Kys7XG4gICAgICAvLyBBTHNvIG1vdmUgZWxlbWVudCBhcyBsZWZ0IGFzIHdlIGNhblxuICAgICAgd2hpbGUgKGwueCA+IDAgJiYgIWdldEZpcnN0Q29sbGlzaW9uKGNvbXBhcmVXaXRoLCBsKSkge1xuICAgICAgICBsLngtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBFbnN1cmUgdGhhdCB0aGVyZSBhcmUgbm8gbmVnYXRpdmUgcG9zaXRpb25zXG4gIGwueSA9IE1hdGgubWF4KGwueSwgMCk7XG4gIGwueCA9IE1hdGgubWF4KGwueCwgMCk7XG4gIHJldHVybiBsO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgbGF5b3V0LCBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGZpdCB3aXRoaW4gaXRzIGJvdW5kcy5cbiAqXG4gKiBNb2RpZmllcyBsYXlvdXQgaXRlbXMuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGxheW91dCBMYXlvdXQgYXJyYXkuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGJvdW5kcyBOdW1iZXIgb2YgY29sdW1ucy5cbiAqL1xuZnVuY3Rpb24gY29ycmVjdEJvdW5kcyhsYXlvdXQgLyo6IExheW91dCovLCBib3VuZHMgLyo6IHsgY29sczogbnVtYmVyIH0qLykgLyo6IExheW91dCove1xuICBjb25zdCBjb2xsaWRlc1dpdGggPSBnZXRTdGF0aWNzKGxheW91dCk7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsYXlvdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBsID0gbGF5b3V0W2ldO1xuICAgIC8vIE92ZXJmbG93cyByaWdodFxuICAgIGlmIChsLnggKyBsLncgPiBib3VuZHMuY29scykgbC54ID0gYm91bmRzLmNvbHMgLSBsLnc7XG4gICAgLy8gT3ZlcmZsb3dzIGxlZnRcbiAgICBpZiAobC54IDwgMCkge1xuICAgICAgbC54ID0gMDtcbiAgICAgIGwudyA9IGJvdW5kcy5jb2xzO1xuICAgIH1cbiAgICBpZiAoIWwuc3RhdGljKSBjb2xsaWRlc1dpdGgucHVzaChsKTtlbHNlIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgc3RhdGljIGFuZCBjb2xsaWRlcyB3aXRoIG90aGVyIHN0YXRpY3MsIHdlIG11c3QgbW92ZSBpdCBkb3duLlxuICAgICAgLy8gV2UgaGF2ZSB0byBkbyBzb21ldGhpbmcgbmljZXIgdGhhbiBqdXN0IGxldHRpbmcgdGhlbSBvdmVybGFwLlxuICAgICAgd2hpbGUgKGdldEZpcnN0Q29sbGlzaW9uKGNvbGxpZGVzV2l0aCwgbCkpIHtcbiAgICAgICAgbC55Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBsYXlvdXQ7XG59XG5cbi8qKlxuICogR2V0IGEgbGF5b3V0IGl0ZW0gYnkgSUQuIFVzZWQgc28gd2UgY2FuIG92ZXJyaWRlIGxhdGVyIG9uIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gIGxheW91dCBMYXlvdXQgYXJyYXkuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGlkICAgICBJRFxuICogQHJldHVybiB7TGF5b3V0SXRlbX0gICAgSXRlbSBhdCBJRC5cbiAqL1xuZnVuY3Rpb24gZ2V0TGF5b3V0SXRlbShsYXlvdXQgLyo6IExheW91dCovLCBpZCAvKjogc3RyaW5nKi8pIC8qOiA/TGF5b3V0SXRlbSove1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGxheW91dFtpXS5pID09PSBpZCkgcmV0dXJuIGxheW91dFtpXTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGl0ZW0gdGhpcyBsYXlvdXQgY29sbGlkZXMgd2l0aC5cbiAqIEl0IGRvZXNuJ3QgYXBwZWFyIHRvIG1hdHRlciB3aGljaCBvcmRlciB3ZSBhcHByb2FjaCB0aGlzIGZyb20sIGFsdGhvdWdoXG4gKiBwZXJoYXBzIHRoYXQgaXMgdGhlIHdyb25nIHRoaW5nIHRvIGRvLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gbGF5b3V0SXRlbSBMYXlvdXQgaXRlbS5cbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9ICBBIGNvbGxpZGluZyBsYXlvdXQgaXRlbSwgb3IgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiBnZXRGaXJzdENvbGxpc2lvbihsYXlvdXQgLyo6IExheW91dCovLCBsYXlvdXRJdGVtIC8qOiBMYXlvdXRJdGVtKi8pIC8qOiA/TGF5b3V0SXRlbSove1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGNvbGxpZGVzKGxheW91dFtpXSwgbGF5b3V0SXRlbSkpIHJldHVybiBsYXlvdXRbaV07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEFsbENvbGxpc2lvbnMobGF5b3V0IC8qOiBMYXlvdXQqLywgbGF5b3V0SXRlbSAvKjogTGF5b3V0SXRlbSovKSAvKjogQXJyYXk8TGF5b3V0SXRlbT4qL3tcbiAgcmV0dXJuIGxheW91dC5maWx0ZXIobCA9PiBjb2xsaWRlcyhsLCBsYXlvdXRJdGVtKSk7XG59XG5cbi8qKlxuICogR2V0IGFsbCBzdGF0aWMgZWxlbWVudHMuXG4gKiBAcGFyYW0gIHtBcnJheX0gbGF5b3V0IEFycmF5IG9mIGxheW91dCBvYmplY3RzLlxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICBBcnJheSBvZiBzdGF0aWMgbGF5b3V0IGl0ZW1zLi5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGljcyhsYXlvdXQgLyo6IExheW91dCovKSAvKjogQXJyYXk8TGF5b3V0SXRlbT4qL3tcbiAgcmV0dXJuIGxheW91dC5maWx0ZXIobCA9PiBsLnN0YXRpYyk7XG59XG5cbi8qKlxuICogTW92ZSBhbiBlbGVtZW50LiBSZXNwb25zaWJsZSBmb3IgZG9pbmcgY2FzY2FkaW5nIG1vdmVtZW50cyBvZiBvdGhlciBlbGVtZW50cy5cbiAqXG4gKiBNb2RpZmllcyBsYXlvdXQgaXRlbXMuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgbGF5b3V0ICAgICAgICAgICAgRnVsbCBsYXlvdXQgdG8gbW9kaWZ5LlxuICogQHBhcmFtICB7TGF5b3V0SXRlbX0gbCAgICAgICAgICAgICAgICAgZWxlbWVudCB0byBtb3ZlLlxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgW3hdICAgICAgICAgICAgICAgWCBwb3NpdGlvbiBpbiBncmlkIHVuaXRzLlxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgW3ldICAgICAgICAgICAgICAgWSBwb3NpdGlvbiBpbiBncmlkIHVuaXRzLlxuICovXG5mdW5jdGlvbiBtb3ZlRWxlbWVudChsYXlvdXQgLyo6IExheW91dCovLCBsIC8qOiBMYXlvdXRJdGVtKi8sIHggLyo6ID9udW1iZXIqLywgeSAvKjogP251bWJlciovLCBpc1VzZXJBY3Rpb24gLyo6ID9ib29sZWFuKi8sIHByZXZlbnRDb2xsaXNpb24gLyo6ID9ib29sZWFuKi8sIGNvbXBhY3RUeXBlIC8qOiBDb21wYWN0VHlwZSovLCBjb2xzIC8qOiBudW1iZXIqLywgYWxsb3dPdmVybGFwIC8qOiA/Ym9vbGVhbiovKSAvKjogTGF5b3V0Ki97XG4gIC8vIElmIHRoaXMgaXMgc3RhdGljIGFuZCBub3QgZXhwbGljaXRseSBlbmFibGVkIGFzIGRyYWdnYWJsZSxcbiAgLy8gbm8gbW92ZSBpcyBwb3NzaWJsZSwgc28gd2UgY2FuIHNob3J0LWNpcmN1aXQgdGhpcyBpbW1lZGlhdGVseS5cbiAgaWYgKGwuc3RhdGljICYmIGwuaXNEcmFnZ2FibGUgIT09IHRydWUpIHJldHVybiBsYXlvdXQ7XG5cbiAgLy8gU2hvcnQtY2lyY3VpdCBpZiBub3RoaW5nIHRvIGRvLlxuICBpZiAobC55ID09PSB5ICYmIGwueCA9PT0geCkgcmV0dXJuIGxheW91dDtcbiAgbG9nKGBNb3ZpbmcgZWxlbWVudCAke2wuaX0gdG8gWyR7U3RyaW5nKHgpfSwke1N0cmluZyh5KX1dIGZyb20gWyR7bC54fSwke2wueX1dYCk7XG4gIGNvbnN0IG9sZFggPSBsLng7XG4gIGNvbnN0IG9sZFkgPSBsLnk7XG5cbiAgLy8gVGhpcyBpcyBxdWl0ZSBhIGJpdCBmYXN0ZXIgdGhhbiBleHRlbmRpbmcgdGhlIG9iamVjdFxuICBpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIGwueCA9IHg7XG4gIGlmICh0eXBlb2YgeSA9PT0gXCJudW1iZXJcIikgbC55ID0geTtcbiAgbC5tb3ZlZCA9IHRydWU7XG5cbiAgLy8gSWYgdGhpcyBjb2xsaWRlcyB3aXRoIGFueXRoaW5nLCBtb3ZlIGl0LlxuICAvLyBXaGVuIGRvaW5nIHRoaXMgY29tcGFyaXNvbiwgd2UgaGF2ZSB0byBzb3J0IHRoZSBpdGVtcyB3ZSBjb21wYXJlIHdpdGhcbiAgLy8gdG8gZW5zdXJlLCBpbiB0aGUgY2FzZSBvZiBtdWx0aXBsZSBjb2xsaXNpb25zLCB0aGF0IHdlJ3JlIGdldHRpbmcgdGhlXG4gIC8vIG5lYXJlc3QgY29sbGlzaW9uLlxuICBsZXQgc29ydGVkID0gc29ydExheW91dEl0ZW1zKGxheW91dCwgY29tcGFjdFR5cGUpO1xuICBjb25zdCBtb3ZpbmdVcCA9IGNvbXBhY3RUeXBlID09PSBcInZlcnRpY2FsXCIgJiYgdHlwZW9mIHkgPT09IFwibnVtYmVyXCIgPyBvbGRZID49IHkgOiBjb21wYWN0VHlwZSA9PT0gXCJob3Jpem9udGFsXCIgJiYgdHlwZW9mIHggPT09IFwibnVtYmVyXCIgPyBvbGRYID49IHggOiBmYWxzZTtcbiAgLy8gJEZsb3dJZ25vcmUgYWNjZXB0YWJsZSBtb2RpZmljYXRpb24gb2YgcmVhZC1vbmx5IGFycmF5IGFzIGl0IHdhcyByZWNlbnRseSBjbG9uZWRcbiAgaWYgKG1vdmluZ1VwKSBzb3J0ZWQgPSBzb3J0ZWQucmV2ZXJzZSgpO1xuICBjb25zdCBjb2xsaXNpb25zID0gZ2V0QWxsQ29sbGlzaW9ucyhzb3J0ZWQsIGwpO1xuICBjb25zdCBoYXNDb2xsaXNpb25zID0gY29sbGlzaW9ucy5sZW5ndGggPiAwO1xuXG4gIC8vIFdlIG1heSBoYXZlIGNvbGxpc2lvbnMuIFdlIGNhbiBzaG9ydC1jaXJjdWl0IGlmIHdlJ3ZlIHR1cm5lZCBvZmYgY29sbGlzaW9ucyBvclxuICAvLyBhbGxvd2VkIG92ZXJsYXAuXG4gIGlmIChoYXNDb2xsaXNpb25zICYmIGFsbG93T3ZlcmxhcCkge1xuICAgIC8vIEVhc3ksIHdlIGRvbid0IG5lZWQgdG8gcmVzb2x2ZSBjb2xsaXNpb25zLiBCdXQgd2UgKmRpZCogY2hhbmdlIHRoZSBsYXlvdXQsXG4gICAgLy8gc28gY2xvbmUgaXQgb24gdGhlIHdheSBvdXQuXG4gICAgcmV0dXJuIGNsb25lTGF5b3V0KGxheW91dCk7XG4gIH0gZWxzZSBpZiAoaGFzQ29sbGlzaW9ucyAmJiBwcmV2ZW50Q29sbGlzaW9uKSB7XG4gICAgLy8gSWYgd2UgYXJlIHByZXZlbnRpbmcgY29sbGlzaW9uIGJ1dCBub3QgYWxsb3dpbmcgb3ZlcmxhcCwgd2UgbmVlZCB0b1xuICAgIC8vIHJldmVydCB0aGUgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50IHNvIGl0IGdvZXMgdG8gd2hlcmUgaXQgY2FtZSBmcm9tLCByYXRoZXJcbiAgICAvLyB0aGFuIHRoZSB1c2VyJ3MgZGVzaXJlZCBsb2NhdGlvbi5cbiAgICBsb2coYENvbGxpc2lvbiBwcmV2ZW50ZWQgb24gJHtsLml9LCByZXZlcnRpbmcuYCk7XG4gICAgbC54ID0gb2xkWDtcbiAgICBsLnkgPSBvbGRZO1xuICAgIGwubW92ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gbGF5b3V0OyAvLyBkaWQgbm90IGNoYW5nZSBzbyBkb24ndCBjbG9uZVxuICB9XG5cbiAgLy8gTW92ZSBlYWNoIGl0ZW0gdGhhdCBjb2xsaWRlcyBhd2F5IGZyb20gdGhpcyBlbGVtZW50LlxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gY29sbGlzaW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNvbGxpc2lvbiA9IGNvbGxpc2lvbnNbaV07XG4gICAgbG9nKGBSZXNvbHZpbmcgY29sbGlzaW9uIGJldHdlZW4gJHtsLml9IGF0IFske2wueH0sJHtsLnl9XSBhbmQgJHtjb2xsaXNpb24uaX0gYXQgWyR7Y29sbGlzaW9uLnh9LCR7Y29sbGlzaW9uLnl9XWApO1xuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBzbyB3ZSBjYW4ndCBpbmZpbml0ZSBsb29wXG4gICAgaWYgKGNvbGxpc2lvbi5tb3ZlZCkgY29udGludWU7XG5cbiAgICAvLyBEb24ndCBtb3ZlIHN0YXRpYyBpdGVtcyAtIHdlIGhhdmUgdG8gbW92ZSAqdGhpcyogZWxlbWVudCBhd2F5XG4gICAgaWYgKGNvbGxpc2lvbi5zdGF0aWMpIHtcbiAgICAgIGxheW91dCA9IG1vdmVFbGVtZW50QXdheUZyb21Db2xsaXNpb24obGF5b3V0LCBjb2xsaXNpb24sIGwsIGlzVXNlckFjdGlvbiwgY29tcGFjdFR5cGUsIGNvbHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXlvdXQgPSBtb3ZlRWxlbWVudEF3YXlGcm9tQ29sbGlzaW9uKGxheW91dCwgbCwgY29sbGlzaW9uLCBpc1VzZXJBY3Rpb24sIGNvbXBhY3RUeXBlLCBjb2xzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxheW91dDtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIHdoZXJlIHRoZSBtYWdpYyBuZWVkcyB0byBoYXBwZW4gLSBnaXZlbiBhIGNvbGxpc2lvbiwgbW92ZSBhbiBlbGVtZW50IGF3YXkgZnJvbSB0aGUgY29sbGlzaW9uLlxuICogV2UgYXR0ZW1wdCB0byBtb3ZlIGl0IHVwIGlmIHRoZXJlJ3Mgcm9vbSwgb3RoZXJ3aXNlIGl0IGdvZXMgYmVsb3cuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGxheW91dCAgICAgICAgICAgIEZ1bGwgbGF5b3V0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSAge0xheW91dEl0ZW19IGNvbGxpZGVzV2l0aCBMYXlvdXQgaXRlbSB3ZSdyZSBjb2xsaWRpbmcgd2l0aC5cbiAqIEBwYXJhbSAge0xheW91dEl0ZW19IGl0ZW1Ub01vdmUgICBMYXlvdXQgaXRlbSB3ZSdyZSBtb3ZpbmcuXG4gKi9cbmZ1bmN0aW9uIG1vdmVFbGVtZW50QXdheUZyb21Db2xsaXNpb24obGF5b3V0IC8qOiBMYXlvdXQqLywgY29sbGlkZXNXaXRoIC8qOiBMYXlvdXRJdGVtKi8sIGl0ZW1Ub01vdmUgLyo6IExheW91dEl0ZW0qLywgaXNVc2VyQWN0aW9uIC8qOiA/Ym9vbGVhbiovLCBjb21wYWN0VHlwZSAvKjogQ29tcGFjdFR5cGUqLywgY29scyAvKjogbnVtYmVyKi8pIC8qOiBMYXlvdXQqL3tcbiAgY29uc3QgY29tcGFjdEggPSBjb21wYWN0VHlwZSA9PT0gXCJob3Jpem9udGFsXCI7XG4gIC8vIENvbXBhY3QgdmVydGljYWxseSBpZiBub3Qgc2V0IHRvIGhvcml6b250YWxcbiAgY29uc3QgY29tcGFjdFYgPSBjb21wYWN0VHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiO1xuICBjb25zdCBwcmV2ZW50Q29sbGlzaW9uID0gY29sbGlkZXNXaXRoLnN0YXRpYzsgLy8gd2UncmUgYWxyZWFkeSBjb2xsaWRpbmcgKG5vdCBmb3Igc3RhdGljIGl0ZW1zKVxuXG4gIC8vIElmIHRoZXJlIGlzIGVub3VnaCBzcGFjZSBhYm92ZSB0aGUgY29sbGlzaW9uIHRvIHB1dCB0aGlzIGVsZW1lbnQsIG1vdmUgaXQgdGhlcmUuXG4gIC8vIFdlIG9ubHkgZG8gdGhpcyBvbiB0aGUgbWFpbiBjb2xsaXNpb24gYXMgdGhpcyBjYW4gZ2V0IGZ1bmt5IGluIGNhc2NhZGVzIGFuZCBjYXVzZVxuICAvLyB1bndhbnRlZCBzd2FwcGluZyBiZWhhdmlvci5cbiAgaWYgKGlzVXNlckFjdGlvbikge1xuICAgIC8vIFJlc2V0IGlzVXNlckFjdGlvbiBmbGFnIGJlY2F1c2Ugd2UncmUgbm90IGluIHRoZSBtYWluIGNvbGxpc2lvbiBhbnltb3JlLlxuICAgIGlzVXNlckFjdGlvbiA9IGZhbHNlO1xuXG4gICAgLy8gTWFrZSBhIG1vY2sgaXRlbSBzbyB3ZSBkb24ndCBtb2RpZnkgdGhlIGl0ZW0gaGVyZSwgb25seSBtb2RpZnkgaW4gbW92ZUVsZW1lbnQuXG4gICAgY29uc3QgZmFrZUl0ZW0gLyo6IExheW91dEl0ZW0qLyA9IHtcbiAgICAgIHg6IGNvbXBhY3RIID8gTWF0aC5tYXgoY29sbGlkZXNXaXRoLnggLSBpdGVtVG9Nb3ZlLncsIDApIDogaXRlbVRvTW92ZS54LFxuICAgICAgeTogY29tcGFjdFYgPyBNYXRoLm1heChjb2xsaWRlc1dpdGgueSAtIGl0ZW1Ub01vdmUuaCwgMCkgOiBpdGVtVG9Nb3ZlLnksXG4gICAgICB3OiBpdGVtVG9Nb3ZlLncsXG4gICAgICBoOiBpdGVtVG9Nb3ZlLmgsXG4gICAgICBpOiBcIi0xXCJcbiAgICB9O1xuICAgIGNvbnN0IGZpcnN0Q29sbGlzaW9uID0gZ2V0Rmlyc3RDb2xsaXNpb24obGF5b3V0LCBmYWtlSXRlbSk7XG4gICAgY29uc3QgY29sbGlzaW9uTm9ydGggPSBmaXJzdENvbGxpc2lvbiAmJiBmaXJzdENvbGxpc2lvbi55ICsgZmlyc3RDb2xsaXNpb24uaCA+IGNvbGxpZGVzV2l0aC55O1xuICAgIGNvbnN0IGNvbGxpc2lvbldlc3QgPSBmaXJzdENvbGxpc2lvbiAmJiBjb2xsaWRlc1dpdGgueCArIGNvbGxpZGVzV2l0aC53ID4gZmlyc3RDb2xsaXNpb24ueDtcblxuICAgIC8vIE5vIGNvbGxpc2lvbj8gSWYgc28sIHdlIGNhbiBnbyB1cCB0aGVyZTsgb3RoZXJ3aXNlLCB3ZSdsbCBlbmQgdXAgbW92aW5nIGRvd24gYXMgbm9ybWFsXG4gICAgaWYgKCFmaXJzdENvbGxpc2lvbikge1xuICAgICAgbG9nKGBEb2luZyByZXZlcnNlIGNvbGxpc2lvbiBvbiAke2l0ZW1Ub01vdmUuaX0gdXAgdG8gWyR7ZmFrZUl0ZW0ueH0sJHtmYWtlSXRlbS55fV0uYCk7XG4gICAgICByZXR1cm4gbW92ZUVsZW1lbnQobGF5b3V0LCBpdGVtVG9Nb3ZlLCBjb21wYWN0SCA/IGZha2VJdGVtLnggOiB1bmRlZmluZWQsIGNvbXBhY3RWID8gZmFrZUl0ZW0ueSA6IHVuZGVmaW5lZCwgaXNVc2VyQWN0aW9uLCBwcmV2ZW50Q29sbGlzaW9uLCBjb21wYWN0VHlwZSwgY29scyk7XG4gICAgfSBlbHNlIGlmIChjb2xsaXNpb25Ob3J0aCAmJiBjb21wYWN0Vikge1xuICAgICAgcmV0dXJuIG1vdmVFbGVtZW50KGxheW91dCwgaXRlbVRvTW92ZSwgdW5kZWZpbmVkLCBjb2xsaWRlc1dpdGgueSArIDEsIGlzVXNlckFjdGlvbiwgcHJldmVudENvbGxpc2lvbiwgY29tcGFjdFR5cGUsIGNvbHMpO1xuICAgIH0gZWxzZSBpZiAoY29sbGlzaW9uTm9ydGggJiYgY29tcGFjdFR5cGUgPT0gbnVsbCkge1xuICAgICAgY29sbGlkZXNXaXRoLnkgPSBpdGVtVG9Nb3ZlLnk7XG4gICAgICBpdGVtVG9Nb3ZlLnkgPSBpdGVtVG9Nb3ZlLnkgKyBpdGVtVG9Nb3ZlLmg7XG4gICAgICByZXR1cm4gbGF5b3V0O1xuICAgIH0gZWxzZSBpZiAoY29sbGlzaW9uV2VzdCAmJiBjb21wYWN0SCkge1xuICAgICAgcmV0dXJuIG1vdmVFbGVtZW50KGxheW91dCwgY29sbGlkZXNXaXRoLCBpdGVtVG9Nb3ZlLngsIHVuZGVmaW5lZCwgaXNVc2VyQWN0aW9uLCBwcmV2ZW50Q29sbGlzaW9uLCBjb21wYWN0VHlwZSwgY29scyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5ld1ggPSBjb21wYWN0SCA/IGl0ZW1Ub01vdmUueCArIDEgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG5ld1kgPSBjb21wYWN0ViA/IGl0ZW1Ub01vdmUueSArIDEgOiB1bmRlZmluZWQ7XG4gIGlmIChuZXdYID09IG51bGwgJiYgbmV3WSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGxheW91dDtcbiAgfVxuICByZXR1cm4gbW92ZUVsZW1lbnQobGF5b3V0LCBpdGVtVG9Nb3ZlLCBjb21wYWN0SCA/IGl0ZW1Ub01vdmUueCArIDEgOiB1bmRlZmluZWQsIGNvbXBhY3RWID8gaXRlbVRvTW92ZS55ICsgMSA6IHVuZGVmaW5lZCwgaXNVc2VyQWN0aW9uLCBwcmV2ZW50Q29sbGlzaW9uLCBjb21wYWN0VHlwZSwgY29scyk7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGNvbnZlcnQgYSBudW1iZXIgdG8gYSBwZXJjZW50YWdlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG51bSBBbnkgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICBUaGF0IG51bWJlciBhcyBhIHBlcmNlbnRhZ2UuXG4gKi9cbmZ1bmN0aW9uIHBlcmMobnVtIC8qOiBudW1iZXIqLykgLyo6IHN0cmluZyove1xuICByZXR1cm4gbnVtICogMTAwICsgXCIlXCI7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9ucyB0byBjb25zdHJhaW4gZGltZW5zaW9ucyBvZiBhIEdyaWRJdGVtXG4gKi9cbmNvbnN0IGNvbnN0cmFpbldpZHRoID0gKGxlZnQgLyo6IG51bWJlciovLCBjdXJyZW50V2lkdGggLyo6IG51bWJlciovLCBuZXdXaWR0aCAvKjogbnVtYmVyKi8sIGNvbnRhaW5lcldpZHRoIC8qOiBudW1iZXIqLykgPT4ge1xuICByZXR1cm4gbGVmdCArIG5ld1dpZHRoID4gY29udGFpbmVyV2lkdGggPyBjdXJyZW50V2lkdGggOiBuZXdXaWR0aDtcbn07XG5jb25zdCBjb25zdHJhaW5IZWlnaHQgPSAodG9wIC8qOiBudW1iZXIqLywgY3VycmVudEhlaWdodCAvKjogbnVtYmVyKi8sIG5ld0hlaWdodCAvKjogbnVtYmVyKi8pID0+IHtcbiAgcmV0dXJuIHRvcCA8IDAgPyBjdXJyZW50SGVpZ2h0IDogbmV3SGVpZ2h0O1xufTtcbmNvbnN0IGNvbnN0cmFpbkxlZnQgPSAobGVmdCAvKjogbnVtYmVyKi8pID0+IE1hdGgubWF4KDAsIGxlZnQpO1xuY29uc3QgY29uc3RyYWluVG9wID0gKHRvcCAvKjogbnVtYmVyKi8pID0+IE1hdGgubWF4KDAsIHRvcCk7XG5jb25zdCByZXNpemVOb3J0aCA9IChjdXJyZW50U2l6ZSwgX3JlZiwgX2NvbnRhaW5lcldpZHRoKSA9PiB7XG4gIGxldCB7XG4gICAgbGVmdCxcbiAgICBoZWlnaHQsXG4gICAgd2lkdGhcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHRvcCA9IGN1cnJlbnRTaXplLnRvcCAtIChoZWlnaHQgLSBjdXJyZW50U2l6ZS5oZWlnaHQpO1xuICByZXR1cm4ge1xuICAgIGxlZnQsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0OiBjb25zdHJhaW5IZWlnaHQodG9wLCBjdXJyZW50U2l6ZS5oZWlnaHQsIGhlaWdodCksXG4gICAgdG9wOiBjb25zdHJhaW5Ub3AodG9wKVxuICB9O1xufTtcbmNvbnN0IHJlc2l6ZUVhc3QgPSAoY3VycmVudFNpemUsIF9yZWYyLCBjb250YWluZXJXaWR0aCkgPT4ge1xuICBsZXQge1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIGhlaWdodCxcbiAgICB3aWR0aFxuICB9ID0gX3JlZjI7XG4gIHJldHVybiB7XG4gICAgdG9wLFxuICAgIGhlaWdodCxcbiAgICB3aWR0aDogY29uc3RyYWluV2lkdGgoY3VycmVudFNpemUubGVmdCwgY3VycmVudFNpemUud2lkdGgsIHdpZHRoLCBjb250YWluZXJXaWR0aCksXG4gICAgbGVmdDogY29uc3RyYWluTGVmdChsZWZ0KVxuICB9O1xufTtcbmNvbnN0IHJlc2l6ZVdlc3QgPSAoY3VycmVudFNpemUsIF9yZWYzLCBjb250YWluZXJXaWR0aCkgPT4ge1xuICBsZXQge1xuICAgIHRvcCxcbiAgICBoZWlnaHQsXG4gICAgd2lkdGhcbiAgfSA9IF9yZWYzO1xuICBjb25zdCBsZWZ0ID0gY3VycmVudFNpemUubGVmdCAtICh3aWR0aCAtIGN1cnJlbnRTaXplLndpZHRoKTtcbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQsXG4gICAgd2lkdGg6IGxlZnQgPCAwID8gY3VycmVudFNpemUud2lkdGggOiBjb25zdHJhaW5XaWR0aChjdXJyZW50U2l6ZS5sZWZ0LCBjdXJyZW50U2l6ZS53aWR0aCwgd2lkdGgsIGNvbnRhaW5lcldpZHRoKSxcbiAgICB0b3A6IGNvbnN0cmFpblRvcCh0b3ApLFxuICAgIGxlZnQ6IGNvbnN0cmFpbkxlZnQobGVmdClcbiAgfTtcbn07XG5jb25zdCByZXNpemVTb3V0aCA9IChjdXJyZW50U2l6ZSwgX3JlZjQsIGNvbnRhaW5lcldpZHRoKSA9PiB7XG4gIGxldCB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgaGVpZ2h0LFxuICAgIHdpZHRoXG4gIH0gPSBfcmVmNDtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBsZWZ0LFxuICAgIGhlaWdodDogY29uc3RyYWluSGVpZ2h0KHRvcCwgY3VycmVudFNpemUuaGVpZ2h0LCBoZWlnaHQpLFxuICAgIHRvcDogY29uc3RyYWluVG9wKHRvcClcbiAgfTtcbn07XG5jb25zdCByZXNpemVOb3J0aEVhc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiByZXNpemVOb3J0aChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIHJlc2l6ZUVhc3QoLi4uYXJndW1lbnRzKSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbn07XG5jb25zdCByZXNpemVOb3J0aFdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiByZXNpemVOb3J0aChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIHJlc2l6ZVdlc3QoLi4uYXJndW1lbnRzKSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbn07XG5jb25zdCByZXNpemVTb3V0aEVhc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiByZXNpemVTb3V0aChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIHJlc2l6ZUVhc3QoLi4uYXJndW1lbnRzKSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbn07XG5jb25zdCByZXNpemVTb3V0aFdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiByZXNpemVTb3V0aChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIHJlc2l6ZVdlc3QoLi4uYXJndW1lbnRzKSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbn07XG5jb25zdCBvcmRpbmFsUmVzaXplSGFuZGxlck1hcCA9IHtcbiAgbjogcmVzaXplTm9ydGgsXG4gIG5lOiByZXNpemVOb3J0aEVhc3QsXG4gIGU6IHJlc2l6ZUVhc3QsXG4gIHNlOiByZXNpemVTb3V0aEVhc3QsXG4gIHM6IHJlc2l6ZVNvdXRoLFxuICBzdzogcmVzaXplU291dGhXZXN0LFxuICB3OiByZXNpemVXZXN0LFxuICBudzogcmVzaXplTm9ydGhXZXN0XG59O1xuXG4vKipcbiAqIEhlbHBlciBmb3IgY2xhbXBpbmcgd2lkdGggYW5kIHBvc2l0aW9uIHdoZW4gcmVzaXppbmcgYW4gaXRlbS5cbiAqL1xuZnVuY3Rpb24gcmVzaXplSXRlbUluRGlyZWN0aW9uKGRpcmVjdGlvbiAvKjogUmVzaXplSGFuZGxlQXhpcyovLCBjdXJyZW50U2l6ZSAvKjogUG9zaXRpb24qLywgbmV3U2l6ZSAvKjogUG9zaXRpb24qLywgY29udGFpbmVyV2lkdGggLyo6IG51bWJlciovKSAvKjogUG9zaXRpb24qL3tcbiAgY29uc3Qgb3JkaW5hbEhhbmRsZXIgPSBvcmRpbmFsUmVzaXplSGFuZGxlck1hcFtkaXJlY3Rpb25dO1xuICAvLyBTaG91bGRuJ3QgYmUgcG9zc2libGUgZ2l2ZW4gdHlwZXM7IHRoYXQgc2FpZCwgZG9uJ3QgZmFpbCBoYXJkXG4gIGlmICghb3JkaW5hbEhhbmRsZXIpIHJldHVybiBuZXdTaXplO1xuICByZXR1cm4gb3JkaW5hbEhhbmRsZXIoY3VycmVudFNpemUsIHtcbiAgICAuLi5jdXJyZW50U2l6ZSxcbiAgICAuLi5uZXdTaXplXG4gIH0sIGNvbnRhaW5lcldpZHRoKTtcbn1cbmZ1bmN0aW9uIHNldFRyYW5zZm9ybShfcmVmNSAvKjo6ICovKSAvKjogT2JqZWN0Ki97XG4gIGxldCB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gLyo6IFBvc2l0aW9uKi8gPSBfcmVmNSAvKjogUG9zaXRpb24qLztcbiAgLy8gUmVwbGFjZSB1bml0bGVzcyBpdGVtcyB3aXRoIHB4XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IGB0cmFuc2xhdGUoJHtsZWZ0fXB4LCR7dG9wfXB4KWA7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUsXG4gICAgV2Via2l0VHJhbnNmb3JtOiB0cmFuc2xhdGUsXG4gICAgTW96VHJhbnNmb3JtOiB0cmFuc2xhdGUsXG4gICAgbXNUcmFuc2Zvcm06IHRyYW5zbGF0ZSxcbiAgICBPVHJhbnNmb3JtOiB0cmFuc2xhdGUsXG4gICAgd2lkdGg6IGAke3dpZHRofXB4YCxcbiAgICBoZWlnaHQ6IGAke2hlaWdodH1weGAsXG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICB9O1xufVxuZnVuY3Rpb24gc2V0VG9wTGVmdChfcmVmNiAvKjo6ICovKSAvKjogT2JqZWN0Ki97XG4gIGxldCB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gLyo6IFBvc2l0aW9uKi8gPSBfcmVmNiAvKjogUG9zaXRpb24qLztcbiAgcmV0dXJuIHtcbiAgICB0b3A6IGAke3RvcH1weGAsXG4gICAgbGVmdDogYCR7bGVmdH1weGAsXG4gICAgd2lkdGg6IGAke3dpZHRofXB4YCxcbiAgICBoZWlnaHQ6IGAke2hlaWdodH1weGAsXG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICB9O1xufVxuXG4vKipcbiAqIEdldCBsYXlvdXQgaXRlbXMgc29ydGVkIGZyb20gdG9wIGxlZnQgdG8gcmlnaHQgYW5kIGRvd24uXG4gKlxuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGxheW91dCBvYmplY3RzLlxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICBMYXlvdXQsIHNvcnRlZCBzdGF0aWMgaXRlbXMgZmlyc3QuXG4gKi9cbmZ1bmN0aW9uIHNvcnRMYXlvdXRJdGVtcyhsYXlvdXQgLyo6IExheW91dCovLCBjb21wYWN0VHlwZSAvKjogQ29tcGFjdFR5cGUqLykgLyo6IExheW91dCove1xuICBpZiAoY29tcGFjdFR5cGUgPT09IFwiaG9yaXpvbnRhbFwiKSByZXR1cm4gc29ydExheW91dEl0ZW1zQnlDb2xSb3cobGF5b3V0KTtcbiAgaWYgKGNvbXBhY3RUeXBlID09PSBcInZlcnRpY2FsXCIpIHJldHVybiBzb3J0TGF5b3V0SXRlbXNCeVJvd0NvbChsYXlvdXQpO2Vsc2UgcmV0dXJuIGxheW91dDtcbn1cblxuLyoqXG4gKiBTb3J0IGxheW91dCBpdGVtcyBieSByb3cgYXNjZW5kaW5nIGFuZCBjb2x1bW4gYXNjZW5kaW5nLlxuICpcbiAqIERvZXMgbm90IG1vZGlmeSBMYXlvdXQuXG4gKi9cbmZ1bmN0aW9uIHNvcnRMYXlvdXRJdGVtc0J5Um93Q29sKGxheW91dCAvKjogTGF5b3V0Ki8pIC8qOiBMYXlvdXQqL3tcbiAgLy8gU2xpY2UgdG8gY2xvbmUgYXJyYXkgYXMgc29ydCBtb2RpZmllc1xuICByZXR1cm4gbGF5b3V0LnNsaWNlKDApLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS55ID4gYi55IHx8IGEueSA9PT0gYi55ICYmIGEueCA+IGIueCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChhLnkgPT09IGIueSAmJiBhLnggPT09IGIueCkge1xuICAgICAgLy8gV2l0aG91dCB0aGlzLCB3ZSBjYW4gZ2V0IGRpZmZlcmVudCBzb3J0IHJlc3VsdHMgaW4gSUUgdnMuIENocm9tZS9GRlxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfSk7XG59XG5cbi8qKlxuICogU29ydCBsYXlvdXQgaXRlbXMgYnkgY29sdW1uIGFzY2VuZGluZyB0aGVuIHJvdyBhc2NlbmRpbmcuXG4gKlxuICogRG9lcyBub3QgbW9kaWZ5IExheW91dC5cbiAqL1xuZnVuY3Rpb24gc29ydExheW91dEl0ZW1zQnlDb2xSb3cobGF5b3V0IC8qOiBMYXlvdXQqLykgLyo6IExheW91dCove1xuICByZXR1cm4gbGF5b3V0LnNsaWNlKDApLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS54ID4gYi54IHx8IGEueCA9PT0gYi54ICYmIGEueSA+IGIueSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBsYXlvdXQgdXNpbmcgdGhlIGluaXRpYWxMYXlvdXQgYW5kIGNoaWxkcmVuIGFzIGEgdGVtcGxhdGUuXG4gKiBNaXNzaW5nIGVudHJpZXMgd2lsbCBiZSBhZGRlZCwgZXh0cmFuZW91cyBvbmVzIHdpbGwgYmUgdHJ1bmNhdGVkLlxuICpcbiAqIERvZXMgbm90IG1vZGlmeSBpbml0aWFsTGF5b3V0LlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgaW5pdGlhbExheW91dCBMYXlvdXQgcGFzc2VkIGluIHRocm91Z2ggcHJvcHMuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGJyZWFrcG9pbnQgICAgQ3VycmVudCByZXNwb25zaXZlIGJyZWFrcG9pbnQuXG4gKiBAcGFyYW0gIHs/U3RyaW5nfSBjb21wYWN0ICAgICAgQ29tcGFjdGlvbiBvcHRpb24uXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgICAgV29ya2luZyBsYXlvdXQuXG4gKi9cbmZ1bmN0aW9uIHN5bmNocm9uaXplTGF5b3V0V2l0aENoaWxkcmVuKGluaXRpYWxMYXlvdXQgLyo6IExheW91dCovLCBjaGlsZHJlbiAvKjogUmVhY3RDaGlsZHJlbiovLCBjb2xzIC8qOiBudW1iZXIqLywgY29tcGFjdFR5cGUgLyo6IENvbXBhY3RUeXBlKi8sIGFsbG93T3ZlcmxhcCAvKjogP2Jvb2xlYW4qLykgLyo6IExheW91dCove1xuICBpbml0aWFsTGF5b3V0ID0gaW5pdGlhbExheW91dCB8fCBbXTtcblxuICAvLyBHZW5lcmF0ZSBvbmUgbGF5b3V0IGl0ZW0gcGVyIGNoaWxkLlxuICBjb25zdCBsYXlvdXQgLyo6IExheW91dEl0ZW1bXSovID0gW107XG4gIF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjaGlsZCAvKjogUmVhY3RFbGVtZW50PGFueT4qLykgPT4ge1xuICAgIC8vIENoaWxkIG1heSBub3QgZXhpc3RcbiAgICBpZiAoY2hpbGQ/LmtleSA9PSBudWxsKSByZXR1cm47XG4gICAgY29uc3QgZXhpc3RzID0gZ2V0TGF5b3V0SXRlbShpbml0aWFsTGF5b3V0LCBTdHJpbmcoY2hpbGQua2V5KSk7XG4gICAgY29uc3QgZyA9IGNoaWxkLnByb3BzW1wiZGF0YS1ncmlkXCJdO1xuICAgIC8vIERvbid0IG92ZXJ3cml0ZSB0aGUgbGF5b3V0IGl0ZW0gaWYgaXQncyBhbHJlYWR5IGluIHRoZSBpbml0aWFsIGxheW91dC5cbiAgICAvLyBJZiBpdCBoYXMgYSBgZGF0YS1ncmlkYCBwcm9wZXJ0eSwgcHJlZmVyIHRoYXQgb3ZlciB3aGF0J3MgaW4gdGhlIGxheW91dC5cbiAgICBpZiAoZXhpc3RzICYmIGcgPT0gbnVsbCkge1xuICAgICAgbGF5b3V0LnB1c2goY2xvbmVMYXlvdXRJdGVtKGV4aXN0cykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIZXksIHRoaXMgaXRlbSBoYXMgYSBkYXRhLWdyaWQgcHJvcGVydHksIHVzZSBpdC5cbiAgICAgIGlmIChnKSB7XG4gICAgICAgIGlmICghaXNQcm9kdWN0aW9uKSB7XG4gICAgICAgICAgdmFsaWRhdGVMYXlvdXQoW2ddLCBcIlJlYWN0R3JpZExheW91dC5jaGlsZHJlblwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGSVhNRSBjbG9uZSBub3QgcmVhbGx5IG5lY2Vzc2FyeSBoZXJlXG4gICAgICAgIGxheW91dC5wdXNoKGNsb25lTGF5b3V0SXRlbSh7XG4gICAgICAgICAgLi4uZyxcbiAgICAgICAgICBpOiBjaGlsZC5rZXlcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90aGluZyBwcm92aWRlZDogZW5zdXJlIHRoaXMgaXMgYWRkZWQgdG8gdGhlIGJvdHRvbVxuICAgICAgICAvLyBGSVhNRSBjbG9uZSBub3QgcmVhbGx5IG5lY2Vzc2FyeSBoZXJlXG4gICAgICAgIGxheW91dC5wdXNoKGNsb25lTGF5b3V0SXRlbSh7XG4gICAgICAgICAgdzogMSxcbiAgICAgICAgICBoOiAxLFxuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogYm90dG9tKGxheW91dCksXG4gICAgICAgICAgaTogU3RyaW5nKGNoaWxkLmtleSlcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gQ29ycmVjdCB0aGUgbGF5b3V0LlxuICBjb25zdCBjb3JyZWN0ZWRMYXlvdXQgPSBjb3JyZWN0Qm91bmRzKGxheW91dCwge1xuICAgIGNvbHM6IGNvbHNcbiAgfSk7XG4gIHJldHVybiBhbGxvd092ZXJsYXAgPyBjb3JyZWN0ZWRMYXlvdXQgOiBjb21wYWN0KGNvcnJlY3RlZExheW91dCwgY29tcGFjdFR5cGUsIGNvbHMpO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGEgbGF5b3V0LiBUaHJvd3MgZXJyb3JzLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgbGF5b3V0ICAgICAgICBBcnJheSBvZiBsYXlvdXQgaXRlbXMuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFtjb250ZXh0TmFtZV0gQ29udGV4dCBuYW1lIGZvciBlcnJvcnMuXG4gKiBAdGhyb3cgIHtFcnJvcn0gICAgICAgICAgICAgICAgVmFsaWRhdGlvbiBlcnJvci5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVMYXlvdXQobGF5b3V0IC8qOiBMYXlvdXQqLykgLyo6IHZvaWQqL3tcbiAgbGV0IGNvbnRleHROYW1lIC8qOiBzdHJpbmcqLyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJMYXlvdXRcIjtcbiAgY29uc3Qgc3ViUHJvcHMgPSBbXCJ4XCIsIFwieVwiLCBcIndcIiwgXCJoXCJdO1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGF5b3V0KSkgdGhyb3cgbmV3IEVycm9yKGNvbnRleHROYW1lICsgXCIgbXVzdCBiZSBhbiBhcnJheSFcIik7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsYXlvdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBpdGVtID0gbGF5b3V0W2ldO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3ViUHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IHN1YlByb3BzW2pdO1xuICAgICAgY29uc3QgdmFsdWUgPSBpdGVtW2tleV07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8IE51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWFjdEdyaWRMYXlvdXQ6ICR7Y29udGV4dE5hbWV9WyR7aX1dLiR7a2V5fSBtdXN0IGJlIGEgbnVtYmVyISBSZWNlaXZlZDogJHt2YWx1ZX0gKCR7dHlwZW9mIHZhbHVlfSlgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpdGVtLmkgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGl0ZW0uaSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWFjdEdyaWRMYXlvdXQ6ICR7Y29udGV4dE5hbWV9WyR7aX1dLmkgbXVzdCBiZSBhIHN0cmluZyEgUmVjZWl2ZWQ6ICR7aXRlbS5pfSAoJHt0eXBlb2YgaXRlbS5pfSlgKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHZlcnRpY2FsQ29tcGFjdDogZmFsc2VcbmZ1bmN0aW9uIGNvbXBhY3RUeXBlKHByb3BzIC8qOiA/eyB2ZXJ0aWNhbENvbXBhY3Q6IGJvb2xlYW4sIGNvbXBhY3RUeXBlOiBDb21wYWN0VHlwZSB9Ki8pIC8qOiBDb21wYWN0VHlwZSove1xuICBjb25zdCB7XG4gICAgdmVydGljYWxDb21wYWN0LFxuICAgIGNvbXBhY3RUeXBlXG4gIH0gPSBwcm9wcyB8fCB7fTtcbiAgcmV0dXJuIHZlcnRpY2FsQ29tcGFjdCA9PT0gZmFsc2UgPyBudWxsIDogY29tcGFjdFR5cGU7XG59XG5mdW5jdGlvbiBsb2coKSB7XG4gIGlmICghREVCVUcpIHJldHVybjtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS5sb2coLi4uYXJndW1lbnRzKTtcbn1cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcbmV4cG9ydHMubm9vcCA9IG5vb3A7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/react-grid-layout/build/utils.js\n");

/***/ }),

/***/ "../../node_modules/react-grid-layout/index.js":
/*!*****************************************************!*\
  !*** ../../node_modules/react-grid-layout/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./build/ReactGridLayout */ \"../../node_modules/react-grid-layout/build/ReactGridLayout.js\")[\"default\"];\nmodule.exports.utils = __webpack_require__(/*! ./build/utils */ \"../../node_modules/react-grid-layout/build/utils.js\");\nmodule.exports.calculateUtils = __webpack_require__(/*! ./build/calculateUtils */ \"../../node_modules/react-grid-layout/build/calculateUtils.js\");\nmodule.exports.Responsive = __webpack_require__(/*! ./build/ResponsiveReactGridLayout */ \"../../node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js\")[\"default\"];\nmodule.exports.Responsive.utils = __webpack_require__(/*! ./build/responsiveUtils */ \"../../node_modules/react-grid-layout/build/responsiveUtils.js\");\nmodule.exports.WidthProvider = __webpack_require__(/*! ./build/components/WidthProvider */ \"../../node_modules/react-grid-layout/build/components/WidthProvider.js\")[\"default\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2luZGV4LmpzPzkwZWQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9idWlsZC9SZWFjdEdyaWRMYXlvdXRcIikuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLnV0aWxzID0gcmVxdWlyZShcIi4vYnVpbGQvdXRpbHNcIik7XG5tb2R1bGUuZXhwb3J0cy5jYWxjdWxhdGVVdGlscyA9IHJlcXVpcmUoXCIuL2J1aWxkL2NhbGN1bGF0ZVV0aWxzXCIpO1xubW9kdWxlLmV4cG9ydHMuUmVzcG9uc2l2ZSA9XG4gIHJlcXVpcmUoXCIuL2J1aWxkL1Jlc3BvbnNpdmVSZWFjdEdyaWRMYXlvdXRcIikuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLlJlc3BvbnNpdmUudXRpbHMgPSByZXF1aXJlKFwiLi9idWlsZC9yZXNwb25zaXZlVXRpbHNcIik7XG5tb2R1bGUuZXhwb3J0cy5XaWR0aFByb3ZpZGVyID1cbiAgcmVxdWlyZShcIi4vYnVpbGQvY29tcG9uZW50cy9XaWR0aFByb3ZpZGVyXCIpLmRlZmF1bHQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/react-grid-layout/index.js\n");

/***/ }),

/***/ "../../node_modules/react-is/cjs/react-is.development.js":
/*!***************************************************************!*\
  !*** ../../node_modules/react-is/cjs/react-is.development.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n// (unstable) APIs that have been removed. Can we remove the symbols?\n\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\nvar REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\nvar REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\nvar REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\nvar REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_ASYNC_MODE_TYPE:\n          case REACT_CONCURRENT_MODE_TYPE:\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n} // AsyncMode is deprecated along with isAsyncMode\n\nvar AsyncMode = REACT_ASYNC_MODE_TYPE;\nvar ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n    }\n  }\n\n  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n}\nfunction isConcurrentMode(object) {\n  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\n\nexports.AsyncMode = AsyncMode;\nexports.ConcurrentMode = ConcurrentMode;\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcz80NzI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpIDogMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmJsb2NrJykgOiAweGVhZDk7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKSA6IDB4ZWFkNztcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IC8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcblxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcblxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/react-is/cjs/react-is.development.js\n");

/***/ }),

/***/ "../../node_modules/react-is/index.js":
/*!********************************************!*\
  !*** ../../node_modules/react-is/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"../../node_modules/react-is/cjs/react-is.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcz85MmY1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/react-is/index.js\n");

/***/ }),

/***/ "../../node_modules/react-resizable/build/Resizable.js":
/*!*************************************************************!*\
  !*** ../../node_modules/react-resizable/build/Resizable.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\"));\nvar _reactDraggable = __webpack_require__(/*! react-draggable */ \"../../node_modules/react-draggable/build/cjs/cjs.js\");\nvar _utils = __webpack_require__(/*! ./utils */ \"../../node_modules/react-resizable/build/utils.js\");\nvar _propTypes = __webpack_require__(/*! ./propTypes */ \"../../node_modules/react-resizable/build/propTypes.js\");\nvar _excluded = [\"children\", \"className\", \"draggableOpts\", \"width\", \"height\", \"handle\", \"handleSize\", \"lockAspectRatio\", \"axis\", \"minConstraints\", \"maxConstraints\", \"onResize\", \"onResizeStop\", \"onResizeStart\", \"resizeHandles\", \"transformScale\"];\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n// The base <Resizable> component.\n// This component does not have state and relies on the parent to set its props based on callback data.\nvar Resizable = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Resizable, _React$Component);\n  function Resizable() {\n    var _this;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.handleRefs = {};\n    _this.lastHandleRect = null;\n    _this.slack = null;\n    return _this;\n  }\n  var _proto = Resizable.prototype;\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.resetData();\n  };\n  _proto.resetData = function resetData() {\n    this.lastHandleRect = this.slack = null;\n  }\n\n  // Clamp width and height within provided constraints\n  ;\n  _proto.runConstraints = function runConstraints(width, height) {\n    var _this$props = this.props,\n      minConstraints = _this$props.minConstraints,\n      maxConstraints = _this$props.maxConstraints,\n      lockAspectRatio = _this$props.lockAspectRatio;\n    // short circuit\n    if (!minConstraints && !maxConstraints && !lockAspectRatio) return [width, height];\n\n    // If constraining to min and max, we need to also fit width and height to aspect ratio.\n    if (lockAspectRatio) {\n      var ratio = this.props.width / this.props.height;\n      var deltaW = width - this.props.width;\n      var deltaH = height - this.props.height;\n\n      // Find which coordinate was greater and should push the other toward it.\n      // E.g.:\n      // ratio = 1, deltaW = 10, deltaH = 5, deltaH should become 10.\n      // ratio = 2, deltaW = 10, deltaH = 6, deltaW should become 12.\n      if (Math.abs(deltaW) > Math.abs(deltaH * ratio)) {\n        height = width / ratio;\n      } else {\n        width = height * ratio;\n      }\n    }\n    var oldW = width,\n      oldH = height;\n\n    // Add slack to the values used to calculate bound position. This will ensure that if\n    // we start removing slack, the element won't react to it right away until it's been\n    // completely removed.\n    var _ref = this.slack || [0, 0],\n      slackW = _ref[0],\n      slackH = _ref[1];\n    width += slackW;\n    height += slackH;\n    if (minConstraints) {\n      width = Math.max(minConstraints[0], width);\n      height = Math.max(minConstraints[1], height);\n    }\n    if (maxConstraints) {\n      width = Math.min(maxConstraints[0], width);\n      height = Math.min(maxConstraints[1], height);\n    }\n\n    // If the width or height changed, we must have introduced some slack. Record it for the next iteration.\n    this.slack = [slackW + (oldW - width), slackH + (oldH - height)];\n    return [width, height];\n  }\n\n  /**\n   * Wrapper around drag events to provide more useful data.\n   *\n   * @param  {String} handlerName Handler name to wrap.\n   * @return {Function}           Handler function.\n   */;\n  _proto.resizeHandler = function resizeHandler(handlerName, axis) {\n    var _this2 = this;\n    return function (e, _ref2) {\n      var node = _ref2.node,\n        deltaX = _ref2.deltaX,\n        deltaY = _ref2.deltaY;\n      // Reset data in case it was left over somehow (should not be possible)\n      if (handlerName === 'onResizeStart') _this2.resetData();\n\n      // Axis restrictions\n      var canDragX = (_this2.props.axis === 'both' || _this2.props.axis === 'x') && axis !== 'n' && axis !== 's';\n      var canDragY = (_this2.props.axis === 'both' || _this2.props.axis === 'y') && axis !== 'e' && axis !== 'w';\n      // No dragging possible.\n      if (!canDragX && !canDragY) return;\n\n      // Decompose axis for later use\n      var axisV = axis[0];\n      var axisH = axis[axis.length - 1]; // intentionally not axis[1], so that this catches axis === 'w' for example\n\n      // Track the element being dragged to account for changes in position.\n      // If a handle's position is changed between callbacks, we need to factor this in to the next callback.\n      // Failure to do so will cause the element to \"skip\" when resized upwards or leftwards.\n      var handleRect = node.getBoundingClientRect();\n      if (_this2.lastHandleRect != null) {\n        // If the handle has repositioned on either axis since last render,\n        // we need to increase our callback values by this much.\n        // Only checking 'n', 'w' since resizing by 's', 'w' won't affect the overall position on page,\n        if (axisH === 'w') {\n          var deltaLeftSinceLast = handleRect.left - _this2.lastHandleRect.left;\n          deltaX += deltaLeftSinceLast;\n        }\n        if (axisV === 'n') {\n          var deltaTopSinceLast = handleRect.top - _this2.lastHandleRect.top;\n          deltaY += deltaTopSinceLast;\n        }\n      }\n      // Storage of last rect so we know how much it has really moved.\n      _this2.lastHandleRect = handleRect;\n\n      // Reverse delta if using top or left drag handles.\n      if (axisH === 'w') deltaX = -deltaX;\n      if (axisV === 'n') deltaY = -deltaY;\n\n      // Update w/h by the deltas. Also factor in transformScale.\n      var width = _this2.props.width + (canDragX ? deltaX / _this2.props.transformScale : 0);\n      var height = _this2.props.height + (canDragY ? deltaY / _this2.props.transformScale : 0);\n\n      // Run user-provided constraints.\n      var _this2$runConstraints = _this2.runConstraints(width, height);\n      width = _this2$runConstraints[0];\n      height = _this2$runConstraints[1];\n      var dimensionsChanged = width !== _this2.props.width || height !== _this2.props.height;\n\n      // Call user-supplied callback if present.\n      var cb = typeof _this2.props[handlerName] === 'function' ? _this2.props[handlerName] : null;\n      // Don't call 'onResize' if dimensions haven't changed.\n      var shouldSkipCb = handlerName === 'onResize' && !dimensionsChanged;\n      if (cb && !shouldSkipCb) {\n        e.persist == null ? void 0 : e.persist();\n        cb(e, {\n          node: node,\n          size: {\n            width: width,\n            height: height\n          },\n          handle: axis\n        });\n      }\n\n      // Reset internal data\n      if (handlerName === 'onResizeStop') _this2.resetData();\n    };\n  }\n\n  // Render a resize handle given an axis & DOM ref. Ref *must* be attached for\n  // the underlying draggable library to work properly.\n  ;\n  _proto.renderResizeHandle = function renderResizeHandle(handleAxis, ref) {\n    var handle = this.props.handle;\n    // No handle provided, make the default\n    if (!handle) {\n      return /*#__PURE__*/React.createElement(\"span\", {\n        className: \"react-resizable-handle react-resizable-handle-\" + handleAxis,\n        ref: ref\n      });\n    }\n    // Handle is a function, such as:\n    // `handle={(handleAxis) => <span className={...} />}`\n    if (typeof handle === 'function') {\n      return handle(handleAxis, ref);\n    }\n    // Handle is a React component (composite or DOM).\n    var isDOMElement = typeof handle.type === 'string';\n    var props = _objectSpread({\n      ref: ref\n    }, isDOMElement ? {} : {\n      handleAxis: handleAxis\n    });\n    return /*#__PURE__*/React.cloneElement(handle, props);\n  };\n  _proto.render = function render() {\n    var _this3 = this;\n    // Pass along only props not meant for the `<Resizable>`.`\n    // eslint-disable-next-line no-unused-vars\n    var _this$props2 = this.props,\n      children = _this$props2.children,\n      className = _this$props2.className,\n      draggableOpts = _this$props2.draggableOpts,\n      width = _this$props2.width,\n      height = _this$props2.height,\n      handle = _this$props2.handle,\n      handleSize = _this$props2.handleSize,\n      lockAspectRatio = _this$props2.lockAspectRatio,\n      axis = _this$props2.axis,\n      minConstraints = _this$props2.minConstraints,\n      maxConstraints = _this$props2.maxConstraints,\n      onResize = _this$props2.onResize,\n      onResizeStop = _this$props2.onResizeStop,\n      onResizeStart = _this$props2.onResizeStart,\n      resizeHandles = _this$props2.resizeHandles,\n      transformScale = _this$props2.transformScale,\n      p = _objectWithoutPropertiesLoose(_this$props2, _excluded);\n\n    // What we're doing here is getting the child of this element, and cloning it with this element's props.\n    // We are then defining its children as:\n    // 1. Its original children (resizable's child's children), and\n    // 2. One or more draggable handles.\n    return (0, _utils.cloneElement)(children, _objectSpread(_objectSpread({}, p), {}, {\n      className: (className ? className + \" \" : '') + \"react-resizable\",\n      children: [].concat(children.props.children, resizeHandles.map(function (handleAxis) {\n        var _this3$handleRefs$han;\n        // Create a ref to the handle so that `<DraggableCore>` doesn't have to use ReactDOM.findDOMNode().\n        var ref = (_this3$handleRefs$han = _this3.handleRefs[handleAxis]) != null ? _this3$handleRefs$han : _this3.handleRefs[handleAxis] = /*#__PURE__*/React.createRef();\n        return /*#__PURE__*/React.createElement(_reactDraggable.DraggableCore, _extends({}, draggableOpts, {\n          nodeRef: ref,\n          key: \"resizableHandle-\" + handleAxis,\n          onStop: _this3.resizeHandler('onResizeStop', handleAxis),\n          onStart: _this3.resizeHandler('onResizeStart', handleAxis),\n          onDrag: _this3.resizeHandler('onResize', handleAxis)\n        }), _this3.renderResizeHandle(handleAxis, ref));\n      }))\n    }));\n  };\n  return Resizable;\n}(React.Component);\nexports[\"default\"] = Resizable;\nResizable.propTypes = _propTypes.resizableProps;\nResizable.defaultProps = {\n  axis: 'both',\n  handleSize: [20, 20],\n  lockAspectRatio: false,\n  minConstraints: [20, 20],\n  maxConstraints: [Infinity, Infinity],\n  resizeHandles: ['se'],\n  transformScale: 1\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc2l6YWJsZS9idWlsZC9SZXNpemFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNpemFibGUvYnVpbGQvUmVzaXphYmxlLmpzPzBjODYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9yZWFjdERyYWdnYWJsZSA9IHJlcXVpcmUoXCJyZWFjdC1kcmFnZ2FibGVcIik7XG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgX3Byb3BUeXBlcyA9IHJlcXVpcmUoXCIuL3Byb3BUeXBlc1wiKTtcbnZhciBfZXhjbHVkZWQgPSBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiLCBcImRyYWdnYWJsZU9wdHNcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcImhhbmRsZVwiLCBcImhhbmRsZVNpemVcIiwgXCJsb2NrQXNwZWN0UmF0aW9cIiwgXCJheGlzXCIsIFwibWluQ29uc3RyYWludHNcIiwgXCJtYXhDb25zdHJhaW50c1wiLCBcIm9uUmVzaXplXCIsIFwib25SZXNpemVTdG9wXCIsIFwib25SZXNpemVTdGFydFwiLCBcInJlc2l6ZUhhbmRsZXNcIiwgXCJ0cmFuc2Zvcm1TY2FsZVwiXTtcbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbi8vIFRoZSBiYXNlIDxSZXNpemFibGU+IGNvbXBvbmVudC5cbi8vIFRoaXMgY29tcG9uZW50IGRvZXMgbm90IGhhdmUgc3RhdGUgYW5kIHJlbGllcyBvbiB0aGUgcGFyZW50IHRvIHNldCBpdHMgcHJvcHMgYmFzZWQgb24gY2FsbGJhY2sgZGF0YS5cbnZhciBSZXNpemFibGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoUmVzaXphYmxlLCBfUmVhY3QkQ29tcG9uZW50KTtcbiAgZnVuY3Rpb24gUmVzaXphYmxlKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMuaGFuZGxlUmVmcyA9IHt9O1xuICAgIF90aGlzLmxhc3RIYW5kbGVSZWN0ID0gbnVsbDtcbiAgICBfdGhpcy5zbGFjayA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfcHJvdG8gPSBSZXNpemFibGUucHJvdG90eXBlO1xuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnJlc2V0RGF0YSgpO1xuICB9O1xuICBfcHJvdG8ucmVzZXREYXRhID0gZnVuY3Rpb24gcmVzZXREYXRhKCkge1xuICAgIHRoaXMubGFzdEhhbmRsZVJlY3QgPSB0aGlzLnNsYWNrID0gbnVsbDtcbiAgfVxuXG4gIC8vIENsYW1wIHdpZHRoIGFuZCBoZWlnaHQgd2l0aGluIHByb3ZpZGVkIGNvbnN0cmFpbnRzXG4gIDtcbiAgX3Byb3RvLnJ1bkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gcnVuQ29uc3RyYWludHMod2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICBtaW5Db25zdHJhaW50cyA9IF90aGlzJHByb3BzLm1pbkNvbnN0cmFpbnRzLFxuICAgICAgbWF4Q29uc3RyYWludHMgPSBfdGhpcyRwcm9wcy5tYXhDb25zdHJhaW50cyxcbiAgICAgIGxvY2tBc3BlY3RSYXRpbyA9IF90aGlzJHByb3BzLmxvY2tBc3BlY3RSYXRpbztcbiAgICAvLyBzaG9ydCBjaXJjdWl0XG4gICAgaWYgKCFtaW5Db25zdHJhaW50cyAmJiAhbWF4Q29uc3RyYWludHMgJiYgIWxvY2tBc3BlY3RSYXRpbykgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0XTtcblxuICAgIC8vIElmIGNvbnN0cmFpbmluZyB0byBtaW4gYW5kIG1heCwgd2UgbmVlZCB0byBhbHNvIGZpdCB3aWR0aCBhbmQgaGVpZ2h0IHRvIGFzcGVjdCByYXRpby5cbiAgICBpZiAobG9ja0FzcGVjdFJhdGlvKSB7XG4gICAgICB2YXIgcmF0aW8gPSB0aGlzLnByb3BzLndpZHRoIC8gdGhpcy5wcm9wcy5oZWlnaHQ7XG4gICAgICB2YXIgZGVsdGFXID0gd2lkdGggLSB0aGlzLnByb3BzLndpZHRoO1xuICAgICAgdmFyIGRlbHRhSCA9IGhlaWdodCAtIHRoaXMucHJvcHMuaGVpZ2h0O1xuXG4gICAgICAvLyBGaW5kIHdoaWNoIGNvb3JkaW5hdGUgd2FzIGdyZWF0ZXIgYW5kIHNob3VsZCBwdXNoIHRoZSBvdGhlciB0b3dhcmQgaXQuXG4gICAgICAvLyBFLmcuOlxuICAgICAgLy8gcmF0aW8gPSAxLCBkZWx0YVcgPSAxMCwgZGVsdGFIID0gNSwgZGVsdGFIIHNob3VsZCBiZWNvbWUgMTAuXG4gICAgICAvLyByYXRpbyA9IDIsIGRlbHRhVyA9IDEwLCBkZWx0YUggPSA2LCBkZWx0YVcgc2hvdWxkIGJlY29tZSAxMi5cbiAgICAgIGlmIChNYXRoLmFicyhkZWx0YVcpID4gTWF0aC5hYnMoZGVsdGFIICogcmF0aW8pKSB7XG4gICAgICAgIGhlaWdodCA9IHdpZHRoIC8gcmF0aW87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aCA9IGhlaWdodCAqIHJhdGlvO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgb2xkVyA9IHdpZHRoLFxuICAgICAgb2xkSCA9IGhlaWdodDtcblxuICAgIC8vIEFkZCBzbGFjayB0byB0aGUgdmFsdWVzIHVzZWQgdG8gY2FsY3VsYXRlIGJvdW5kIHBvc2l0aW9uLiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgaWZcbiAgICAvLyB3ZSBzdGFydCByZW1vdmluZyBzbGFjaywgdGhlIGVsZW1lbnQgd29uJ3QgcmVhY3QgdG8gaXQgcmlnaHQgYXdheSB1bnRpbCBpdCdzIGJlZW5cbiAgICAvLyBjb21wbGV0ZWx5IHJlbW92ZWQuXG4gICAgdmFyIF9yZWYgPSB0aGlzLnNsYWNrIHx8IFswLCAwXSxcbiAgICAgIHNsYWNrVyA9IF9yZWZbMF0sXG4gICAgICBzbGFja0ggPSBfcmVmWzFdO1xuICAgIHdpZHRoICs9IHNsYWNrVztcbiAgICBoZWlnaHQgKz0gc2xhY2tIO1xuICAgIGlmIChtaW5Db25zdHJhaW50cykge1xuICAgICAgd2lkdGggPSBNYXRoLm1heChtaW5Db25zdHJhaW50c1swXSwgd2lkdGgpO1xuICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgobWluQ29uc3RyYWludHNbMV0sIGhlaWdodCk7XG4gICAgfVxuICAgIGlmIChtYXhDb25zdHJhaW50cykge1xuICAgICAgd2lkdGggPSBNYXRoLm1pbihtYXhDb25zdHJhaW50c1swXSwgd2lkdGgpO1xuICAgICAgaGVpZ2h0ID0gTWF0aC5taW4obWF4Q29uc3RyYWludHNbMV0sIGhlaWdodCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHdpZHRoIG9yIGhlaWdodCBjaGFuZ2VkLCB3ZSBtdXN0IGhhdmUgaW50cm9kdWNlZCBzb21lIHNsYWNrLiBSZWNvcmQgaXQgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbiAgICB0aGlzLnNsYWNrID0gW3NsYWNrVyArIChvbGRXIC0gd2lkdGgpLCBzbGFja0ggKyAob2xkSCAtIGhlaWdodCldO1xuICAgIHJldHVybiBbd2lkdGgsIGhlaWdodF07XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBhcm91bmQgZHJhZyBldmVudHMgdG8gcHJvdmlkZSBtb3JlIHVzZWZ1bCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGhhbmRsZXJOYW1lIEhhbmRsZXIgbmFtZSB0byB3cmFwLlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gICAgICAgICAgIEhhbmRsZXIgZnVuY3Rpb24uXG4gICAqLztcbiAgX3Byb3RvLnJlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiByZXNpemVIYW5kbGVyKGhhbmRsZXJOYW1lLCBheGlzKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlLCBfcmVmMikge1xuICAgICAgdmFyIG5vZGUgPSBfcmVmMi5ub2RlLFxuICAgICAgICBkZWx0YVggPSBfcmVmMi5kZWx0YVgsXG4gICAgICAgIGRlbHRhWSA9IF9yZWYyLmRlbHRhWTtcbiAgICAgIC8vIFJlc2V0IGRhdGEgaW4gY2FzZSBpdCB3YXMgbGVmdCBvdmVyIHNvbWVob3cgKHNob3VsZCBub3QgYmUgcG9zc2libGUpXG4gICAgICBpZiAoaGFuZGxlck5hbWUgPT09ICdvblJlc2l6ZVN0YXJ0JykgX3RoaXMyLnJlc2V0RGF0YSgpO1xuXG4gICAgICAvLyBBeGlzIHJlc3RyaWN0aW9uc1xuICAgICAgdmFyIGNhbkRyYWdYID0gKF90aGlzMi5wcm9wcy5heGlzID09PSAnYm90aCcgfHwgX3RoaXMyLnByb3BzLmF4aXMgPT09ICd4JykgJiYgYXhpcyAhPT0gJ24nICYmIGF4aXMgIT09ICdzJztcbiAgICAgIHZhciBjYW5EcmFnWSA9IChfdGhpczIucHJvcHMuYXhpcyA9PT0gJ2JvdGgnIHx8IF90aGlzMi5wcm9wcy5heGlzID09PSAneScpICYmIGF4aXMgIT09ICdlJyAmJiBheGlzICE9PSAndyc7XG4gICAgICAvLyBObyBkcmFnZ2luZyBwb3NzaWJsZS5cbiAgICAgIGlmICghY2FuRHJhZ1ggJiYgIWNhbkRyYWdZKSByZXR1cm47XG5cbiAgICAgIC8vIERlY29tcG9zZSBheGlzIGZvciBsYXRlciB1c2VcbiAgICAgIHZhciBheGlzViA9IGF4aXNbMF07XG4gICAgICB2YXIgYXhpc0ggPSBheGlzW2F4aXMubGVuZ3RoIC0gMV07IC8vIGludGVudGlvbmFsbHkgbm90IGF4aXNbMV0sIHNvIHRoYXQgdGhpcyBjYXRjaGVzIGF4aXMgPT09ICd3JyBmb3IgZXhhbXBsZVxuXG4gICAgICAvLyBUcmFjayB0aGUgZWxlbWVudCBiZWluZyBkcmFnZ2VkIHRvIGFjY291bnQgZm9yIGNoYW5nZXMgaW4gcG9zaXRpb24uXG4gICAgICAvLyBJZiBhIGhhbmRsZSdzIHBvc2l0aW9uIGlzIGNoYW5nZWQgYmV0d2VlbiBjYWxsYmFja3MsIHdlIG5lZWQgdG8gZmFjdG9yIHRoaXMgaW4gdG8gdGhlIG5leHQgY2FsbGJhY2suXG4gICAgICAvLyBGYWlsdXJlIHRvIGRvIHNvIHdpbGwgY2F1c2UgdGhlIGVsZW1lbnQgdG8gXCJza2lwXCIgd2hlbiByZXNpemVkIHVwd2FyZHMgb3IgbGVmdHdhcmRzLlxuICAgICAgdmFyIGhhbmRsZVJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKF90aGlzMi5sYXN0SGFuZGxlUmVjdCAhPSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZSBoYW5kbGUgaGFzIHJlcG9zaXRpb25lZCBvbiBlaXRoZXIgYXhpcyBzaW5jZSBsYXN0IHJlbmRlcixcbiAgICAgICAgLy8gd2UgbmVlZCB0byBpbmNyZWFzZSBvdXIgY2FsbGJhY2sgdmFsdWVzIGJ5IHRoaXMgbXVjaC5cbiAgICAgICAgLy8gT25seSBjaGVja2luZyAnbicsICd3JyBzaW5jZSByZXNpemluZyBieSAncycsICd3JyB3b24ndCBhZmZlY3QgdGhlIG92ZXJhbGwgcG9zaXRpb24gb24gcGFnZSxcbiAgICAgICAgaWYgKGF4aXNIID09PSAndycpIHtcbiAgICAgICAgICB2YXIgZGVsdGFMZWZ0U2luY2VMYXN0ID0gaGFuZGxlUmVjdC5sZWZ0IC0gX3RoaXMyLmxhc3RIYW5kbGVSZWN0LmxlZnQ7XG4gICAgICAgICAgZGVsdGFYICs9IGRlbHRhTGVmdFNpbmNlTGFzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXhpc1YgPT09ICduJykge1xuICAgICAgICAgIHZhciBkZWx0YVRvcFNpbmNlTGFzdCA9IGhhbmRsZVJlY3QudG9wIC0gX3RoaXMyLmxhc3RIYW5kbGVSZWN0LnRvcDtcbiAgICAgICAgICBkZWx0YVkgKz0gZGVsdGFUb3BTaW5jZUxhc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFN0b3JhZ2Ugb2YgbGFzdCByZWN0IHNvIHdlIGtub3cgaG93IG11Y2ggaXQgaGFzIHJlYWxseSBtb3ZlZC5cbiAgICAgIF90aGlzMi5sYXN0SGFuZGxlUmVjdCA9IGhhbmRsZVJlY3Q7XG5cbiAgICAgIC8vIFJldmVyc2UgZGVsdGEgaWYgdXNpbmcgdG9wIG9yIGxlZnQgZHJhZyBoYW5kbGVzLlxuICAgICAgaWYgKGF4aXNIID09PSAndycpIGRlbHRhWCA9IC1kZWx0YVg7XG4gICAgICBpZiAoYXhpc1YgPT09ICduJykgZGVsdGFZID0gLWRlbHRhWTtcblxuICAgICAgLy8gVXBkYXRlIHcvaCBieSB0aGUgZGVsdGFzLiBBbHNvIGZhY3RvciBpbiB0cmFuc2Zvcm1TY2FsZS5cbiAgICAgIHZhciB3aWR0aCA9IF90aGlzMi5wcm9wcy53aWR0aCArIChjYW5EcmFnWCA/IGRlbHRhWCAvIF90aGlzMi5wcm9wcy50cmFuc2Zvcm1TY2FsZSA6IDApO1xuICAgICAgdmFyIGhlaWdodCA9IF90aGlzMi5wcm9wcy5oZWlnaHQgKyAoY2FuRHJhZ1kgPyBkZWx0YVkgLyBfdGhpczIucHJvcHMudHJhbnNmb3JtU2NhbGUgOiAwKTtcblxuICAgICAgLy8gUnVuIHVzZXItcHJvdmlkZWQgY29uc3RyYWludHMuXG4gICAgICB2YXIgX3RoaXMyJHJ1bkNvbnN0cmFpbnRzID0gX3RoaXMyLnJ1bkNvbnN0cmFpbnRzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgd2lkdGggPSBfdGhpczIkcnVuQ29uc3RyYWludHNbMF07XG4gICAgICBoZWlnaHQgPSBfdGhpczIkcnVuQ29uc3RyYWludHNbMV07XG4gICAgICB2YXIgZGltZW5zaW9uc0NoYW5nZWQgPSB3aWR0aCAhPT0gX3RoaXMyLnByb3BzLndpZHRoIHx8IGhlaWdodCAhPT0gX3RoaXMyLnByb3BzLmhlaWdodDtcblxuICAgICAgLy8gQ2FsbCB1c2VyLXN1cHBsaWVkIGNhbGxiYWNrIGlmIHByZXNlbnQuXG4gICAgICB2YXIgY2IgPSB0eXBlb2YgX3RoaXMyLnByb3BzW2hhbmRsZXJOYW1lXSA9PT0gJ2Z1bmN0aW9uJyA/IF90aGlzMi5wcm9wc1toYW5kbGVyTmFtZV0gOiBudWxsO1xuICAgICAgLy8gRG9uJ3QgY2FsbCAnb25SZXNpemUnIGlmIGRpbWVuc2lvbnMgaGF2ZW4ndCBjaGFuZ2VkLlxuICAgICAgdmFyIHNob3VsZFNraXBDYiA9IGhhbmRsZXJOYW1lID09PSAnb25SZXNpemUnICYmICFkaW1lbnNpb25zQ2hhbmdlZDtcbiAgICAgIGlmIChjYiAmJiAhc2hvdWxkU2tpcENiKSB7XG4gICAgICAgIGUucGVyc2lzdCA9PSBudWxsID8gdm9pZCAwIDogZS5wZXJzaXN0KCk7XG4gICAgICAgIGNiKGUsIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIHNpemU6IHtcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBoYW5kbGU6IGF4aXNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IGludGVybmFsIGRhdGFcbiAgICAgIGlmIChoYW5kbGVyTmFtZSA9PT0gJ29uUmVzaXplU3RvcCcpIF90aGlzMi5yZXNldERhdGEoKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmVuZGVyIGEgcmVzaXplIGhhbmRsZSBnaXZlbiBhbiBheGlzICYgRE9NIHJlZi4gUmVmICptdXN0KiBiZSBhdHRhY2hlZCBmb3JcbiAgLy8gdGhlIHVuZGVybHlpbmcgZHJhZ2dhYmxlIGxpYnJhcnkgdG8gd29yayBwcm9wZXJseS5cbiAgO1xuICBfcHJvdG8ucmVuZGVyUmVzaXplSGFuZGxlID0gZnVuY3Rpb24gcmVuZGVyUmVzaXplSGFuZGxlKGhhbmRsZUF4aXMsIHJlZikge1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLnByb3BzLmhhbmRsZTtcbiAgICAvLyBObyBoYW5kbGUgcHJvdmlkZWQsIG1ha2UgdGhlIGRlZmF1bHRcbiAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWFjdC1yZXNpemFibGUtaGFuZGxlIHJlYWN0LXJlc2l6YWJsZS1oYW5kbGUtXCIgKyBoYW5kbGVBeGlzLFxuICAgICAgICByZWY6IHJlZlxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEhhbmRsZSBpcyBhIGZ1bmN0aW9uLCBzdWNoIGFzOlxuICAgIC8vIGBoYW5kbGU9eyhoYW5kbGVBeGlzKSA9PiA8c3BhbiBjbGFzc05hbWU9ey4uLn0gLz59YFxuICAgIGlmICh0eXBlb2YgaGFuZGxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaGFuZGxlKGhhbmRsZUF4aXMsIHJlZik7XG4gICAgfVxuICAgIC8vIEhhbmRsZSBpcyBhIFJlYWN0IGNvbXBvbmVudCAoY29tcG9zaXRlIG9yIERPTSkuXG4gICAgdmFyIGlzRE9NRWxlbWVudCA9IHR5cGVvZiBoYW5kbGUudHlwZSA9PT0gJ3N0cmluZyc7XG4gICAgdmFyIHByb3BzID0gX29iamVjdFNwcmVhZCh7XG4gICAgICByZWY6IHJlZlxuICAgIH0sIGlzRE9NRWxlbWVudCA/IHt9IDoge1xuICAgICAgaGFuZGxlQXhpczogaGFuZGxlQXhpc1xuICAgIH0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGhhbmRsZSwgcHJvcHMpO1xuICB9O1xuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgIC8vIFBhc3MgYWxvbmcgb25seSBwcm9wcyBub3QgbWVhbnQgZm9yIHRoZSBgPFJlc2l6YWJsZT5gLmBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMyLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMyLmNsYXNzTmFtZSxcbiAgICAgIGRyYWdnYWJsZU9wdHMgPSBfdGhpcyRwcm9wczIuZHJhZ2dhYmxlT3B0cyxcbiAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHMyLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHMyLmhlaWdodCxcbiAgICAgIGhhbmRsZSA9IF90aGlzJHByb3BzMi5oYW5kbGUsXG4gICAgICBoYW5kbGVTaXplID0gX3RoaXMkcHJvcHMyLmhhbmRsZVNpemUsXG4gICAgICBsb2NrQXNwZWN0UmF0aW8gPSBfdGhpcyRwcm9wczIubG9ja0FzcGVjdFJhdGlvLFxuICAgICAgYXhpcyA9IF90aGlzJHByb3BzMi5heGlzLFxuICAgICAgbWluQ29uc3RyYWludHMgPSBfdGhpcyRwcm9wczIubWluQ29uc3RyYWludHMsXG4gICAgICBtYXhDb25zdHJhaW50cyA9IF90aGlzJHByb3BzMi5tYXhDb25zdHJhaW50cyxcbiAgICAgIG9uUmVzaXplID0gX3RoaXMkcHJvcHMyLm9uUmVzaXplLFxuICAgICAgb25SZXNpemVTdG9wID0gX3RoaXMkcHJvcHMyLm9uUmVzaXplU3RvcCxcbiAgICAgIG9uUmVzaXplU3RhcnQgPSBfdGhpcyRwcm9wczIub25SZXNpemVTdGFydCxcbiAgICAgIHJlc2l6ZUhhbmRsZXMgPSBfdGhpcyRwcm9wczIucmVzaXplSGFuZGxlcyxcbiAgICAgIHRyYW5zZm9ybVNjYWxlID0gX3RoaXMkcHJvcHMyLnRyYW5zZm9ybVNjYWxlLFxuICAgICAgcCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzMiwgX2V4Y2x1ZGVkKTtcblxuICAgIC8vIFdoYXQgd2UncmUgZG9pbmcgaGVyZSBpcyBnZXR0aW5nIHRoZSBjaGlsZCBvZiB0aGlzIGVsZW1lbnQsIGFuZCBjbG9uaW5nIGl0IHdpdGggdGhpcyBlbGVtZW50J3MgcHJvcHMuXG4gICAgLy8gV2UgYXJlIHRoZW4gZGVmaW5pbmcgaXRzIGNoaWxkcmVuIGFzOlxuICAgIC8vIDEuIEl0cyBvcmlnaW5hbCBjaGlsZHJlbiAocmVzaXphYmxlJ3MgY2hpbGQncyBjaGlsZHJlbiksIGFuZFxuICAgIC8vIDIuIE9uZSBvciBtb3JlIGRyYWdnYWJsZSBoYW5kbGVzLlxuICAgIHJldHVybiAoMCwgX3V0aWxzLmNsb25lRWxlbWVudCkoY2hpbGRyZW4sIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcCksIHt9LCB7XG4gICAgICBjbGFzc05hbWU6IChjbGFzc05hbWUgPyBjbGFzc05hbWUgKyBcIiBcIiA6ICcnKSArIFwicmVhY3QtcmVzaXphYmxlXCIsXG4gICAgICBjaGlsZHJlbjogW10uY29uY2F0KGNoaWxkcmVuLnByb3BzLmNoaWxkcmVuLCByZXNpemVIYW5kbGVzLm1hcChmdW5jdGlvbiAoaGFuZGxlQXhpcykge1xuICAgICAgICB2YXIgX3RoaXMzJGhhbmRsZVJlZnMkaGFuO1xuICAgICAgICAvLyBDcmVhdGUgYSByZWYgdG8gdGhlIGhhbmRsZSBzbyB0aGF0IGA8RHJhZ2dhYmxlQ29yZT5gIGRvZXNuJ3QgaGF2ZSB0byB1c2UgUmVhY3RET00uZmluZERPTU5vZGUoKS5cbiAgICAgICAgdmFyIHJlZiA9IChfdGhpczMkaGFuZGxlUmVmcyRoYW4gPSBfdGhpczMuaGFuZGxlUmVmc1toYW5kbGVBeGlzXSkgIT0gbnVsbCA/IF90aGlzMyRoYW5kbGVSZWZzJGhhbiA6IF90aGlzMy5oYW5kbGVSZWZzW2hhbmRsZUF4aXNdID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0RHJhZ2dhYmxlLkRyYWdnYWJsZUNvcmUsIF9leHRlbmRzKHt9LCBkcmFnZ2FibGVPcHRzLCB7XG4gICAgICAgICAgbm9kZVJlZjogcmVmLFxuICAgICAgICAgIGtleTogXCJyZXNpemFibGVIYW5kbGUtXCIgKyBoYW5kbGVBeGlzLFxuICAgICAgICAgIG9uU3RvcDogX3RoaXMzLnJlc2l6ZUhhbmRsZXIoJ29uUmVzaXplU3RvcCcsIGhhbmRsZUF4aXMpLFxuICAgICAgICAgIG9uU3RhcnQ6IF90aGlzMy5yZXNpemVIYW5kbGVyKCdvblJlc2l6ZVN0YXJ0JywgaGFuZGxlQXhpcyksXG4gICAgICAgICAgb25EcmFnOiBfdGhpczMucmVzaXplSGFuZGxlcignb25SZXNpemUnLCBoYW5kbGVBeGlzKVxuICAgICAgICB9KSwgX3RoaXMzLnJlbmRlclJlc2l6ZUhhbmRsZShoYW5kbGVBeGlzLCByZWYpKTtcbiAgICAgIH0pKVxuICAgIH0pKTtcbiAgfTtcbiAgcmV0dXJuIFJlc2l6YWJsZTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlc2l6YWJsZTtcblJlc2l6YWJsZS5wcm9wVHlwZXMgPSBfcHJvcFR5cGVzLnJlc2l6YWJsZVByb3BzO1xuUmVzaXphYmxlLmRlZmF1bHRQcm9wcyA9IHtcbiAgYXhpczogJ2JvdGgnLFxuICBoYW5kbGVTaXplOiBbMjAsIDIwXSxcbiAgbG9ja0FzcGVjdFJhdGlvOiBmYWxzZSxcbiAgbWluQ29uc3RyYWludHM6IFsyMCwgMjBdLFxuICBtYXhDb25zdHJhaW50czogW0luZmluaXR5LCBJbmZpbml0eV0sXG4gIHJlc2l6ZUhhbmRsZXM6IFsnc2UnXSxcbiAgdHJhbnNmb3JtU2NhbGU6IDFcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/react-resizable/build/Resizable.js\n");

/***/ }),

/***/ "../../node_modules/react-resizable/build/ResizableBox.js":
/*!****************************************************************!*\
  !*** ../../node_modules/react-resizable/build/ResizableBox.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"../../node_modules/prop-types/index.js\"));\nvar _Resizable = _interopRequireDefault(__webpack_require__(/*! ./Resizable */ \"../../node_modules/react-resizable/build/Resizable.js\"));\nvar _propTypes2 = __webpack_require__(/*! ./propTypes */ \"../../node_modules/react-resizable/build/propTypes.js\");\nvar _excluded = [\"handle\", \"handleSize\", \"onResize\", \"onResizeStart\", \"onResizeStop\", \"draggableOpts\", \"minConstraints\", \"maxConstraints\", \"lockAspectRatio\", \"axis\", \"width\", \"height\", \"resizeHandles\", \"style\", \"transformScale\"];\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nvar ResizableBox = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ResizableBox, _React$Component);\n  function ResizableBox() {\n    var _this;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.state = {\n      width: _this.props.width,\n      height: _this.props.height,\n      propsWidth: _this.props.width,\n      propsHeight: _this.props.height\n    };\n    _this.onResize = function (e, data) {\n      var size = data.size;\n      if (_this.props.onResize) {\n        e.persist == null ? void 0 : e.persist();\n        _this.setState(size, function () {\n          return _this.props.onResize && _this.props.onResize(e, data);\n        });\n      } else {\n        _this.setState(size);\n      }\n    };\n    return _this;\n  }\n  ResizableBox.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    // If parent changes height/width, set that in our state.\n    if (state.propsWidth !== props.width || state.propsHeight !== props.height) {\n      return {\n        width: props.width,\n        height: props.height,\n        propsWidth: props.width,\n        propsHeight: props.height\n      };\n    }\n    return null;\n  };\n  var _proto = ResizableBox.prototype;\n  _proto.render = function render() {\n    // Basic wrapper around a Resizable instance.\n    // If you use Resizable directly, you are responsible for updating the child component\n    // with a new width and height.\n    var _this$props = this.props,\n      handle = _this$props.handle,\n      handleSize = _this$props.handleSize,\n      onResize = _this$props.onResize,\n      onResizeStart = _this$props.onResizeStart,\n      onResizeStop = _this$props.onResizeStop,\n      draggableOpts = _this$props.draggableOpts,\n      minConstraints = _this$props.minConstraints,\n      maxConstraints = _this$props.maxConstraints,\n      lockAspectRatio = _this$props.lockAspectRatio,\n      axis = _this$props.axis,\n      width = _this$props.width,\n      height = _this$props.height,\n      resizeHandles = _this$props.resizeHandles,\n      style = _this$props.style,\n      transformScale = _this$props.transformScale,\n      props = _objectWithoutPropertiesLoose(_this$props, _excluded);\n    return /*#__PURE__*/React.createElement(_Resizable.default, {\n      axis: axis,\n      draggableOpts: draggableOpts,\n      handle: handle,\n      handleSize: handleSize,\n      height: this.state.height,\n      lockAspectRatio: lockAspectRatio,\n      maxConstraints: maxConstraints,\n      minConstraints: minConstraints,\n      onResizeStart: onResizeStart,\n      onResize: this.onResize,\n      onResizeStop: onResizeStop,\n      resizeHandles: resizeHandles,\n      transformScale: transformScale,\n      width: this.state.width\n    }, /*#__PURE__*/React.createElement(\"div\", _extends({}, props, {\n      style: _objectSpread(_objectSpread({}, style), {}, {\n        width: this.state.width + 'px',\n        height: this.state.height + 'px'\n      })\n    })));\n  };\n  return ResizableBox;\n}(React.Component);\nexports[\"default\"] = ResizableBox;\n// PropTypes are identical to <Resizable>, except that children are not strictly required to be present.\nResizableBox.propTypes = _objectSpread(_objectSpread({}, _propTypes2.resizableProps), {}, {\n  children: _propTypes.default.element\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc2l6YWJsZS9idWlsZC9SZXNpemFibGVCb3guanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9zdC8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzaXphYmxlL2J1aWxkL1Jlc2l6YWJsZUJveC5qcz85ZTBiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIFJlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG52YXIgX1Jlc2l6YWJsZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vUmVzaXphYmxlXCIpKTtcbnZhciBfcHJvcFR5cGVzMiA9IHJlcXVpcmUoXCIuL3Byb3BUeXBlc1wiKTtcbnZhciBfZXhjbHVkZWQgPSBbXCJoYW5kbGVcIiwgXCJoYW5kbGVTaXplXCIsIFwib25SZXNpemVcIiwgXCJvblJlc2l6ZVN0YXJ0XCIsIFwib25SZXNpemVTdG9wXCIsIFwiZHJhZ2dhYmxlT3B0c1wiLCBcIm1pbkNvbnN0cmFpbnRzXCIsIFwibWF4Q29uc3RyYWludHNcIiwgXCJsb2NrQXNwZWN0UmF0aW9cIiwgXCJheGlzXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJyZXNpemVIYW5kbGVzXCIsIFwic3R5bGVcIiwgXCJ0cmFuc2Zvcm1TY2FsZVwiXTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG52YXIgUmVzaXphYmxlQm94ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFJlc2l6YWJsZUJveCwgX1JlYWN0JENvbXBvbmVudCk7XG4gIGZ1bmN0aW9uIFJlc2l6YWJsZUJveCgpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgd2lkdGg6IF90aGlzLnByb3BzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBfdGhpcy5wcm9wcy5oZWlnaHQsXG4gICAgICBwcm9wc1dpZHRoOiBfdGhpcy5wcm9wcy53aWR0aCxcbiAgICAgIHByb3BzSGVpZ2h0OiBfdGhpcy5wcm9wcy5oZWlnaHRcbiAgICB9O1xuICAgIF90aGlzLm9uUmVzaXplID0gZnVuY3Rpb24gKGUsIGRhdGEpIHtcbiAgICAgIHZhciBzaXplID0gZGF0YS5zaXplO1xuICAgICAgaWYgKF90aGlzLnByb3BzLm9uUmVzaXplKSB7XG4gICAgICAgIGUucGVyc2lzdCA9PSBudWxsID8gdm9pZCAwIDogZS5wZXJzaXN0KCk7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHNpemUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMub25SZXNpemUgJiYgX3RoaXMucHJvcHMub25SZXNpemUoZSwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoc2l6ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgUmVzaXphYmxlQm94LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICAvLyBJZiBwYXJlbnQgY2hhbmdlcyBoZWlnaHQvd2lkdGgsIHNldCB0aGF0IGluIG91ciBzdGF0ZS5cbiAgICBpZiAoc3RhdGUucHJvcHNXaWR0aCAhPT0gcHJvcHMud2lkdGggfHwgc3RhdGUucHJvcHNIZWlnaHQgIT09IHByb3BzLmhlaWdodCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHByb3BzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHByb3BzLmhlaWdodCxcbiAgICAgICAgcHJvcHNXaWR0aDogcHJvcHMud2lkdGgsXG4gICAgICAgIHByb3BzSGVpZ2h0OiBwcm9wcy5oZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICB2YXIgX3Byb3RvID0gUmVzaXphYmxlQm94LnByb3RvdHlwZTtcbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAvLyBCYXNpYyB3cmFwcGVyIGFyb3VuZCBhIFJlc2l6YWJsZSBpbnN0YW5jZS5cbiAgICAvLyBJZiB5b3UgdXNlIFJlc2l6YWJsZSBkaXJlY3RseSwgeW91IGFyZSByZXNwb25zaWJsZSBmb3IgdXBkYXRpbmcgdGhlIGNoaWxkIGNvbXBvbmVudFxuICAgIC8vIHdpdGggYSBuZXcgd2lkdGggYW5kIGhlaWdodC5cbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgaGFuZGxlID0gX3RoaXMkcHJvcHMuaGFuZGxlLFxuICAgICAgaGFuZGxlU2l6ZSA9IF90aGlzJHByb3BzLmhhbmRsZVNpemUsXG4gICAgICBvblJlc2l6ZSA9IF90aGlzJHByb3BzLm9uUmVzaXplLFxuICAgICAgb25SZXNpemVTdGFydCA9IF90aGlzJHByb3BzLm9uUmVzaXplU3RhcnQsXG4gICAgICBvblJlc2l6ZVN0b3AgPSBfdGhpcyRwcm9wcy5vblJlc2l6ZVN0b3AsXG4gICAgICBkcmFnZ2FibGVPcHRzID0gX3RoaXMkcHJvcHMuZHJhZ2dhYmxlT3B0cyxcbiAgICAgIG1pbkNvbnN0cmFpbnRzID0gX3RoaXMkcHJvcHMubWluQ29uc3RyYWludHMsXG4gICAgICBtYXhDb25zdHJhaW50cyA9IF90aGlzJHByb3BzLm1heENvbnN0cmFpbnRzLFxuICAgICAgbG9ja0FzcGVjdFJhdGlvID0gX3RoaXMkcHJvcHMubG9ja0FzcGVjdFJhdGlvLFxuICAgICAgYXhpcyA9IF90aGlzJHByb3BzLmF4aXMsXG4gICAgICB3aWR0aCA9IF90aGlzJHByb3BzLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3RoaXMkcHJvcHMuaGVpZ2h0LFxuICAgICAgcmVzaXplSGFuZGxlcyA9IF90aGlzJHByb3BzLnJlc2l6ZUhhbmRsZXMsXG4gICAgICBzdHlsZSA9IF90aGlzJHByb3BzLnN0eWxlLFxuICAgICAgdHJhbnNmb3JtU2NhbGUgPSBfdGhpcyRwcm9wcy50cmFuc2Zvcm1TY2FsZSxcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIF9leGNsdWRlZCk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KF9SZXNpemFibGUuZGVmYXVsdCwge1xuICAgICAgYXhpczogYXhpcyxcbiAgICAgIGRyYWdnYWJsZU9wdHM6IGRyYWdnYWJsZU9wdHMsXG4gICAgICBoYW5kbGU6IGhhbmRsZSxcbiAgICAgIGhhbmRsZVNpemU6IGhhbmRsZVNpemUsXG4gICAgICBoZWlnaHQ6IHRoaXMuc3RhdGUuaGVpZ2h0LFxuICAgICAgbG9ja0FzcGVjdFJhdGlvOiBsb2NrQXNwZWN0UmF0aW8sXG4gICAgICBtYXhDb25zdHJhaW50czogbWF4Q29uc3RyYWludHMsXG4gICAgICBtaW5Db25zdHJhaW50czogbWluQ29uc3RyYWludHMsXG4gICAgICBvblJlc2l6ZVN0YXJ0OiBvblJlc2l6ZVN0YXJ0LFxuICAgICAgb25SZXNpemU6IHRoaXMub25SZXNpemUsXG4gICAgICBvblJlc2l6ZVN0b3A6IG9uUmVzaXplU3RvcCxcbiAgICAgIHJlc2l6ZUhhbmRsZXM6IHJlc2l6ZUhhbmRsZXMsXG4gICAgICB0cmFuc2Zvcm1TY2FsZTogdHJhbnNmb3JtU2NhbGUsXG4gICAgICB3aWR0aDogdGhpcy5zdGF0ZS53aWR0aFxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3R5bGUpLCB7fSwge1xuICAgICAgICB3aWR0aDogdGhpcy5zdGF0ZS53aWR0aCArICdweCcsXG4gICAgICAgIGhlaWdodDogdGhpcy5zdGF0ZS5oZWlnaHQgKyAncHgnXG4gICAgICB9KVxuICAgIH0pKSk7XG4gIH07XG4gIHJldHVybiBSZXNpemFibGVCb3g7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5leHBvcnRzLmRlZmF1bHQgPSBSZXNpemFibGVCb3g7XG4vLyBQcm9wVHlwZXMgYXJlIGlkZW50aWNhbCB0byA8UmVzaXphYmxlPiwgZXhjZXB0IHRoYXQgY2hpbGRyZW4gYXJlIG5vdCBzdHJpY3RseSByZXF1aXJlZCB0byBiZSBwcmVzZW50LlxuUmVzaXphYmxlQm94LnByb3BUeXBlcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3Byb3BUeXBlczIucmVzaXphYmxlUHJvcHMpLCB7fSwge1xuICBjaGlsZHJlbjogX3Byb3BUeXBlcy5kZWZhdWx0LmVsZW1lbnRcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/react-resizable/build/ResizableBox.js\n");

/***/ }),

/***/ "../../node_modules/react-resizable/build/propTypes.js":
/*!*************************************************************!*\
  !*** ../../node_modules/react-resizable/build/propTypes.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.resizableProps = void 0;\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"../../node_modules/prop-types/index.js\"));\nvar _reactDraggable = __webpack_require__(/*! react-draggable */ \"../../node_modules/react-draggable/build/cjs/cjs.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar resizableProps = {\n  /*\n  * Restricts resizing to a particular axis (default: 'both')\n  * 'both' - allows resizing by width or height\n  * 'x' - only allows the width to be changed\n  * 'y' - only allows the height to be changed\n  * 'none' - disables resizing altogether\n  * */\n  axis: _propTypes.default.oneOf(['both', 'x', 'y', 'none']),\n  className: _propTypes.default.string,\n  /*\n  * Require that one and only one child be present.\n  * */\n  children: _propTypes.default.element.isRequired,\n  /*\n  * These will be passed wholesale to react-draggable's DraggableCore\n  * */\n  draggableOpts: _propTypes.default.shape({\n    allowAnyClick: _propTypes.default.bool,\n    cancel: _propTypes.default.string,\n    children: _propTypes.default.node,\n    disabled: _propTypes.default.bool,\n    enableUserSelectHack: _propTypes.default.bool,\n    offsetParent: _propTypes.default.node,\n    grid: _propTypes.default.arrayOf(_propTypes.default.number),\n    handle: _propTypes.default.string,\n    nodeRef: _propTypes.default.object,\n    onStart: _propTypes.default.func,\n    onDrag: _propTypes.default.func,\n    onStop: _propTypes.default.func,\n    onMouseDown: _propTypes.default.func,\n    scale: _propTypes.default.number\n  }),\n  /*\n  * Initial height\n  * */\n  height: function height() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var props = args[0];\n    // Required if resizing height or both\n    if (props.axis === 'both' || props.axis === 'y') {\n      var _PropTypes$number;\n      return (_PropTypes$number = _propTypes.default.number).isRequired.apply(_PropTypes$number, args);\n    }\n    return _propTypes.default.number.apply(_propTypes.default, args);\n  },\n  /*\n  * Customize cursor resize handle\n  * */\n  handle: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]),\n  /*\n  * If you change this, be sure to update your css\n  * */\n  handleSize: _propTypes.default.arrayOf(_propTypes.default.number),\n  lockAspectRatio: _propTypes.default.bool,\n  /*\n  * Max X & Y measure\n  * */\n  maxConstraints: _propTypes.default.arrayOf(_propTypes.default.number),\n  /*\n  * Min X & Y measure\n  * */\n  minConstraints: _propTypes.default.arrayOf(_propTypes.default.number),\n  /*\n  * Called on stop resize event\n  * */\n  onResizeStop: _propTypes.default.func,\n  /*\n  * Called on start resize event\n  * */\n  onResizeStart: _propTypes.default.func,\n  /*\n  * Called on resize event\n  * */\n  onResize: _propTypes.default.func,\n  /*\n  * Defines which resize handles should be rendered (default: 'se')\n  * 's' - South handle (bottom-center)\n  * 'w' - West handle (left-center)\n  * 'e' - East handle (right-center)\n  * 'n' - North handle (top-center)\n  * 'sw' - Southwest handle (bottom-left)\n  * 'nw' - Northwest handle (top-left)\n  * 'se' - Southeast handle (bottom-right)\n  * 'ne' - Northeast handle (top-center)\n  * */\n  resizeHandles: _propTypes.default.arrayOf(_propTypes.default.oneOf(['s', 'w', 'e', 'n', 'sw', 'nw', 'se', 'ne'])),\n  /*\n  * If `transform: scale(n)` is set on the parent, this should be set to `n`.\n  * */\n  transformScale: _propTypes.default.number,\n  /*\n   * Initial width\n   */\n  width: function width() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    var props = args[0];\n    // Required if resizing width or both\n    if (props.axis === 'both' || props.axis === 'x') {\n      var _PropTypes$number2;\n      return (_PropTypes$number2 = _propTypes.default.number).isRequired.apply(_PropTypes$number2, args);\n    }\n    return _propTypes.default.number.apply(_propTypes.default, args);\n  }\n};\nexports.resizableProps = resizableProps;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc2l6YWJsZS9idWlsZC9wcm9wVHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9zdC8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzaXphYmxlL2J1aWxkL3Byb3BUeXBlcy5qcz9lYWJiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5yZXNpemFibGVQcm9wcyA9IHZvaWQgMDtcbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG52YXIgX3JlYWN0RHJhZ2dhYmxlID0gcmVxdWlyZShcInJlYWN0LWRyYWdnYWJsZVwiKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG52YXIgcmVzaXphYmxlUHJvcHMgPSB7XG4gIC8qXG4gICogUmVzdHJpY3RzIHJlc2l6aW5nIHRvIGEgcGFydGljdWxhciBheGlzIChkZWZhdWx0OiAnYm90aCcpXG4gICogJ2JvdGgnIC0gYWxsb3dzIHJlc2l6aW5nIGJ5IHdpZHRoIG9yIGhlaWdodFxuICAqICd4JyAtIG9ubHkgYWxsb3dzIHRoZSB3aWR0aCB0byBiZSBjaGFuZ2VkXG4gICogJ3knIC0gb25seSBhbGxvd3MgdGhlIGhlaWdodCB0byBiZSBjaGFuZ2VkXG4gICogJ25vbmUnIC0gZGlzYWJsZXMgcmVzaXppbmcgYWx0b2dldGhlclxuICAqICovXG4gIGF4aXM6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbJ2JvdGgnLCAneCcsICd5JywgJ25vbmUnXSksXG4gIGNsYXNzTmFtZTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgLypcbiAgKiBSZXF1aXJlIHRoYXQgb25lIGFuZCBvbmx5IG9uZSBjaGlsZCBiZSBwcmVzZW50LlxuICAqICovXG4gIGNoaWxkcmVuOiBfcHJvcFR5cGVzLmRlZmF1bHQuZWxlbWVudC5pc1JlcXVpcmVkLFxuICAvKlxuICAqIFRoZXNlIHdpbGwgYmUgcGFzc2VkIHdob2xlc2FsZSB0byByZWFjdC1kcmFnZ2FibGUncyBEcmFnZ2FibGVDb3JlXG4gICogKi9cbiAgZHJhZ2dhYmxlT3B0czogX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICBhbGxvd0FueUNsaWNrOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgICBjYW5jZWw6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gICAgY2hpbGRyZW46IF9wcm9wVHlwZXMuZGVmYXVsdC5ub2RlLFxuICAgIGRpc2FibGVkOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgICBlbmFibGVVc2VyU2VsZWN0SGFjazogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gICAgb2Zmc2V0UGFyZW50OiBfcHJvcFR5cGVzLmRlZmF1bHQubm9kZSxcbiAgICBncmlkOiBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyKSxcbiAgICBoYW5kbGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gICAgbm9kZVJlZjogX3Byb3BUeXBlcy5kZWZhdWx0Lm9iamVjdCxcbiAgICBvblN0YXJ0OiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgICBvbkRyYWc6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAgIG9uU3RvcDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gICAgb25Nb3VzZURvd246IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAgIHNjYWxlOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyXG4gIH0pLFxuICAvKlxuICAqIEluaXRpYWwgaGVpZ2h0XG4gICogKi9cbiAgaGVpZ2h0OiBmdW5jdGlvbiBoZWlnaHQoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICB2YXIgcHJvcHMgPSBhcmdzWzBdO1xuICAgIC8vIFJlcXVpcmVkIGlmIHJlc2l6aW5nIGhlaWdodCBvciBib3RoXG4gICAgaWYgKHByb3BzLmF4aXMgPT09ICdib3RoJyB8fCBwcm9wcy5heGlzID09PSAneScpIHtcbiAgICAgIHZhciBfUHJvcFR5cGVzJG51bWJlcjtcbiAgICAgIHJldHVybiAoX1Byb3BUeXBlcyRudW1iZXIgPSBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyKS5pc1JlcXVpcmVkLmFwcGx5KF9Qcm9wVHlwZXMkbnVtYmVyLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuYXBwbHkoX3Byb3BUeXBlcy5kZWZhdWx0LCBhcmdzKTtcbiAgfSxcbiAgLypcbiAgKiBDdXN0b21pemUgY3Vyc29yIHJlc2l6ZSBoYW5kbGVcbiAgKiAqL1xuICBoYW5kbGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5ub2RlLCBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuY10pLFxuICAvKlxuICAqIElmIHlvdSBjaGFuZ2UgdGhpcywgYmUgc3VyZSB0byB1cGRhdGUgeW91ciBjc3NcbiAgKiAqL1xuICBoYW5kbGVTaXplOiBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyKSxcbiAgbG9ja0FzcGVjdFJhdGlvOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLypcbiAgKiBNYXggWCAmIFkgbWVhc3VyZVxuICAqICovXG4gIG1heENvbnN0cmFpbnRzOiBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyKSxcbiAgLypcbiAgKiBNaW4gWCAmIFkgbWVhc3VyZVxuICAqICovXG4gIG1pbkNvbnN0cmFpbnRzOiBfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyKSxcbiAgLypcbiAgKiBDYWxsZWQgb24gc3RvcCByZXNpemUgZXZlbnRcbiAgKiAqL1xuICBvblJlc2l6ZVN0b3A6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAvKlxuICAqIENhbGxlZCBvbiBzdGFydCByZXNpemUgZXZlbnRcbiAgKiAqL1xuICBvblJlc2l6ZVN0YXJ0OiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLypcbiAgKiBDYWxsZWQgb24gcmVzaXplIGV2ZW50XG4gICogKi9cbiAgb25SZXNpemU6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAvKlxuICAqIERlZmluZXMgd2hpY2ggcmVzaXplIGhhbmRsZXMgc2hvdWxkIGJlIHJlbmRlcmVkIChkZWZhdWx0OiAnc2UnKVxuICAqICdzJyAtIFNvdXRoIGhhbmRsZSAoYm90dG9tLWNlbnRlcilcbiAgKiAndycgLSBXZXN0IGhhbmRsZSAobGVmdC1jZW50ZXIpXG4gICogJ2UnIC0gRWFzdCBoYW5kbGUgKHJpZ2h0LWNlbnRlcilcbiAgKiAnbicgLSBOb3J0aCBoYW5kbGUgKHRvcC1jZW50ZXIpXG4gICogJ3N3JyAtIFNvdXRod2VzdCBoYW5kbGUgKGJvdHRvbS1sZWZ0KVxuICAqICdudycgLSBOb3J0aHdlc3QgaGFuZGxlICh0b3AtbGVmdClcbiAgKiAnc2UnIC0gU291dGhlYXN0IGhhbmRsZSAoYm90dG9tLXJpZ2h0KVxuICAqICduZScgLSBOb3J0aGVhc3QgaGFuZGxlICh0b3AtY2VudGVyKVxuICAqICovXG4gIHJlc2l6ZUhhbmRsZXM6IF9wcm9wVHlwZXMuZGVmYXVsdC5hcnJheU9mKF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbJ3MnLCAndycsICdlJywgJ24nLCAnc3cnLCAnbncnLCAnc2UnLCAnbmUnXSkpLFxuICAvKlxuICAqIElmIGB0cmFuc2Zvcm06IHNjYWxlKG4pYCBpcyBzZXQgb24gdGhlIHBhcmVudCwgdGhpcyBzaG91bGQgYmUgc2V0IHRvIGBuYC5cbiAgKiAqL1xuICB0cmFuc2Zvcm1TY2FsZTogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgLypcbiAgICogSW5pdGlhbCB3aWR0aFxuICAgKi9cbiAgd2lkdGg6IGZ1bmN0aW9uIHdpZHRoKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICB2YXIgcHJvcHMgPSBhcmdzWzBdO1xuICAgIC8vIFJlcXVpcmVkIGlmIHJlc2l6aW5nIHdpZHRoIG9yIGJvdGhcbiAgICBpZiAocHJvcHMuYXhpcyA9PT0gJ2JvdGgnIHx8IHByb3BzLmF4aXMgPT09ICd4Jykge1xuICAgICAgdmFyIF9Qcm9wVHlwZXMkbnVtYmVyMjtcbiAgICAgIHJldHVybiAoX1Byb3BUeXBlcyRudW1iZXIyID0gX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcikuaXNSZXF1aXJlZC5hcHBseShfUHJvcFR5cGVzJG51bWJlcjIsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5hcHBseShfcHJvcFR5cGVzLmRlZmF1bHQsIGFyZ3MpO1xuICB9XG59O1xuZXhwb3J0cy5yZXNpemFibGVQcm9wcyA9IHJlc2l6YWJsZVByb3BzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/react-resizable/build/propTypes.js\n");

/***/ }),

/***/ "../../node_modules/react-resizable/build/utils.js":
/*!*********************************************************!*\
  !*** ../../node_modules/react-resizable/build/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.cloneElement = cloneElement;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n// React.addons.cloneWithProps look-alike that merges style & className.\nfunction cloneElement(element, props) {\n  if (props.style && element.props.style) {\n    props.style = _objectSpread(_objectSpread({}, element.props.style), props.style);\n  }\n  if (props.className && element.props.className) {\n    props.className = element.props.className + \" \" + props.className;\n  }\n  return /*#__PURE__*/_react.default.cloneElement(element, props);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc2l6YWJsZS9idWlsZC91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNpemFibGUvYnVpbGQvdXRpbHMuanM/ZjljNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY2xvbmVFbGVtZW50ID0gY2xvbmVFbGVtZW50O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbi8vIFJlYWN0LmFkZG9ucy5jbG9uZVdpdGhQcm9wcyBsb29rLWFsaWtlIHRoYXQgbWVyZ2VzIHN0eWxlICYgY2xhc3NOYW1lLlxuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIHByb3BzKSB7XG4gIGlmIChwcm9wcy5zdHlsZSAmJiBlbGVtZW50LnByb3BzLnN0eWxlKSB7XG4gICAgcHJvcHMuc3R5bGUgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVsZW1lbnQucHJvcHMuc3R5bGUpLCBwcm9wcy5zdHlsZSk7XG4gIH1cbiAgaWYgKHByb3BzLmNsYXNzTmFtZSAmJiBlbGVtZW50LnByb3BzLmNsYXNzTmFtZSkge1xuICAgIHByb3BzLmNsYXNzTmFtZSA9IGVsZW1lbnQucHJvcHMuY2xhc3NOYW1lICsgXCIgXCIgKyBwcm9wcy5jbGFzc05hbWU7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoZWxlbWVudCwgcHJvcHMpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/react-resizable/build/utils.js\n");

/***/ }),

/***/ "../../node_modules/react-resizable/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/react-resizable/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = function() {\n  throw new Error(\"Don't instantiate Resizable directly! Use require('react-resizable').Resizable\");\n};\n\nmodule.exports.Resizable = __webpack_require__(/*! ./build/Resizable */ \"../../node_modules/react-resizable/build/Resizable.js\")[\"default\"];\nmodule.exports.ResizableBox = __webpack_require__(/*! ./build/ResizableBox */ \"../../node_modules/react-resizable/build/ResizableBox.js\")[\"default\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc2l6YWJsZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc2l6YWJsZS9pbmRleC5qcz9lZTRiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIkRvbid0IGluc3RhbnRpYXRlIFJlc2l6YWJsZSBkaXJlY3RseSEgVXNlIHJlcXVpcmUoJ3JlYWN0LXJlc2l6YWJsZScpLlJlc2l6YWJsZVwiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLlJlc2l6YWJsZSA9IHJlcXVpcmUoJy4vYnVpbGQvUmVzaXphYmxlJykuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLlJlc2l6YWJsZUJveCA9IHJlcXVpcmUoJy4vYnVpbGQvUmVzaXphYmxlQm94JykuZGVmYXVsdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/react-resizable/index.js\n");

/***/ }),

/***/ "../../node_modules/react-tiny-popover/dist/ArrowContainer.js":
/*!********************************************************************!*\
  !*** ../../node_modules/react-tiny-popover/dist/ArrowContainer.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ArrowContainer = void 0;\nvar jsx_runtime_1 = __webpack_require__(/*! react/jsx-runtime */ \"../../node_modules/react/jsx-runtime.js\");\nvar react_1 = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\nvar useArrowContainer_1 = __webpack_require__(/*! ./useArrowContainer */ \"../../node_modules/react-tiny-popover/dist/useArrowContainer.js\");\nvar ArrowContainer = function (_a) {\n    var childRect = _a.childRect, popoverRect = _a.popoverRect, position = _a.position, arrowColor = _a.arrowColor, arrowSize = _a.arrowSize, arrowClassName = _a.arrowClassName, externalArrowStyle = _a.arrowStyle, className = _a.className, children = _a.children, externalArrowContainerStyle = _a.style;\n    var _b = (0, useArrowContainer_1.useArrowContainer)({\n        childRect: childRect,\n        popoverRect: popoverRect,\n        position: position,\n        arrowColor: arrowColor,\n        arrowSize: arrowSize,\n    }), arrowContainerStyle = _b.arrowContainerStyle, arrowStyle = _b.arrowStyle;\n    var mergedContainerStyle = (0, react_1.useMemo)(function () { return (__assign(__assign({}, arrowContainerStyle), externalArrowContainerStyle)); }, [arrowContainerStyle, externalArrowContainerStyle]);\n    var mergedArrowStyle = (0, react_1.useMemo)(function () { return (__assign(__assign({}, arrowStyle), externalArrowStyle)); }, [arrowStyle, externalArrowStyle]);\n    return ((0, jsx_runtime_1.jsxs)(\"div\", { className: className, style: mergedContainerStyle, children: [(0, jsx_runtime_1.jsx)(\"div\", { style: mergedArrowStyle, className: arrowClassName }), children] }));\n};\nexports.ArrowContainer = ArrowContainer;\n//# sourceMappingURL=ArrowContainer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXRpbnktcG9wb3Zlci9kaXN0L0Fycm93Q29udGFpbmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC10aW55LXBvcG92ZXIvZGlzdC9BcnJvd0NvbnRhaW5lci5qcz84MTdmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXJyb3dDb250YWluZXIgPSB2b2lkIDA7XG52YXIganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbnZhciByZWFjdF8xID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIHVzZUFycm93Q29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi91c2VBcnJvd0NvbnRhaW5lclwiKTtcbnZhciBBcnJvd0NvbnRhaW5lciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjaGlsZFJlY3QgPSBfYS5jaGlsZFJlY3QsIHBvcG92ZXJSZWN0ID0gX2EucG9wb3ZlclJlY3QsIHBvc2l0aW9uID0gX2EucG9zaXRpb24sIGFycm93Q29sb3IgPSBfYS5hcnJvd0NvbG9yLCBhcnJvd1NpemUgPSBfYS5hcnJvd1NpemUsIGFycm93Q2xhc3NOYW1lID0gX2EuYXJyb3dDbGFzc05hbWUsIGV4dGVybmFsQXJyb3dTdHlsZSA9IF9hLmFycm93U3R5bGUsIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgZXh0ZXJuYWxBcnJvd0NvbnRhaW5lclN0eWxlID0gX2Euc3R5bGU7XG4gICAgdmFyIF9iID0gKDAsIHVzZUFycm93Q29udGFpbmVyXzEudXNlQXJyb3dDb250YWluZXIpKHtcbiAgICAgICAgY2hpbGRSZWN0OiBjaGlsZFJlY3QsXG4gICAgICAgIHBvcG92ZXJSZWN0OiBwb3BvdmVyUmVjdCxcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICBhcnJvd0NvbG9yOiBhcnJvd0NvbG9yLFxuICAgICAgICBhcnJvd1NpemU6IGFycm93U2l6ZSxcbiAgICB9KSwgYXJyb3dDb250YWluZXJTdHlsZSA9IF9iLmFycm93Q29udGFpbmVyU3R5bGUsIGFycm93U3R5bGUgPSBfYi5hcnJvd1N0eWxlO1xuICAgIHZhciBtZXJnZWRDb250YWluZXJTdHlsZSA9ICgwLCByZWFjdF8xLnVzZU1lbW8pKGZ1bmN0aW9uICgpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYXJyb3dDb250YWluZXJTdHlsZSksIGV4dGVybmFsQXJyb3dDb250YWluZXJTdHlsZSkpOyB9LCBbYXJyb3dDb250YWluZXJTdHlsZSwgZXh0ZXJuYWxBcnJvd0NvbnRhaW5lclN0eWxlXSk7XG4gICAgdmFyIG1lcmdlZEFycm93U3R5bGUgPSAoMCwgcmVhY3RfMS51c2VNZW1vKShmdW5jdGlvbiAoKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIGFycm93U3R5bGUpLCBleHRlcm5hbEFycm93U3R5bGUpKTsgfSwgW2Fycm93U3R5bGUsIGV4dGVybmFsQXJyb3dTdHlsZV0pO1xuICAgIHJldHVybiAoKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgc3R5bGU6IG1lcmdlZENvbnRhaW5lclN0eWxlLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJkaXZcIiwgeyBzdHlsZTogbWVyZ2VkQXJyb3dTdHlsZSwgY2xhc3NOYW1lOiBhcnJvd0NsYXNzTmFtZSB9KSwgY2hpbGRyZW5dIH0pKTtcbn07XG5leHBvcnRzLkFycm93Q29udGFpbmVyID0gQXJyb3dDb250YWluZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcnJvd0NvbnRhaW5lci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/react-tiny-popover/dist/ArrowContainer.js\n");

/***/ }),

/***/ "../../node_modules/react-tiny-popover/dist/Popover.js":
/*!*************************************************************!*\
  !*** ../../node_modules/react-tiny-popover/dist/Popover.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Popover = exports.usePopover = exports.ArrowContainer = exports.useArrowContainer = void 0;\nvar jsx_runtime_1 = __webpack_require__(/*! react/jsx-runtime */ \"../../node_modules/react/jsx-runtime.js\");\nvar react_1 = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\nvar PopoverPortal_1 = __webpack_require__(/*! ./PopoverPortal */ \"../../node_modules/react-tiny-popover/dist/PopoverPortal.js\");\nvar util_1 = __webpack_require__(/*! ./util */ \"../../node_modules/react-tiny-popover/dist/util.js\");\nvar usePopover_1 = __webpack_require__(/*! ./usePopover */ \"../../node_modules/react-tiny-popover/dist/usePopover.js\");\nObject.defineProperty(exports, \"usePopover\", ({ enumerable: true, get: function () { return usePopover_1.usePopover; } }));\nvar useMemoizedArray_1 = __webpack_require__(/*! ./useMemoizedArray */ \"../../node_modules/react-tiny-popover/dist/useMemoizedArray.js\");\nvar useHandlePrevValues_1 = __webpack_require__(/*! ./useHandlePrevValues */ \"../../node_modules/react-tiny-popover/dist/useHandlePrevValues.js\");\nvar useArrowContainer_1 = __webpack_require__(/*! ./useArrowContainer */ \"../../node_modules/react-tiny-popover/dist/useArrowContainer.js\");\nObject.defineProperty(exports, \"useArrowContainer\", ({ enumerable: true, get: function () { return useArrowContainer_1.useArrowContainer; } }));\nvar ArrowContainer_1 = __webpack_require__(/*! ./ArrowContainer */ \"../../node_modules/react-tiny-popover/dist/ArrowContainer.js\");\nObject.defineProperty(exports, \"ArrowContainer\", ({ enumerable: true, get: function () { return ArrowContainer_1.ArrowContainer; } }));\nvar DEFAULT_POSITIONS = ['top', 'left', 'right', 'bottom'];\nvar PopoverInternal = (0, react_1.forwardRef)(function (_a, externalRef) {\n    var isOpen = _a.isOpen, children = _a.children, content = _a.content, _b = _a.positions, externalPositions = _b === void 0 ? DEFAULT_POSITIONS : _b, _c = _a.align, align = _c === void 0 ? 'center' : _c, _d = _a.padding, padding = _d === void 0 ? 0 : _d, _e = _a.reposition, reposition = _e === void 0 ? true : _e, _f = _a.parentElement, parentElement = _f === void 0 ? window.document.body : _f, _g = _a.boundaryElement, boundaryElement = _g === void 0 ? parentElement : _g, containerClassName = _a.containerClassName, containerStyle = _a.containerStyle, transform = _a.transform, _h = _a.transformMode, transformMode = _h === void 0 ? 'absolute' : _h, _j = _a.boundaryInset, boundaryInset = _j === void 0 ? 0 : _j, onClickOutside = _a.onClickOutside, _k = _a.clickOutsideCapture, clickOutsideCapture = _k === void 0 ? false : _k;\n    var positions = (0, useMemoizedArray_1.useMemoizedArray)(Array.isArray(externalPositions) ? externalPositions : [externalPositions]);\n    var _l = (0, useHandlePrevValues_1.useHandlePrevValues)({\n        positions: positions,\n        reposition: reposition,\n        transformMode: transformMode,\n        transform: transform,\n        boundaryElement: boundaryElement,\n        boundaryInset: boundaryInset,\n    }), prev = _l.prev, updatePrevValues = _l.updatePrevValues;\n    var childRef = (0, react_1.useRef)();\n    var _m = (0, react_1.useState)({\n        align: align,\n        nudgedLeft: 0,\n        nudgedTop: 0,\n        position: positions[0],\n        padding: padding,\n        childRect: util_1.EMPTY_RECT,\n        popoverRect: util_1.EMPTY_RECT,\n        parentRect: util_1.EMPTY_RECT,\n        boundaryRect: util_1.EMPTY_RECT,\n        boundaryInset: boundaryInset,\n        violations: util_1.EMPTY_RECT,\n        hasViolations: false,\n    }), popoverState = _m[0], setPopoverState = _m[1];\n    var onPositionPopover = (0, react_1.useCallback)(function (popoverState) { return setPopoverState(popoverState); }, []);\n    var _o = (0, usePopover_1.usePopover)({\n        isOpen: isOpen,\n        childRef: childRef,\n        containerClassName: containerClassName,\n        parentElement: parentElement,\n        boundaryElement: boundaryElement,\n        transform: transform,\n        transformMode: transformMode,\n        positions: positions,\n        align: align,\n        padding: padding,\n        boundaryInset: boundaryInset,\n        reposition: reposition,\n        onPositionPopover: onPositionPopover,\n    }), positionPopover = _o.positionPopover, popoverRef = _o.popoverRef, scoutRef = _o.scoutRef;\n    (0, react_1.useLayoutEffect)(function () {\n        var shouldUpdate = true;\n        var updatePopover = function () {\n            var _a, _b;\n            if (isOpen && shouldUpdate) {\n                var childRect = (_a = childRef === null || childRef === void 0 ? void 0 : childRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();\n                var popoverRect = (_b = popoverRef === null || popoverRef === void 0 ? void 0 : popoverRef.current) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect();\n                if (childRect != null &&\n                    popoverRect != null &&\n                    (!(0, util_1.rectsAreEqual)(childRect, popoverState.childRect) ||\n                        popoverRect.width !== popoverState.popoverRect.width ||\n                        popoverRect.height !== popoverState.popoverRect.height ||\n                        popoverState.padding !== padding ||\n                        popoverState.align !== align ||\n                        positions !== prev.positions ||\n                        reposition !== prev.reposition ||\n                        transformMode !== prev.transformMode ||\n                        transform !== prev.transform ||\n                        boundaryElement !== prev.boundaryElement ||\n                        boundaryInset !== prev.boundaryInset)) {\n                    positionPopover();\n                }\n                updatePrevValues();\n                if (shouldUpdate) {\n                    window.requestAnimationFrame(updatePopover);\n                }\n            }\n        };\n        updatePopover();\n        return function () {\n            shouldUpdate = false;\n        };\n    }, [\n        align,\n        boundaryElement,\n        boundaryInset,\n        isOpen,\n        padding,\n        popoverRef,\n        popoverState.align,\n        popoverState.childRect,\n        popoverState.padding,\n        popoverState.popoverRect.height,\n        popoverState.popoverRect.width,\n        positionPopover,\n        positions,\n        prev.boundaryElement,\n        prev.boundaryInset,\n        prev.positions,\n        prev.reposition,\n        prev.transform,\n        prev.transformMode,\n        reposition,\n        transform,\n        transformMode,\n        updatePrevValues,\n    ]);\n    (0, react_1.useEffect)(function () {\n        var popoverElement = popoverRef.current;\n        Object.assign(popoverElement.style, containerStyle);\n        return function () {\n            Object.keys(containerStyle !== null && containerStyle !== void 0 ? containerStyle : {}).forEach(function (key) {\n                return delete popoverElement.style[key];\n            });\n        };\n    }, [containerStyle, isOpen, popoverRef]);\n    var handleOnClickOutside = (0, react_1.useCallback)(function (e) {\n        var _a, _b;\n        if (isOpen &&\n            !((_a = popoverRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target)) &&\n            !((_b = childRef.current) === null || _b === void 0 ? void 0 : _b.contains(e.target))) {\n            onClickOutside === null || onClickOutside === void 0 ? void 0 : onClickOutside(e);\n        }\n    }, [isOpen, onClickOutside, popoverRef]);\n    var handleWindowResize = (0, react_1.useCallback)(function () {\n        if (childRef.current && isOpen) {\n            window.requestAnimationFrame(function () { return positionPopover(); });\n        }\n    }, [positionPopover, isOpen]);\n    (0, react_1.useEffect)(function () {\n        var body = parentElement.ownerDocument.body;\n        body.addEventListener('click', handleOnClickOutside, clickOutsideCapture);\n        body.addEventListener('contextmenu', handleOnClickOutside, clickOutsideCapture);\n        window.addEventListener('resize', handleWindowResize);\n        return function () {\n            body.removeEventListener('click', handleOnClickOutside, clickOutsideCapture);\n            body.removeEventListener('contextmenu', handleOnClickOutside, clickOutsideCapture);\n            window.removeEventListener('resize', handleWindowResize);\n        };\n    }, [clickOutsideCapture, handleOnClickOutside, handleWindowResize, parentElement]);\n    var handleRef = (0, react_1.useCallback)(function (node) {\n        childRef.current = node;\n        if (externalRef != null) {\n            if (typeof externalRef === 'object') {\n                externalRef.current = node;\n            }\n            else if (typeof externalRef === 'function') {\n                externalRef(node);\n            }\n        }\n    }, [externalRef]);\n    var renderChild = function () { return (0, react_1.cloneElement)(children, { ref: handleRef }); };\n    var renderPopover = function () {\n        if (!isOpen)\n            return null;\n        return ((0, jsx_runtime_1.jsx)(PopoverPortal_1.PopoverPortal, { element: popoverRef.current, scoutElement: scoutRef.current, container: parentElement, children: typeof content === 'function' ? content(popoverState) : content }));\n    };\n    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [renderChild(), renderPopover()] }));\n});\nexports.Popover = (0, react_1.forwardRef)(function (props, ref) {\n    if (typeof window === 'undefined')\n        return props.children;\n    return (0, jsx_runtime_1.jsx)(PopoverInternal, __assign({}, props, { ref: ref }));\n});\n//# sourceMappingURL=Popover.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXRpbnktcG9wb3Zlci9kaXN0L1BvcG92ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC10aW55LXBvcG92ZXIvZGlzdC9Qb3BvdmVyLmpzP2JlODAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb3BvdmVyID0gZXhwb3J0cy51c2VQb3BvdmVyID0gZXhwb3J0cy5BcnJvd0NvbnRhaW5lciA9IGV4cG9ydHMudXNlQXJyb3dDb250YWluZXIgPSB2b2lkIDA7XG52YXIganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbnZhciByZWFjdF8xID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIFBvcG92ZXJQb3J0YWxfMSA9IHJlcXVpcmUoXCIuL1BvcG92ZXJQb3J0YWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciB1c2VQb3BvdmVyXzEgPSByZXF1aXJlKFwiLi91c2VQb3BvdmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXNlUG9wb3ZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXNlUG9wb3Zlcl8xLnVzZVBvcG92ZXI7IH0gfSk7XG52YXIgdXNlTWVtb2l6ZWRBcnJheV8xID0gcmVxdWlyZShcIi4vdXNlTWVtb2l6ZWRBcnJheVwiKTtcbnZhciB1c2VIYW5kbGVQcmV2VmFsdWVzXzEgPSByZXF1aXJlKFwiLi91c2VIYW5kbGVQcmV2VmFsdWVzXCIpO1xudmFyIHVzZUFycm93Q29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi91c2VBcnJvd0NvbnRhaW5lclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVzZUFycm93Q29udGFpbmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1c2VBcnJvd0NvbnRhaW5lcl8xLnVzZUFycm93Q29udGFpbmVyOyB9IH0pO1xudmFyIEFycm93Q29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9BcnJvd0NvbnRhaW5lclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFycm93Q29udGFpbmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBBcnJvd0NvbnRhaW5lcl8xLkFycm93Q29udGFpbmVyOyB9IH0pO1xudmFyIERFRkFVTFRfUE9TSVRJT05TID0gWyd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nXTtcbnZhciBQb3BvdmVySW50ZXJuYWwgPSAoMCwgcmVhY3RfMS5mb3J3YXJkUmVmKShmdW5jdGlvbiAoX2EsIGV4dGVybmFsUmVmKSB7XG4gICAgdmFyIGlzT3BlbiA9IF9hLmlzT3BlbiwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgY29udGVudCA9IF9hLmNvbnRlbnQsIF9iID0gX2EucG9zaXRpb25zLCBleHRlcm5hbFBvc2l0aW9ucyA9IF9iID09PSB2b2lkIDAgPyBERUZBVUxUX1BPU0lUSU9OUyA6IF9iLCBfYyA9IF9hLmFsaWduLCBhbGlnbiA9IF9jID09PSB2b2lkIDAgPyAnY2VudGVyJyA6IF9jLCBfZCA9IF9hLnBhZGRpbmcsIHBhZGRpbmcgPSBfZCA9PT0gdm9pZCAwID8gMCA6IF9kLCBfZSA9IF9hLnJlcG9zaXRpb24sIHJlcG9zaXRpb24gPSBfZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9lLCBfZiA9IF9hLnBhcmVudEVsZW1lbnQsIHBhcmVudEVsZW1lbnQgPSBfZiA9PT0gdm9pZCAwID8gd2luZG93LmRvY3VtZW50LmJvZHkgOiBfZiwgX2cgPSBfYS5ib3VuZGFyeUVsZW1lbnQsIGJvdW5kYXJ5RWxlbWVudCA9IF9nID09PSB2b2lkIDAgPyBwYXJlbnRFbGVtZW50IDogX2csIGNvbnRhaW5lckNsYXNzTmFtZSA9IF9hLmNvbnRhaW5lckNsYXNzTmFtZSwgY29udGFpbmVyU3R5bGUgPSBfYS5jb250YWluZXJTdHlsZSwgdHJhbnNmb3JtID0gX2EudHJhbnNmb3JtLCBfaCA9IF9hLnRyYW5zZm9ybU1vZGUsIHRyYW5zZm9ybU1vZGUgPSBfaCA9PT0gdm9pZCAwID8gJ2Fic29sdXRlJyA6IF9oLCBfaiA9IF9hLmJvdW5kYXJ5SW5zZXQsIGJvdW5kYXJ5SW5zZXQgPSBfaiA9PT0gdm9pZCAwID8gMCA6IF9qLCBvbkNsaWNrT3V0c2lkZSA9IF9hLm9uQ2xpY2tPdXRzaWRlLCBfayA9IF9hLmNsaWNrT3V0c2lkZUNhcHR1cmUsIGNsaWNrT3V0c2lkZUNhcHR1cmUgPSBfayA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaztcbiAgICB2YXIgcG9zaXRpb25zID0gKDAsIHVzZU1lbW9pemVkQXJyYXlfMS51c2VNZW1vaXplZEFycmF5KShBcnJheS5pc0FycmF5KGV4dGVybmFsUG9zaXRpb25zKSA/IGV4dGVybmFsUG9zaXRpb25zIDogW2V4dGVybmFsUG9zaXRpb25zXSk7XG4gICAgdmFyIF9sID0gKDAsIHVzZUhhbmRsZVByZXZWYWx1ZXNfMS51c2VIYW5kbGVQcmV2VmFsdWVzKSh7XG4gICAgICAgIHBvc2l0aW9uczogcG9zaXRpb25zLFxuICAgICAgICByZXBvc2l0aW9uOiByZXBvc2l0aW9uLFxuICAgICAgICB0cmFuc2Zvcm1Nb2RlOiB0cmFuc2Zvcm1Nb2RlLFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgICAgYm91bmRhcnlFbGVtZW50OiBib3VuZGFyeUVsZW1lbnQsXG4gICAgICAgIGJvdW5kYXJ5SW5zZXQ6IGJvdW5kYXJ5SW5zZXQsXG4gICAgfSksIHByZXYgPSBfbC5wcmV2LCB1cGRhdGVQcmV2VmFsdWVzID0gX2wudXBkYXRlUHJldlZhbHVlcztcbiAgICB2YXIgY2hpbGRSZWYgPSAoMCwgcmVhY3RfMS51c2VSZWYpKCk7XG4gICAgdmFyIF9tID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKHtcbiAgICAgICAgYWxpZ246IGFsaWduLFxuICAgICAgICBudWRnZWRMZWZ0OiAwLFxuICAgICAgICBudWRnZWRUb3A6IDAsXG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbnNbMF0sXG4gICAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICAgIGNoaWxkUmVjdDogdXRpbF8xLkVNUFRZX1JFQ1QsXG4gICAgICAgIHBvcG92ZXJSZWN0OiB1dGlsXzEuRU1QVFlfUkVDVCxcbiAgICAgICAgcGFyZW50UmVjdDogdXRpbF8xLkVNUFRZX1JFQ1QsXG4gICAgICAgIGJvdW5kYXJ5UmVjdDogdXRpbF8xLkVNUFRZX1JFQ1QsXG4gICAgICAgIGJvdW5kYXJ5SW5zZXQ6IGJvdW5kYXJ5SW5zZXQsXG4gICAgICAgIHZpb2xhdGlvbnM6IHV0aWxfMS5FTVBUWV9SRUNULFxuICAgICAgICBoYXNWaW9sYXRpb25zOiBmYWxzZSxcbiAgICB9KSwgcG9wb3ZlclN0YXRlID0gX21bMF0sIHNldFBvcG92ZXJTdGF0ZSA9IF9tWzFdO1xuICAgIHZhciBvblBvc2l0aW9uUG9wb3ZlciA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKShmdW5jdGlvbiAocG9wb3ZlclN0YXRlKSB7IHJldHVybiBzZXRQb3BvdmVyU3RhdGUocG9wb3ZlclN0YXRlKTsgfSwgW10pO1xuICAgIHZhciBfbyA9ICgwLCB1c2VQb3BvdmVyXzEudXNlUG9wb3Zlcikoe1xuICAgICAgICBpc09wZW46IGlzT3BlbixcbiAgICAgICAgY2hpbGRSZWY6IGNoaWxkUmVmLFxuICAgICAgICBjb250YWluZXJDbGFzc05hbWU6IGNvbnRhaW5lckNsYXNzTmFtZSxcbiAgICAgICAgcGFyZW50RWxlbWVudDogcGFyZW50RWxlbWVudCxcbiAgICAgICAgYm91bmRhcnlFbGVtZW50OiBib3VuZGFyeUVsZW1lbnQsXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICB0cmFuc2Zvcm1Nb2RlOiB0cmFuc2Zvcm1Nb2RlLFxuICAgICAgICBwb3NpdGlvbnM6IHBvc2l0aW9ucyxcbiAgICAgICAgYWxpZ246IGFsaWduLFxuICAgICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgICBib3VuZGFyeUluc2V0OiBib3VuZGFyeUluc2V0LFxuICAgICAgICByZXBvc2l0aW9uOiByZXBvc2l0aW9uLFxuICAgICAgICBvblBvc2l0aW9uUG9wb3Zlcjogb25Qb3NpdGlvblBvcG92ZXIsXG4gICAgfSksIHBvc2l0aW9uUG9wb3ZlciA9IF9vLnBvc2l0aW9uUG9wb3ZlciwgcG9wb3ZlclJlZiA9IF9vLnBvcG92ZXJSZWYsIHNjb3V0UmVmID0gX28uc2NvdXRSZWY7XG4gICAgKDAsIHJlYWN0XzEudXNlTGF5b3V0RWZmZWN0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgICAgICB2YXIgdXBkYXRlUG9wb3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoaXNPcGVuICYmIHNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZFJlY3QgPSAoX2EgPSBjaGlsZFJlZiA9PT0gbnVsbCB8fCBjaGlsZFJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hpbGRSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciBwb3BvdmVyUmVjdCA9IChfYiA9IHBvcG92ZXJSZWYgPT09IG51bGwgfHwgcG9wb3ZlclJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9wb3ZlclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkUmVjdCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIHBvcG92ZXJSZWN0ICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgKCEoMCwgdXRpbF8xLnJlY3RzQXJlRXF1YWwpKGNoaWxkUmVjdCwgcG9wb3ZlclN0YXRlLmNoaWxkUmVjdCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcG92ZXJSZWN0LndpZHRoICE9PSBwb3BvdmVyU3RhdGUucG9wb3ZlclJlY3Qud2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcG92ZXJSZWN0LmhlaWdodCAhPT0gcG9wb3ZlclN0YXRlLnBvcG92ZXJSZWN0LmhlaWdodCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9wb3ZlclN0YXRlLnBhZGRpbmcgIT09IHBhZGRpbmcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcG92ZXJTdGF0ZS5hbGlnbiAhPT0gYWxpZ24gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9ucyAhPT0gcHJldi5wb3NpdGlvbnMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9zaXRpb24gIT09IHByZXYucmVwb3NpdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtTW9kZSAhPT0gcHJldi50cmFuc2Zvcm1Nb2RlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gIT09IHByZXYudHJhbnNmb3JtIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeUVsZW1lbnQgIT09IHByZXYuYm91bmRhcnlFbGVtZW50IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZGFyeUluc2V0ICE9PSBwcmV2LmJvdW5kYXJ5SW5zZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uUG9wb3ZlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGVQcmV2VmFsdWVzKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZVBvcG92ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdXBkYXRlUG9wb3ZlcigpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2hvdWxkVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBhbGlnbixcbiAgICAgICAgYm91bmRhcnlFbGVtZW50LFxuICAgICAgICBib3VuZGFyeUluc2V0LFxuICAgICAgICBpc09wZW4sXG4gICAgICAgIHBhZGRpbmcsXG4gICAgICAgIHBvcG92ZXJSZWYsXG4gICAgICAgIHBvcG92ZXJTdGF0ZS5hbGlnbixcbiAgICAgICAgcG9wb3ZlclN0YXRlLmNoaWxkUmVjdCxcbiAgICAgICAgcG9wb3ZlclN0YXRlLnBhZGRpbmcsXG4gICAgICAgIHBvcG92ZXJTdGF0ZS5wb3BvdmVyUmVjdC5oZWlnaHQsXG4gICAgICAgIHBvcG92ZXJTdGF0ZS5wb3BvdmVyUmVjdC53aWR0aCxcbiAgICAgICAgcG9zaXRpb25Qb3BvdmVyLFxuICAgICAgICBwb3NpdGlvbnMsXG4gICAgICAgIHByZXYuYm91bmRhcnlFbGVtZW50LFxuICAgICAgICBwcmV2LmJvdW5kYXJ5SW5zZXQsXG4gICAgICAgIHByZXYucG9zaXRpb25zLFxuICAgICAgICBwcmV2LnJlcG9zaXRpb24sXG4gICAgICAgIHByZXYudHJhbnNmb3JtLFxuICAgICAgICBwcmV2LnRyYW5zZm9ybU1vZGUsXG4gICAgICAgIHJlcG9zaXRpb24sXG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgdHJhbnNmb3JtTW9kZSxcbiAgICAgICAgdXBkYXRlUHJldlZhbHVlcyxcbiAgICBdKTtcbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBvcG92ZXJFbGVtZW50ID0gcG9wb3ZlclJlZi5jdXJyZW50O1xuICAgICAgICBPYmplY3QuYXNzaWduKHBvcG92ZXJFbGVtZW50LnN0eWxlLCBjb250YWluZXJTdHlsZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjb250YWluZXJTdHlsZSAhPT0gbnVsbCAmJiBjb250YWluZXJTdHlsZSAhPT0gdm9pZCAwID8gY29udGFpbmVyU3R5bGUgOiB7fSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSBwb3BvdmVyRWxlbWVudC5zdHlsZVtrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfSwgW2NvbnRhaW5lclN0eWxlLCBpc09wZW4sIHBvcG92ZXJSZWZdKTtcbiAgICB2YXIgaGFuZGxlT25DbGlja091dHNpZGUgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKGlzT3BlbiAmJlxuICAgICAgICAgICAgISgoX2EgPSBwb3BvdmVyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyhlLnRhcmdldCkpICYmXG4gICAgICAgICAgICAhKChfYiA9IGNoaWxkUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250YWlucyhlLnRhcmdldCkpKSB7XG4gICAgICAgICAgICBvbkNsaWNrT3V0c2lkZSA9PT0gbnVsbCB8fCBvbkNsaWNrT3V0c2lkZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DbGlja091dHNpZGUoZSk7XG4gICAgICAgIH1cbiAgICB9LCBbaXNPcGVuLCBvbkNsaWNrT3V0c2lkZSwgcG9wb3ZlclJlZl0pO1xuICAgIHZhciBoYW5kbGVXaW5kb3dSZXNpemUgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY2hpbGRSZWYuY3VycmVudCAmJiBpc09wZW4pIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkgeyByZXR1cm4gcG9zaXRpb25Qb3BvdmVyKCk7IH0pO1xuICAgICAgICB9XG4gICAgfSwgW3Bvc2l0aW9uUG9wb3ZlciwgaXNPcGVuXSk7XG4gICAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBib2R5ID0gcGFyZW50RWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVPbkNsaWNrT3V0c2lkZSwgY2xpY2tPdXRzaWRlQ2FwdHVyZSk7XG4gICAgICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBoYW5kbGVPbkNsaWNrT3V0c2lkZSwgY2xpY2tPdXRzaWRlQ2FwdHVyZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVXaW5kb3dSZXNpemUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZU9uQ2xpY2tPdXRzaWRlLCBjbGlja091dHNpZGVDYXB0dXJlKTtcbiAgICAgICAgICAgIGJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBoYW5kbGVPbkNsaWNrT3V0c2lkZSwgY2xpY2tPdXRzaWRlQ2FwdHVyZSk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlV2luZG93UmVzaXplKTtcbiAgICAgICAgfTtcbiAgICB9LCBbY2xpY2tPdXRzaWRlQ2FwdHVyZSwgaGFuZGxlT25DbGlja091dHNpZGUsIGhhbmRsZVdpbmRvd1Jlc2l6ZSwgcGFyZW50RWxlbWVudF0pO1xuICAgIHZhciBoYW5kbGVSZWYgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgY2hpbGRSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgIGlmIChleHRlcm5hbFJlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dGVybmFsUmVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGV4dGVybmFsUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGV4dGVybmFsUmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxSZWYobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbZXh0ZXJuYWxSZWZdKTtcbiAgICB2YXIgcmVuZGVyQ2hpbGQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoMCwgcmVhY3RfMS5jbG9uZUVsZW1lbnQpKGNoaWxkcmVuLCB7IHJlZjogaGFuZGxlUmVmIH0pOyB9O1xuICAgIHZhciByZW5kZXJQb3BvdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzT3BlbilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeCkoUG9wb3ZlclBvcnRhbF8xLlBvcG92ZXJQb3J0YWwsIHsgZWxlbWVudDogcG9wb3ZlclJlZi5jdXJyZW50LCBzY291dEVsZW1lbnQ6IHNjb3V0UmVmLmN1cnJlbnQsIGNvbnRhaW5lcjogcGFyZW50RWxlbWVudCwgY2hpbGRyZW46IHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nID8gY29udGVudChwb3BvdmVyU3RhdGUpIDogY29udGVudCB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKGpzeF9ydW50aW1lXzEuRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtyZW5kZXJDaGlsZCgpLCByZW5kZXJQb3BvdmVyKCldIH0pKTtcbn0pO1xuZXhwb3J0cy5Qb3BvdmVyID0gKDAsIHJlYWN0XzEuZm9yd2FyZFJlZikoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbiAgICByZXR1cm4gKDAsIGpzeF9ydW50aW1lXzEuanN4KShQb3BvdmVySW50ZXJuYWwsIF9fYXNzaWduKHt9LCBwcm9wcywgeyByZWY6IHJlZiB9KSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvcG92ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/react-tiny-popover/dist/Popover.js\n");

/***/ }),

/***/ "../../node_modules/react-tiny-popover/dist/PopoverPortal.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/react-tiny-popover/dist/PopoverPortal.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PopoverPortal = void 0;\nvar react_1 = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\nvar react_dom_1 = __webpack_require__(/*! react-dom */ \"webpack/sharing/consume/default/react-dom/react-dom\");\nvar PopoverPortal = function (_a) {\n    var container = _a.container, element = _a.element, scoutElement = _a.scoutElement, children = _a.children;\n    (0, react_1.useLayoutEffect)(function () {\n        container.appendChild(element);\n        container.appendChild(scoutElement);\n        return function () {\n            container.removeChild(element);\n            container.removeChild(scoutElement);\n        };\n    }, [container, element, scoutElement]);\n    return (0, react_dom_1.createPortal)(children, element);\n};\nexports.PopoverPortal = PopoverPortal;\n//# sourceMappingURL=PopoverPortal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXRpbnktcG9wb3Zlci9kaXN0L1BvcG92ZXJQb3J0YWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC10aW55LXBvcG92ZXIvZGlzdC9Qb3BvdmVyUG9ydGFsLmpzPzQyN2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvcG92ZXJQb3J0YWwgPSB2b2lkIDA7XG52YXIgcmVhY3RfMSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciByZWFjdF9kb21fMSA9IHJlcXVpcmUoXCJyZWFjdC1kb21cIik7XG52YXIgUG9wb3ZlclBvcnRhbCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjb250YWluZXIgPSBfYS5jb250YWluZXIsIGVsZW1lbnQgPSBfYS5lbGVtZW50LCBzY291dEVsZW1lbnQgPSBfYS5zY291dEVsZW1lbnQsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XG4gICAgKDAsIHJlYWN0XzEudXNlTGF5b3V0RWZmZWN0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHNjb3V0RWxlbWVudCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoc2NvdXRFbGVtZW50KTtcbiAgICAgICAgfTtcbiAgICB9LCBbY29udGFpbmVyLCBlbGVtZW50LCBzY291dEVsZW1lbnRdKTtcbiAgICByZXR1cm4gKDAsIHJlYWN0X2RvbV8xLmNyZWF0ZVBvcnRhbCkoY2hpbGRyZW4sIGVsZW1lbnQpO1xufTtcbmV4cG9ydHMuUG9wb3ZlclBvcnRhbCA9IFBvcG92ZXJQb3J0YWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb3BvdmVyUG9ydGFsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/react-tiny-popover/dist/PopoverPortal.js\n");

/***/ }),

/***/ "../../node_modules/react-tiny-popover/dist/useArrowContainer.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/react-tiny-popover/dist/useArrowContainer.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.useArrowContainer = void 0;\nvar react_1 = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\nvar useArrowContainer = function (_a) {\n    var childRect = _a.childRect, popoverRect = _a.popoverRect, position = _a.position, arrowSize = _a.arrowSize, arrowColor = _a.arrowColor;\n    var arrowContainerStyle = (0, react_1.useMemo)(function () {\n        return ({\n            padding: arrowSize,\n        });\n    }, [arrowSize]);\n    var arrowStyle = (0, react_1.useMemo)(function () {\n        return (__assign({ position: 'absolute' }, (function () {\n            var arrowWidth = arrowSize * 2;\n            var top = childRect.top - popoverRect.top + childRect.height / 2 - arrowWidth / 2;\n            var left = childRect.left - popoverRect.left + childRect.width / 2 - arrowWidth / 2;\n            var lowerBound = arrowSize;\n            var leftUpperBound = popoverRect.width - arrowSize;\n            var topUpperBound = popoverRect.height - arrowSize;\n            left = left < lowerBound ? lowerBound : left;\n            left = left + arrowWidth > leftUpperBound ? leftUpperBound - arrowWidth : left;\n            top = top < lowerBound ? lowerBound : top;\n            top = top + arrowWidth > topUpperBound ? topUpperBound - arrowWidth : top;\n            top = Number.isNaN(top) ? 0 : top;\n            left = Number.isNaN(left) ? 0 : left;\n            switch (position) {\n                case 'right':\n                    return {\n                        borderTop: \"\".concat(arrowSize, \"px solid transparent\"),\n                        borderBottom: \"\".concat(arrowSize, \"px solid transparent\"),\n                        borderRight: \"\".concat(arrowSize, \"px solid \").concat(arrowColor),\n                        left: 0,\n                        top: top,\n                    };\n                case 'left':\n                    return {\n                        borderTop: \"\".concat(arrowSize, \"px solid transparent\"),\n                        borderBottom: \"\".concat(arrowSize, \"px solid transparent\"),\n                        borderLeft: \"\".concat(arrowSize, \"px solid \").concat(arrowColor),\n                        right: 0,\n                        top: top,\n                    };\n                case 'bottom':\n                    return {\n                        borderLeft: \"\".concat(arrowSize, \"px solid transparent\"),\n                        borderRight: \"\".concat(arrowSize, \"px solid transparent\"),\n                        borderBottom: \"\".concat(arrowSize, \"px solid \").concat(arrowColor),\n                        top: 0,\n                        left: left,\n                    };\n                case 'top':\n                    return {\n                        borderLeft: \"\".concat(arrowSize, \"px solid transparent\"),\n                        borderRight: \"\".concat(arrowSize, \"px solid transparent\"),\n                        borderTop: \"\".concat(arrowSize, \"px solid \").concat(arrowColor),\n                        bottom: 0,\n                        left: left,\n                    };\n                default:\n                    return {\n                        display: 'hidden',\n                    };\n            }\n        })()));\n    }, [\n        arrowColor,\n        arrowSize,\n        childRect.height,\n        childRect.left,\n        childRect.top,\n        childRect.width,\n        popoverRect.height,\n        popoverRect.left,\n        popoverRect.top,\n        popoverRect.width,\n        position,\n    ]);\n    return {\n        arrowContainerStyle: arrowContainerStyle,\n        arrowStyle: arrowStyle,\n    };\n};\nexports.useArrowContainer = useArrowContainer;\n//# sourceMappingURL=useArrowContainer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXRpbnktcG9wb3Zlci9kaXN0L3VzZUFycm93Q29udGFpbmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC10aW55LXBvcG92ZXIvZGlzdC91c2VBcnJvd0NvbnRhaW5lci5qcz9kMGYwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXNlQXJyb3dDb250YWluZXIgPSB2b2lkIDA7XG52YXIgcmVhY3RfMSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciB1c2VBcnJvd0NvbnRhaW5lciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjaGlsZFJlY3QgPSBfYS5jaGlsZFJlY3QsIHBvcG92ZXJSZWN0ID0gX2EucG9wb3ZlclJlY3QsIHBvc2l0aW9uID0gX2EucG9zaXRpb24sIGFycm93U2l6ZSA9IF9hLmFycm93U2l6ZSwgYXJyb3dDb2xvciA9IF9hLmFycm93Q29sb3I7XG4gICAgdmFyIGFycm93Q29udGFpbmVyU3R5bGUgPSAoMCwgcmVhY3RfMS51c2VNZW1vKShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgcGFkZGluZzogYXJyb3dTaXplLFxuICAgICAgICB9KTtcbiAgICB9LCBbYXJyb3dTaXplXSk7XG4gICAgdmFyIGFycm93U3R5bGUgPSAoMCwgcmVhY3RfMS51c2VNZW1vKShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX19hc3NpZ24oeyBwb3NpdGlvbjogJ2Fic29sdXRlJyB9LCAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFycm93V2lkdGggPSBhcnJvd1NpemUgKiAyO1xuICAgICAgICAgICAgdmFyIHRvcCA9IGNoaWxkUmVjdC50b3AgLSBwb3BvdmVyUmVjdC50b3AgKyBjaGlsZFJlY3QuaGVpZ2h0IC8gMiAtIGFycm93V2lkdGggLyAyO1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBjaGlsZFJlY3QubGVmdCAtIHBvcG92ZXJSZWN0LmxlZnQgKyBjaGlsZFJlY3Qud2lkdGggLyAyIC0gYXJyb3dXaWR0aCAvIDI7XG4gICAgICAgICAgICB2YXIgbG93ZXJCb3VuZCA9IGFycm93U2l6ZTtcbiAgICAgICAgICAgIHZhciBsZWZ0VXBwZXJCb3VuZCA9IHBvcG92ZXJSZWN0LndpZHRoIC0gYXJyb3dTaXplO1xuICAgICAgICAgICAgdmFyIHRvcFVwcGVyQm91bmQgPSBwb3BvdmVyUmVjdC5oZWlnaHQgLSBhcnJvd1NpemU7XG4gICAgICAgICAgICBsZWZ0ID0gbGVmdCA8IGxvd2VyQm91bmQgPyBsb3dlckJvdW5kIDogbGVmdDtcbiAgICAgICAgICAgIGxlZnQgPSBsZWZ0ICsgYXJyb3dXaWR0aCA+IGxlZnRVcHBlckJvdW5kID8gbGVmdFVwcGVyQm91bmQgLSBhcnJvd1dpZHRoIDogbGVmdDtcbiAgICAgICAgICAgIHRvcCA9IHRvcCA8IGxvd2VyQm91bmQgPyBsb3dlckJvdW5kIDogdG9wO1xuICAgICAgICAgICAgdG9wID0gdG9wICsgYXJyb3dXaWR0aCA+IHRvcFVwcGVyQm91bmQgPyB0b3BVcHBlckJvdW5kIC0gYXJyb3dXaWR0aCA6IHRvcDtcbiAgICAgICAgICAgIHRvcCA9IE51bWJlci5pc05hTih0b3ApID8gMCA6IHRvcDtcbiAgICAgICAgICAgIGxlZnQgPSBOdW1iZXIuaXNOYU4obGVmdCkgPyAwIDogbGVmdDtcbiAgICAgICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJUb3A6IFwiXCIuY29uY2F0KGFycm93U2l6ZSwgXCJweCBzb2xpZCB0cmFuc3BhcmVudFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogXCJcIi5jb25jYXQoYXJyb3dTaXplLCBcInB4IHNvbGlkIHRyYW5zcGFyZW50XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmlnaHQ6IFwiXCIuY29uY2F0KGFycm93U2l6ZSwgXCJweCBzb2xpZCBcIikuY29uY2F0KGFycm93Q29sb3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyVG9wOiBcIlwiLmNvbmNhdChhcnJvd1NpemUsIFwicHggc29saWQgdHJhbnNwYXJlbnRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IFwiXCIuY29uY2F0KGFycm93U2l6ZSwgXCJweCBzb2xpZCB0cmFuc3BhcmVudFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckxlZnQ6IFwiXCIuY29uY2F0KGFycm93U2l6ZSwgXCJweCBzb2xpZCBcIikuY29uY2F0KGFycm93Q29sb3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyTGVmdDogXCJcIi5jb25jYXQoYXJyb3dTaXplLCBcInB4IHNvbGlkIHRyYW5zcGFyZW50XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmlnaHQ6IFwiXCIuY29uY2F0KGFycm93U2l6ZSwgXCJweCBzb2xpZCB0cmFuc3BhcmVudFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogXCJcIi5jb25jYXQoYXJyb3dTaXplLCBcInB4IHNvbGlkIFwiKS5jb25jYXQoYXJyb3dDb2xvciksXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJMZWZ0OiBcIlwiLmNvbmNhdChhcnJvd1NpemUsIFwicHggc29saWQgdHJhbnNwYXJlbnRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSaWdodDogXCJcIi5jb25jYXQoYXJyb3dTaXplLCBcInB4IHNvbGlkIHRyYW5zcGFyZW50XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyVG9wOiBcIlwiLmNvbmNhdChhcnJvd1NpemUsIFwicHggc29saWQgXCIpLmNvbmNhdChhcnJvd0NvbG9yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpKSk7XG4gICAgfSwgW1xuICAgICAgICBhcnJvd0NvbG9yLFxuICAgICAgICBhcnJvd1NpemUsXG4gICAgICAgIGNoaWxkUmVjdC5oZWlnaHQsXG4gICAgICAgIGNoaWxkUmVjdC5sZWZ0LFxuICAgICAgICBjaGlsZFJlY3QudG9wLFxuICAgICAgICBjaGlsZFJlY3Qud2lkdGgsXG4gICAgICAgIHBvcG92ZXJSZWN0LmhlaWdodCxcbiAgICAgICAgcG9wb3ZlclJlY3QubGVmdCxcbiAgICAgICAgcG9wb3ZlclJlY3QudG9wLFxuICAgICAgICBwb3BvdmVyUmVjdC53aWR0aCxcbiAgICAgICAgcG9zaXRpb24sXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXJyb3dDb250YWluZXJTdHlsZTogYXJyb3dDb250YWluZXJTdHlsZSxcbiAgICAgICAgYXJyb3dTdHlsZTogYXJyb3dTdHlsZSxcbiAgICB9O1xufTtcbmV4cG9ydHMudXNlQXJyb3dDb250YWluZXIgPSB1c2VBcnJvd0NvbnRhaW5lcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZUFycm93Q29udGFpbmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/react-tiny-popover/dist/useArrowContainer.js\n");

/***/ }),

/***/ "../../node_modules/react-tiny-popover/dist/useElementRef.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/react-tiny-popover/dist/useElementRef.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.useElementRef = void 0;\nvar react_1 = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\nvar util_1 = __webpack_require__(/*! ./util */ \"../../node_modules/react-tiny-popover/dist/util.js\");\nvar useElementRef = function (_a) {\n    var containerClassName = _a.containerClassName, containerStyle = _a.containerStyle;\n    var ref = (0, react_1.useRef)();\n    var element = (0, react_1.useState)(function () {\n        return (0, util_1.createContainer)({ containerStyle: containerStyle, containerClassName: containerClassName });\n    })[0];\n    (0, react_1.useLayoutEffect)(function () {\n        element.className = containerClassName;\n    }, [containerClassName, element]);\n    (0, react_1.useLayoutEffect)(function () {\n        Object.assign(element.style, containerStyle);\n    }, [containerStyle, element]);\n    ref.current = element;\n    return ref;\n};\nexports.useElementRef = useElementRef;\n//# sourceMappingURL=useElementRef.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXRpbnktcG9wb3Zlci9kaXN0L3VzZUVsZW1lbnRSZWYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC10aW55LXBvcG92ZXIvZGlzdC91c2VFbGVtZW50UmVmLmpzPzRmNzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVzZUVsZW1lbnRSZWYgPSB2b2lkIDA7XG52YXIgcmVhY3RfMSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIHVzZUVsZW1lbnRSZWYgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY29udGFpbmVyQ2xhc3NOYW1lID0gX2EuY29udGFpbmVyQ2xhc3NOYW1lLCBjb250YWluZXJTdHlsZSA9IF9hLmNvbnRhaW5lclN0eWxlO1xuICAgIHZhciByZWYgPSAoMCwgcmVhY3RfMS51c2VSZWYpKCk7XG4gICAgdmFyIGVsZW1lbnQgPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS5jcmVhdGVDb250YWluZXIpKHsgY29udGFpbmVyU3R5bGU6IGNvbnRhaW5lclN0eWxlLCBjb250YWluZXJDbGFzc05hbWU6IGNvbnRhaW5lckNsYXNzTmFtZSB9KTtcbiAgICB9KVswXTtcbiAgICAoMCwgcmVhY3RfMS51c2VMYXlvdXRFZmZlY3QpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjb250YWluZXJDbGFzc05hbWU7XG4gICAgfSwgW2NvbnRhaW5lckNsYXNzTmFtZSwgZWxlbWVudF0pO1xuICAgICgwLCByZWFjdF8xLnVzZUxheW91dEVmZmVjdCkoZnVuY3Rpb24gKCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIGNvbnRhaW5lclN0eWxlKTtcbiAgICB9LCBbY29udGFpbmVyU3R5bGUsIGVsZW1lbnRdKTtcbiAgICByZWYuY3VycmVudCA9IGVsZW1lbnQ7XG4gICAgcmV0dXJuIHJlZjtcbn07XG5leHBvcnRzLnVzZUVsZW1lbnRSZWYgPSB1c2VFbGVtZW50UmVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlRWxlbWVudFJlZi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/react-tiny-popover/dist/useElementRef.js\n");

/***/ }),

/***/ "../../node_modules/react-tiny-popover/dist/useHandlePrevValues.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/react-tiny-popover/dist/useHandlePrevValues.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.useHandlePrevValues = void 0;\nvar react_1 = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\nvar useHandlePrevValues = function (props) {\n    var prevPositions = (0, react_1.useRef)(props.positions);\n    var prevReposition = (0, react_1.useRef)(props.reposition);\n    var prevTransformMode = (0, react_1.useRef)(props.transformMode);\n    var prevTransform = (0, react_1.useRef)(props.transform);\n    var prevBoundaryElement = (0, react_1.useRef)(props.boundaryElement);\n    var prevBoundaryInset = (0, react_1.useRef)(props.boundaryInset);\n    var updatePrevValues = (0, react_1.useCallback)(function () {\n        prevPositions.current = props.positions;\n        prevReposition.current = props.reposition;\n        prevTransformMode.current = props.transformMode;\n        prevTransform.current = props.transform;\n        prevBoundaryElement.current = props.boundaryElement;\n        prevBoundaryInset.current = props.boundaryInset;\n    }, [\n        props.boundaryElement,\n        props.boundaryInset,\n        props.positions,\n        props.reposition,\n        props.transform,\n        props.transformMode,\n    ]);\n    return {\n        prev: {\n            positions: prevPositions.current,\n            reposition: prevReposition.current,\n            transformMode: prevTransformMode.current,\n            transform: prevTransform.current,\n            boundaryElement: prevBoundaryElement.current,\n            boundaryInset: prevBoundaryInset.current,\n        },\n        updatePrevValues: updatePrevValues,\n    };\n};\nexports.useHandlePrevValues = useHandlePrevValues;\n//# sourceMappingURL=useHandlePrevValues.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXRpbnktcG9wb3Zlci9kaXN0L3VzZUhhbmRsZVByZXZWYWx1ZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC10aW55LXBvcG92ZXIvZGlzdC91c2VIYW5kbGVQcmV2VmFsdWVzLmpzPzEyZDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVzZUhhbmRsZVByZXZWYWx1ZXMgPSB2b2lkIDA7XG52YXIgcmVhY3RfMSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciB1c2VIYW5kbGVQcmV2VmFsdWVzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIHByZXZQb3NpdGlvbnMgPSAoMCwgcmVhY3RfMS51c2VSZWYpKHByb3BzLnBvc2l0aW9ucyk7XG4gICAgdmFyIHByZXZSZXBvc2l0aW9uID0gKDAsIHJlYWN0XzEudXNlUmVmKShwcm9wcy5yZXBvc2l0aW9uKTtcbiAgICB2YXIgcHJldlRyYW5zZm9ybU1vZGUgPSAoMCwgcmVhY3RfMS51c2VSZWYpKHByb3BzLnRyYW5zZm9ybU1vZGUpO1xuICAgIHZhciBwcmV2VHJhbnNmb3JtID0gKDAsIHJlYWN0XzEudXNlUmVmKShwcm9wcy50cmFuc2Zvcm0pO1xuICAgIHZhciBwcmV2Qm91bmRhcnlFbGVtZW50ID0gKDAsIHJlYWN0XzEudXNlUmVmKShwcm9wcy5ib3VuZGFyeUVsZW1lbnQpO1xuICAgIHZhciBwcmV2Qm91bmRhcnlJbnNldCA9ICgwLCByZWFjdF8xLnVzZVJlZikocHJvcHMuYm91bmRhcnlJbnNldCk7XG4gICAgdmFyIHVwZGF0ZVByZXZWYWx1ZXMgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoZnVuY3Rpb24gKCkge1xuICAgICAgICBwcmV2UG9zaXRpb25zLmN1cnJlbnQgPSBwcm9wcy5wb3NpdGlvbnM7XG4gICAgICAgIHByZXZSZXBvc2l0aW9uLmN1cnJlbnQgPSBwcm9wcy5yZXBvc2l0aW9uO1xuICAgICAgICBwcmV2VHJhbnNmb3JtTW9kZS5jdXJyZW50ID0gcHJvcHMudHJhbnNmb3JtTW9kZTtcbiAgICAgICAgcHJldlRyYW5zZm9ybS5jdXJyZW50ID0gcHJvcHMudHJhbnNmb3JtO1xuICAgICAgICBwcmV2Qm91bmRhcnlFbGVtZW50LmN1cnJlbnQgPSBwcm9wcy5ib3VuZGFyeUVsZW1lbnQ7XG4gICAgICAgIHByZXZCb3VuZGFyeUluc2V0LmN1cnJlbnQgPSBwcm9wcy5ib3VuZGFyeUluc2V0O1xuICAgIH0sIFtcbiAgICAgICAgcHJvcHMuYm91bmRhcnlFbGVtZW50LFxuICAgICAgICBwcm9wcy5ib3VuZGFyeUluc2V0LFxuICAgICAgICBwcm9wcy5wb3NpdGlvbnMsXG4gICAgICAgIHByb3BzLnJlcG9zaXRpb24sXG4gICAgICAgIHByb3BzLnRyYW5zZm9ybSxcbiAgICAgICAgcHJvcHMudHJhbnNmb3JtTW9kZSxcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmV2OiB7XG4gICAgICAgICAgICBwb3NpdGlvbnM6IHByZXZQb3NpdGlvbnMuY3VycmVudCxcbiAgICAgICAgICAgIHJlcG9zaXRpb246IHByZXZSZXBvc2l0aW9uLmN1cnJlbnQsXG4gICAgICAgICAgICB0cmFuc2Zvcm1Nb2RlOiBwcmV2VHJhbnNmb3JtTW9kZS5jdXJyZW50LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBwcmV2VHJhbnNmb3JtLmN1cnJlbnQsXG4gICAgICAgICAgICBib3VuZGFyeUVsZW1lbnQ6IHByZXZCb3VuZGFyeUVsZW1lbnQuY3VycmVudCxcbiAgICAgICAgICAgIGJvdW5kYXJ5SW5zZXQ6IHByZXZCb3VuZGFyeUluc2V0LmN1cnJlbnQsXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVByZXZWYWx1ZXM6IHVwZGF0ZVByZXZWYWx1ZXMsXG4gICAgfTtcbn07XG5leHBvcnRzLnVzZUhhbmRsZVByZXZWYWx1ZXMgPSB1c2VIYW5kbGVQcmV2VmFsdWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlSGFuZGxlUHJldlZhbHVlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/react-tiny-popover/dist/useHandlePrevValues.js\n");

/***/ }),

/***/ "../../node_modules/react-tiny-popover/dist/useMemoizedArray.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/react-tiny-popover/dist/useMemoizedArray.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.useMemoizedArray = void 0;\nvar react_1 = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\nvar useMemoizedArray = function (externalArray) {\n    var prevArrayRef = (0, react_1.useRef)(externalArray);\n    var array = (0, react_1.useMemo)(function () {\n        if (prevArrayRef.current === externalArray)\n            return prevArrayRef.current;\n        if (prevArrayRef.current.length !== externalArray.length) {\n            prevArrayRef.current = externalArray;\n            return externalArray;\n        }\n        for (var i = 0; i < externalArray.length; i += 1) {\n            if (externalArray[i] !== prevArrayRef.current[i]) {\n                prevArrayRef.current = externalArray;\n                return externalArray;\n            }\n        }\n        return prevArrayRef.current;\n    }, [externalArray]);\n    return array;\n};\nexports.useMemoizedArray = useMemoizedArray;\n//# sourceMappingURL=useMemoizedArray.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXRpbnktcG9wb3Zlci9kaXN0L3VzZU1lbW9pemVkQXJyYXkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC10aW55LXBvcG92ZXIvZGlzdC91c2VNZW1vaXplZEFycmF5LmpzPzBiNjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVzZU1lbW9pemVkQXJyYXkgPSB2b2lkIDA7XG52YXIgcmVhY3RfMSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciB1c2VNZW1vaXplZEFycmF5ID0gZnVuY3Rpb24gKGV4dGVybmFsQXJyYXkpIHtcbiAgICB2YXIgcHJldkFycmF5UmVmID0gKDAsIHJlYWN0XzEudXNlUmVmKShleHRlcm5hbEFycmF5KTtcbiAgICB2YXIgYXJyYXkgPSAoMCwgcmVhY3RfMS51c2VNZW1vKShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwcmV2QXJyYXlSZWYuY3VycmVudCA9PT0gZXh0ZXJuYWxBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBwcmV2QXJyYXlSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKHByZXZBcnJheVJlZi5jdXJyZW50Lmxlbmd0aCAhPT0gZXh0ZXJuYWxBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHByZXZBcnJheVJlZi5jdXJyZW50ID0gZXh0ZXJuYWxBcnJheTtcbiAgICAgICAgICAgIHJldHVybiBleHRlcm5hbEFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXh0ZXJuYWxBcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGV4dGVybmFsQXJyYXlbaV0gIT09IHByZXZBcnJheVJlZi5jdXJyZW50W2ldKSB7XG4gICAgICAgICAgICAgICAgcHJldkFycmF5UmVmLmN1cnJlbnQgPSBleHRlcm5hbEFycmF5O1xuICAgICAgICAgICAgICAgIHJldHVybiBleHRlcm5hbEFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2QXJyYXlSZWYuY3VycmVudDtcbiAgICB9LCBbZXh0ZXJuYWxBcnJheV0pO1xuICAgIHJldHVybiBhcnJheTtcbn07XG5leHBvcnRzLnVzZU1lbW9pemVkQXJyYXkgPSB1c2VNZW1vaXplZEFycmF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlTWVtb2l6ZWRBcnJheS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/react-tiny-popover/dist/useMemoizedArray.js\n");

/***/ }),

/***/ "../../node_modules/react-tiny-popover/dist/usePopover.js":
/*!****************************************************************!*\
  !*** ../../node_modules/react-tiny-popover/dist/usePopover.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.usePopover = void 0;\nvar react_1 = __webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react\");\nvar util_1 = __webpack_require__(/*! ./util */ \"../../node_modules/react-tiny-popover/dist/util.js\");\nvar useElementRef_1 = __webpack_require__(/*! ./useElementRef */ \"../../node_modules/react-tiny-popover/dist/useElementRef.js\");\nvar POPOVER_STYLE = {\n    position: 'fixed',\n    overflow: 'visible',\n    top: '0px',\n    left: '0px',\n};\nvar SCOUT_STYLE = {\n    position: 'fixed',\n    top: '0px',\n    left: '0px',\n    width: '0px',\n    height: '0px',\n    visibility: 'hidden',\n};\nvar usePopover = function (_a) {\n    var isOpen = _a.isOpen, childRef = _a.childRef, positions = _a.positions, containerClassName = _a.containerClassName, parentElement = _a.parentElement, transform = _a.transform, transformMode = _a.transformMode, align = _a.align, padding = _a.padding, reposition = _a.reposition, boundaryInset = _a.boundaryInset, boundaryElement = _a.boundaryElement, onPositionPopover = _a.onPositionPopover;\n    var scoutRef = (0, useElementRef_1.useElementRef)({\n        containerClassName: 'react-tiny-popover-scout',\n        containerStyle: SCOUT_STYLE,\n    });\n    var popoverRef = (0, useElementRef_1.useElementRef)({\n        containerClassName: containerClassName != null &&\n            containerClassName.length > 0 &&\n            containerClassName !== 'react-tiny-popover-container'\n            ? \"react-tiny-popover-container \".concat(containerClassName)\n            : 'react-tiny-popover-container',\n        containerStyle: POPOVER_STYLE,\n    });\n    var positionPopover = (0, react_1.useCallback)(function (_a) {\n        var _b, _c;\n        var _d = _a === void 0 ? {} : _a, _e = _d.positionIndex, positionIndex = _e === void 0 ? 0 : _e, _f = _d.parentRect, parentRect = _f === void 0 ? parentElement.getBoundingClientRect() : _f, _g = _d.childRect, childRect = _g === void 0 ? (_b = childRef === null || childRef === void 0 ? void 0 : childRef.current) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect() : _g, _h = _d.scoutRect, scoutRect = _h === void 0 ? (_c = scoutRef === null || scoutRef === void 0 ? void 0 : scoutRef.current) === null || _c === void 0 ? void 0 : _c.getBoundingClientRect() : _h, _j = _d.popoverRect, popoverRect = _j === void 0 ? popoverRef.current.getBoundingClientRect() : _j, _k = _d.boundaryRect, boundaryRect = _k === void 0 ? boundaryElement === parentElement\n            ? parentRect\n            : boundaryElement.getBoundingClientRect() : _k;\n        if (!childRect || !parentRect || !isOpen) {\n            return;\n        }\n        if (transform && transformMode === 'absolute') {\n            var _l = typeof transform === 'function'\n                ? transform({\n                    childRect: childRect,\n                    popoverRect: popoverRect,\n                    parentRect: parentRect,\n                    boundaryRect: boundaryRect,\n                    padding: padding,\n                    align: align,\n                    nudgedTop: 0,\n                    nudgedLeft: 0,\n                    boundaryInset: boundaryInset,\n                    violations: util_1.EMPTY_RECT,\n                    hasViolations: false,\n                })\n                : transform, inputTop = _l.top, inputLeft = _l.left;\n            var finalLeft_1 = Math.round(parentRect.left + inputLeft - scoutRect.left);\n            var finalTop_1 = Math.round(parentRect.top + inputTop - scoutRect.top);\n            popoverRef.current.style.transform = \"translate(\".concat(finalLeft_1, \"px, \").concat(finalTop_1, \"px)\");\n            onPositionPopover({\n                childRect: childRect,\n                popoverRect: (0, util_1.createRect)({\n                    left: finalLeft_1,\n                    top: finalTop_1,\n                    width: popoverRect.width,\n                    height: popoverRect.height,\n                }),\n                parentRect: parentRect,\n                boundaryRect: boundaryRect,\n                padding: padding,\n                align: align,\n                transform: { top: inputTop, left: inputLeft },\n                nudgedTop: 0,\n                nudgedLeft: 0,\n                boundaryInset: boundaryInset,\n                violations: util_1.EMPTY_RECT,\n                hasViolations: false,\n            });\n            return;\n        }\n        var isExhausted = positionIndex === positions.length;\n        var position = isExhausted ? positions[0] : positions[positionIndex];\n        var _m = (0, util_1.getNewPopoverRect)({\n            childRect: childRect,\n            popoverRect: popoverRect,\n            boundaryRect: boundaryRect,\n            position: position,\n            align: align,\n            padding: padding,\n            reposition: reposition,\n        }, boundaryInset), rect = _m.rect, boundaryViolation = _m.boundaryViolation;\n        if (boundaryViolation && reposition && !isExhausted) {\n            positionPopover({\n                positionIndex: positionIndex + 1,\n                childRect: childRect,\n                popoverRect: popoverRect,\n                parentRect: parentRect,\n                boundaryRect: boundaryRect,\n            });\n            return;\n        }\n        var top = rect.top, left = rect.left, width = rect.width, height = rect.height;\n        var shouldNudge = reposition && !isExhausted;\n        var _o = (0, util_1.getNudgedPopoverRect)(rect, boundaryRect, boundaryInset), nudgedLeft = _o.left, nudgedTop = _o.top;\n        var finalTop = top;\n        var finalLeft = left;\n        if (shouldNudge) {\n            finalTop = nudgedTop;\n            finalLeft = nudgedLeft;\n        }\n        finalTop = Math.round(finalTop - scoutRect.top);\n        finalLeft = Math.round(finalLeft - scoutRect.left);\n        popoverRef.current.style.transform = \"translate(\".concat(finalLeft, \"px, \").concat(finalTop, \"px)\");\n        var potentialViolations = {\n            top: boundaryRect.top + boundaryInset - finalTop,\n            left: boundaryRect.left + boundaryInset - finalLeft,\n            right: finalLeft + width - boundaryRect.right + boundaryInset,\n            bottom: finalTop + height - boundaryRect.bottom + boundaryInset,\n        };\n        var popoverState = {\n            childRect: childRect,\n            popoverRect: (0, util_1.createRect)({ left: finalLeft, top: finalTop, width: width, height: height }),\n            parentRect: parentRect,\n            boundaryRect: boundaryRect,\n            position: position,\n            align: align,\n            padding: padding,\n            nudgedTop: nudgedTop - top,\n            nudgedLeft: nudgedLeft - left,\n            boundaryInset: boundaryInset,\n            violations: {\n                top: potentialViolations.top <= 0 ? 0 : potentialViolations.top,\n                left: potentialViolations.left <= 0 ? 0 : potentialViolations.left,\n                right: potentialViolations.right <= 0 ? 0 : potentialViolations.right,\n                bottom: potentialViolations.bottom <= 0 ? 0 : potentialViolations.bottom,\n            },\n            hasViolations: potentialViolations.top > 0 ||\n                potentialViolations.left > 0 ||\n                potentialViolations.right > 0 ||\n                potentialViolations.bottom > 0,\n        };\n        if (transform) {\n            onPositionPopover(popoverState);\n            var _p = typeof transform === 'function' ? transform(popoverState) : transform, transformTop = _p.top, transformLeft = _p.left;\n            popoverRef.current.style.transform = \"translate(\".concat(Math.round(finalLeft + (transformLeft !== null && transformLeft !== void 0 ? transformLeft : 0)), \"px, \").concat(Math.round(finalTop + (transformTop !== null && transformTop !== void 0 ? transformTop : 0)), \"px)\");\n            popoverState.nudgedLeft += transformLeft !== null && transformLeft !== void 0 ? transformLeft : 0;\n            popoverState.nudgedTop += transformTop !== null && transformTop !== void 0 ? transformTop : 0;\n            popoverState.transform = { top: transformTop, left: transformLeft };\n        }\n        onPositionPopover(popoverState);\n    }, [\n        parentElement,\n        childRef,\n        scoutRef,\n        popoverRef,\n        boundaryElement,\n        isOpen,\n        transform,\n        transformMode,\n        positions,\n        align,\n        padding,\n        reposition,\n        boundaryInset,\n        onPositionPopover,\n    ]);\n    return { positionPopover: positionPopover, popoverRef: popoverRef, scoutRef: scoutRef };\n};\nexports.usePopover = usePopover;\n//# sourceMappingURL=usePopover.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXRpbnktcG9wb3Zlci9kaXN0L3VzZVBvcG92ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC10aW55LXBvcG92ZXIvZGlzdC91c2VQb3BvdmVyLmpzPzFmODQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVzZVBvcG92ZXIgPSB2b2lkIDA7XG52YXIgcmVhY3RfMSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIHVzZUVsZW1lbnRSZWZfMSA9IHJlcXVpcmUoXCIuL3VzZUVsZW1lbnRSZWZcIik7XG52YXIgUE9QT1ZFUl9TVFlMRSA9IHtcbiAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICBvdmVyZmxvdzogJ3Zpc2libGUnLFxuICAgIHRvcDogJzBweCcsXG4gICAgbGVmdDogJzBweCcsXG59O1xudmFyIFNDT1VUX1NUWUxFID0ge1xuICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgIHRvcDogJzBweCcsXG4gICAgbGVmdDogJzBweCcsXG4gICAgd2lkdGg6ICcwcHgnLFxuICAgIGhlaWdodDogJzBweCcsXG4gICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG59O1xudmFyIHVzZVBvcG92ZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgaXNPcGVuID0gX2EuaXNPcGVuLCBjaGlsZFJlZiA9IF9hLmNoaWxkUmVmLCBwb3NpdGlvbnMgPSBfYS5wb3NpdGlvbnMsIGNvbnRhaW5lckNsYXNzTmFtZSA9IF9hLmNvbnRhaW5lckNsYXNzTmFtZSwgcGFyZW50RWxlbWVudCA9IF9hLnBhcmVudEVsZW1lbnQsIHRyYW5zZm9ybSA9IF9hLnRyYW5zZm9ybSwgdHJhbnNmb3JtTW9kZSA9IF9hLnRyYW5zZm9ybU1vZGUsIGFsaWduID0gX2EuYWxpZ24sIHBhZGRpbmcgPSBfYS5wYWRkaW5nLCByZXBvc2l0aW9uID0gX2EucmVwb3NpdGlvbiwgYm91bmRhcnlJbnNldCA9IF9hLmJvdW5kYXJ5SW5zZXQsIGJvdW5kYXJ5RWxlbWVudCA9IF9hLmJvdW5kYXJ5RWxlbWVudCwgb25Qb3NpdGlvblBvcG92ZXIgPSBfYS5vblBvc2l0aW9uUG9wb3ZlcjtcbiAgICB2YXIgc2NvdXRSZWYgPSAoMCwgdXNlRWxlbWVudFJlZl8xLnVzZUVsZW1lbnRSZWYpKHtcbiAgICAgICAgY29udGFpbmVyQ2xhc3NOYW1lOiAncmVhY3QtdGlueS1wb3BvdmVyLXNjb3V0JyxcbiAgICAgICAgY29udGFpbmVyU3R5bGU6IFNDT1VUX1NUWUxFLFxuICAgIH0pO1xuICAgIHZhciBwb3BvdmVyUmVmID0gKDAsIHVzZUVsZW1lbnRSZWZfMS51c2VFbGVtZW50UmVmKSh7XG4gICAgICAgIGNvbnRhaW5lckNsYXNzTmFtZTogY29udGFpbmVyQ2xhc3NOYW1lICE9IG51bGwgJiZcbiAgICAgICAgICAgIGNvbnRhaW5lckNsYXNzTmFtZS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBjb250YWluZXJDbGFzc05hbWUgIT09ICdyZWFjdC10aW55LXBvcG92ZXItY29udGFpbmVyJ1xuICAgICAgICAgICAgPyBcInJlYWN0LXRpbnktcG9wb3Zlci1jb250YWluZXIgXCIuY29uY2F0KGNvbnRhaW5lckNsYXNzTmFtZSlcbiAgICAgICAgICAgIDogJ3JlYWN0LXRpbnktcG9wb3Zlci1jb250YWluZXInLFxuICAgICAgICBjb250YWluZXJTdHlsZTogUE9QT1ZFUl9TVFlMRSxcbiAgICB9KTtcbiAgICB2YXIgcG9zaXRpb25Qb3BvdmVyID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICB2YXIgX2QgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2UgPSBfZC5wb3NpdGlvbkluZGV4LCBwb3NpdGlvbkluZGV4ID0gX2UgPT09IHZvaWQgMCA/IDAgOiBfZSwgX2YgPSBfZC5wYXJlbnRSZWN0LCBwYXJlbnRSZWN0ID0gX2YgPT09IHZvaWQgMCA/IHBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBfZiwgX2cgPSBfZC5jaGlsZFJlY3QsIGNoaWxkUmVjdCA9IF9nID09PSB2b2lkIDAgPyAoX2IgPSBjaGlsZFJlZiA9PT0gbnVsbCB8fCBjaGlsZFJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hpbGRSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogX2csIF9oID0gX2Quc2NvdXRSZWN0LCBzY291dFJlY3QgPSBfaCA9PT0gdm9pZCAwID8gKF9jID0gc2NvdXRSZWYgPT09IG51bGwgfHwgc2NvdXRSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjb3V0UmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IF9oLCBfaiA9IF9kLnBvcG92ZXJSZWN0LCBwb3BvdmVyUmVjdCA9IF9qID09PSB2b2lkIDAgPyBwb3BvdmVyUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBfaiwgX2sgPSBfZC5ib3VuZGFyeVJlY3QsIGJvdW5kYXJ5UmVjdCA9IF9rID09PSB2b2lkIDAgPyBib3VuZGFyeUVsZW1lbnQgPT09IHBhcmVudEVsZW1lbnRcbiAgICAgICAgICAgID8gcGFyZW50UmVjdFxuICAgICAgICAgICAgOiBib3VuZGFyeUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBfaztcbiAgICAgICAgaWYgKCFjaGlsZFJlY3QgfHwgIXBhcmVudFJlY3QgfHwgIWlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtTW9kZSA9PT0gJ2Fic29sdXRlJykge1xuICAgICAgICAgICAgdmFyIF9sID0gdHlwZW9mIHRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgID8gdHJhbnNmb3JtKHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRSZWN0OiBjaGlsZFJlY3QsXG4gICAgICAgICAgICAgICAgICAgIHBvcG92ZXJSZWN0OiBwb3BvdmVyUmVjdCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVjdDogcGFyZW50UmVjdCxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnlSZWN0OiBib3VuZGFyeVJlY3QsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgICAgICAgICAgICAgICAgbnVkZ2VkVG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICBudWRnZWRMZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeUluc2V0OiBib3VuZGFyeUluc2V0LFxuICAgICAgICAgICAgICAgICAgICB2aW9sYXRpb25zOiB1dGlsXzEuRU1QVFlfUkVDVCxcbiAgICAgICAgICAgICAgICAgICAgaGFzVmlvbGF0aW9uczogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICA6IHRyYW5zZm9ybSwgaW5wdXRUb3AgPSBfbC50b3AsIGlucHV0TGVmdCA9IF9sLmxlZnQ7XG4gICAgICAgICAgICB2YXIgZmluYWxMZWZ0XzEgPSBNYXRoLnJvdW5kKHBhcmVudFJlY3QubGVmdCArIGlucHV0TGVmdCAtIHNjb3V0UmVjdC5sZWZ0KTtcbiAgICAgICAgICAgIHZhciBmaW5hbFRvcF8xID0gTWF0aC5yb3VuZChwYXJlbnRSZWN0LnRvcCArIGlucHV0VG9wIC0gc2NvdXRSZWN0LnRvcCk7XG4gICAgICAgICAgICBwb3BvdmVyUmVmLmN1cnJlbnQuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KGZpbmFsTGVmdF8xLCBcInB4LCBcIikuY29uY2F0KGZpbmFsVG9wXzEsIFwicHgpXCIpO1xuICAgICAgICAgICAgb25Qb3NpdGlvblBvcG92ZXIoe1xuICAgICAgICAgICAgICAgIGNoaWxkUmVjdDogY2hpbGRSZWN0LFxuICAgICAgICAgICAgICAgIHBvcG92ZXJSZWN0OiAoMCwgdXRpbF8xLmNyZWF0ZVJlY3QpKHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZmluYWxMZWZ0XzEsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogZmluYWxUb3BfMSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHBvcG92ZXJSZWN0LndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHBvcG92ZXJSZWN0LmhlaWdodCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBwYXJlbnRSZWN0OiBwYXJlbnRSZWN0LFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5UmVjdDogYm91bmRhcnlSZWN0LFxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICAgICAgICAgICAgYWxpZ246IGFsaWduLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogeyB0b3A6IGlucHV0VG9wLCBsZWZ0OiBpbnB1dExlZnQgfSxcbiAgICAgICAgICAgICAgICBudWRnZWRUb3A6IDAsXG4gICAgICAgICAgICAgICAgbnVkZ2VkTGVmdDogMCxcbiAgICAgICAgICAgICAgICBib3VuZGFyeUluc2V0OiBib3VuZGFyeUluc2V0LFxuICAgICAgICAgICAgICAgIHZpb2xhdGlvbnM6IHV0aWxfMS5FTVBUWV9SRUNULFxuICAgICAgICAgICAgICAgIGhhc1Zpb2xhdGlvbnM6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzRXhoYXVzdGVkID0gcG9zaXRpb25JbmRleCA9PT0gcG9zaXRpb25zLmxlbmd0aDtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gaXNFeGhhdXN0ZWQgPyBwb3NpdGlvbnNbMF0gOiBwb3NpdGlvbnNbcG9zaXRpb25JbmRleF07XG4gICAgICAgIHZhciBfbSA9ICgwLCB1dGlsXzEuZ2V0TmV3UG9wb3ZlclJlY3QpKHtcbiAgICAgICAgICAgIGNoaWxkUmVjdDogY2hpbGRSZWN0LFxuICAgICAgICAgICAgcG9wb3ZlclJlY3Q6IHBvcG92ZXJSZWN0LFxuICAgICAgICAgICAgYm91bmRhcnlSZWN0OiBib3VuZGFyeVJlY3QsXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICBhbGlnbjogYWxpZ24sXG4gICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgICAgICAgcmVwb3NpdGlvbjogcmVwb3NpdGlvbixcbiAgICAgICAgfSwgYm91bmRhcnlJbnNldCksIHJlY3QgPSBfbS5yZWN0LCBib3VuZGFyeVZpb2xhdGlvbiA9IF9tLmJvdW5kYXJ5VmlvbGF0aW9uO1xuICAgICAgICBpZiAoYm91bmRhcnlWaW9sYXRpb24gJiYgcmVwb3NpdGlvbiAmJiAhaXNFeGhhdXN0ZWQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uUG9wb3Zlcih7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25JbmRleDogcG9zaXRpb25JbmRleCArIDEsXG4gICAgICAgICAgICAgICAgY2hpbGRSZWN0OiBjaGlsZFJlY3QsXG4gICAgICAgICAgICAgICAgcG9wb3ZlclJlY3Q6IHBvcG92ZXJSZWN0LFxuICAgICAgICAgICAgICAgIHBhcmVudFJlY3Q6IHBhcmVudFJlY3QsXG4gICAgICAgICAgICAgICAgYm91bmRhcnlSZWN0OiBib3VuZGFyeVJlY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9wID0gcmVjdC50b3AsIGxlZnQgPSByZWN0LmxlZnQsIHdpZHRoID0gcmVjdC53aWR0aCwgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIHZhciBzaG91bGROdWRnZSA9IHJlcG9zaXRpb24gJiYgIWlzRXhoYXVzdGVkO1xuICAgICAgICB2YXIgX28gPSAoMCwgdXRpbF8xLmdldE51ZGdlZFBvcG92ZXJSZWN0KShyZWN0LCBib3VuZGFyeVJlY3QsIGJvdW5kYXJ5SW5zZXQpLCBudWRnZWRMZWZ0ID0gX28ubGVmdCwgbnVkZ2VkVG9wID0gX28udG9wO1xuICAgICAgICB2YXIgZmluYWxUb3AgPSB0b3A7XG4gICAgICAgIHZhciBmaW5hbExlZnQgPSBsZWZ0O1xuICAgICAgICBpZiAoc2hvdWxkTnVkZ2UpIHtcbiAgICAgICAgICAgIGZpbmFsVG9wID0gbnVkZ2VkVG9wO1xuICAgICAgICAgICAgZmluYWxMZWZ0ID0gbnVkZ2VkTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbFRvcCA9IE1hdGgucm91bmQoZmluYWxUb3AgLSBzY291dFJlY3QudG9wKTtcbiAgICAgICAgZmluYWxMZWZ0ID0gTWF0aC5yb3VuZChmaW5hbExlZnQgLSBzY291dFJlY3QubGVmdCk7XG4gICAgICAgIHBvcG92ZXJSZWYuY3VycmVudC5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIi5jb25jYXQoZmluYWxMZWZ0LCBcInB4LCBcIikuY29uY2F0KGZpbmFsVG9wLCBcInB4KVwiKTtcbiAgICAgICAgdmFyIHBvdGVudGlhbFZpb2xhdGlvbnMgPSB7XG4gICAgICAgICAgICB0b3A6IGJvdW5kYXJ5UmVjdC50b3AgKyBib3VuZGFyeUluc2V0IC0gZmluYWxUb3AsXG4gICAgICAgICAgICBsZWZ0OiBib3VuZGFyeVJlY3QubGVmdCArIGJvdW5kYXJ5SW5zZXQgLSBmaW5hbExlZnQsXG4gICAgICAgICAgICByaWdodDogZmluYWxMZWZ0ICsgd2lkdGggLSBib3VuZGFyeVJlY3QucmlnaHQgKyBib3VuZGFyeUluc2V0LFxuICAgICAgICAgICAgYm90dG9tOiBmaW5hbFRvcCArIGhlaWdodCAtIGJvdW5kYXJ5UmVjdC5ib3R0b20gKyBib3VuZGFyeUluc2V0LFxuICAgICAgICB9O1xuICAgICAgICB2YXIgcG9wb3ZlclN0YXRlID0ge1xuICAgICAgICAgICAgY2hpbGRSZWN0OiBjaGlsZFJlY3QsXG4gICAgICAgICAgICBwb3BvdmVyUmVjdDogKDAsIHV0aWxfMS5jcmVhdGVSZWN0KSh7IGxlZnQ6IGZpbmFsTGVmdCwgdG9wOiBmaW5hbFRvcCwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KSxcbiAgICAgICAgICAgIHBhcmVudFJlY3Q6IHBhcmVudFJlY3QsXG4gICAgICAgICAgICBib3VuZGFyeVJlY3Q6IGJvdW5kYXJ5UmVjdCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICAgICAgICBudWRnZWRUb3A6IG51ZGdlZFRvcCAtIHRvcCxcbiAgICAgICAgICAgIG51ZGdlZExlZnQ6IG51ZGdlZExlZnQgLSBsZWZ0LFxuICAgICAgICAgICAgYm91bmRhcnlJbnNldDogYm91bmRhcnlJbnNldCxcbiAgICAgICAgICAgIHZpb2xhdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0b3A6IHBvdGVudGlhbFZpb2xhdGlvbnMudG9wIDw9IDAgPyAwIDogcG90ZW50aWFsVmlvbGF0aW9ucy50b3AsXG4gICAgICAgICAgICAgICAgbGVmdDogcG90ZW50aWFsVmlvbGF0aW9ucy5sZWZ0IDw9IDAgPyAwIDogcG90ZW50aWFsVmlvbGF0aW9ucy5sZWZ0LFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBwb3RlbnRpYWxWaW9sYXRpb25zLnJpZ2h0IDw9IDAgPyAwIDogcG90ZW50aWFsVmlvbGF0aW9ucy5yaWdodCxcbiAgICAgICAgICAgICAgICBib3R0b206IHBvdGVudGlhbFZpb2xhdGlvbnMuYm90dG9tIDw9IDAgPyAwIDogcG90ZW50aWFsVmlvbGF0aW9ucy5ib3R0b20sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzVmlvbGF0aW9uczogcG90ZW50aWFsVmlvbGF0aW9ucy50b3AgPiAwIHx8XG4gICAgICAgICAgICAgICAgcG90ZW50aWFsVmlvbGF0aW9ucy5sZWZ0ID4gMCB8fFxuICAgICAgICAgICAgICAgIHBvdGVudGlhbFZpb2xhdGlvbnMucmlnaHQgPiAwIHx8XG4gICAgICAgICAgICAgICAgcG90ZW50aWFsVmlvbGF0aW9ucy5ib3R0b20gPiAwLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBvblBvc2l0aW9uUG9wb3Zlcihwb3BvdmVyU3RhdGUpO1xuICAgICAgICAgICAgdmFyIF9wID0gdHlwZW9mIHRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJyA/IHRyYW5zZm9ybShwb3BvdmVyU3RhdGUpIDogdHJhbnNmb3JtLCB0cmFuc2Zvcm1Ub3AgPSBfcC50b3AsIHRyYW5zZm9ybUxlZnQgPSBfcC5sZWZ0O1xuICAgICAgICAgICAgcG9wb3ZlclJlZi5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdChNYXRoLnJvdW5kKGZpbmFsTGVmdCArICh0cmFuc2Zvcm1MZWZ0ICE9PSBudWxsICYmIHRyYW5zZm9ybUxlZnQgIT09IHZvaWQgMCA/IHRyYW5zZm9ybUxlZnQgOiAwKSksIFwicHgsIFwiKS5jb25jYXQoTWF0aC5yb3VuZChmaW5hbFRvcCArICh0cmFuc2Zvcm1Ub3AgIT09IG51bGwgJiYgdHJhbnNmb3JtVG9wICE9PSB2b2lkIDAgPyB0cmFuc2Zvcm1Ub3AgOiAwKSksIFwicHgpXCIpO1xuICAgICAgICAgICAgcG9wb3ZlclN0YXRlLm51ZGdlZExlZnQgKz0gdHJhbnNmb3JtTGVmdCAhPT0gbnVsbCAmJiB0cmFuc2Zvcm1MZWZ0ICE9PSB2b2lkIDAgPyB0cmFuc2Zvcm1MZWZ0IDogMDtcbiAgICAgICAgICAgIHBvcG92ZXJTdGF0ZS5udWRnZWRUb3AgKz0gdHJhbnNmb3JtVG9wICE9PSBudWxsICYmIHRyYW5zZm9ybVRvcCAhPT0gdm9pZCAwID8gdHJhbnNmb3JtVG9wIDogMDtcbiAgICAgICAgICAgIHBvcG92ZXJTdGF0ZS50cmFuc2Zvcm0gPSB7IHRvcDogdHJhbnNmb3JtVG9wLCBsZWZ0OiB0cmFuc2Zvcm1MZWZ0IH07XG4gICAgICAgIH1cbiAgICAgICAgb25Qb3NpdGlvblBvcG92ZXIocG9wb3ZlclN0YXRlKTtcbiAgICB9LCBbXG4gICAgICAgIHBhcmVudEVsZW1lbnQsXG4gICAgICAgIGNoaWxkUmVmLFxuICAgICAgICBzY291dFJlZixcbiAgICAgICAgcG9wb3ZlclJlZixcbiAgICAgICAgYm91bmRhcnlFbGVtZW50LFxuICAgICAgICBpc09wZW4sXG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgdHJhbnNmb3JtTW9kZSxcbiAgICAgICAgcG9zaXRpb25zLFxuICAgICAgICBhbGlnbixcbiAgICAgICAgcGFkZGluZyxcbiAgICAgICAgcmVwb3NpdGlvbixcbiAgICAgICAgYm91bmRhcnlJbnNldCxcbiAgICAgICAgb25Qb3NpdGlvblBvcG92ZXIsXG4gICAgXSk7XG4gICAgcmV0dXJuIHsgcG9zaXRpb25Qb3BvdmVyOiBwb3NpdGlvblBvcG92ZXIsIHBvcG92ZXJSZWY6IHBvcG92ZXJSZWYsIHNjb3V0UmVmOiBzY291dFJlZiB9O1xufTtcbmV4cG9ydHMudXNlUG9wb3ZlciA9IHVzZVBvcG92ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VQb3BvdmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/react-tiny-popover/dist/usePopover.js\n");

/***/ }),

/***/ "../../node_modules/react-tiny-popover/dist/util.js":
/*!**********************************************************!*\
  !*** ../../node_modules/react-tiny-popover/dist/util.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getNudgedPopoverRect = exports.getNewPopoverRect = exports.popoverRectForPosition = exports.createContainer = exports.rectsAreEqual = exports.createRect = exports.EMPTY_RECT = void 0;\nexports.EMPTY_RECT = {\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    width: 0,\n    height: 0,\n};\nvar createRect = function (_a) {\n    var top = _a.top, left = _a.left, width = _a.width, height = _a.height;\n    return ({\n        top: top,\n        left: left,\n        width: width,\n        height: height,\n        right: left + width,\n        bottom: top + height,\n    });\n};\nexports.createRect = createRect;\nvar rectsAreEqual = function (rectA, rectB) {\n    return rectA === rectB ||\n        ((rectA === null || rectA === void 0 ? void 0 : rectA.bottom) === (rectB === null || rectB === void 0 ? void 0 : rectB.bottom) &&\n            (rectA === null || rectA === void 0 ? void 0 : rectA.height) === (rectB === null || rectB === void 0 ? void 0 : rectB.height) &&\n            (rectA === null || rectA === void 0 ? void 0 : rectA.left) === (rectB === null || rectB === void 0 ? void 0 : rectB.left) &&\n            (rectA === null || rectA === void 0 ? void 0 : rectA.right) === (rectB === null || rectB === void 0 ? void 0 : rectB.right) &&\n            (rectA === null || rectA === void 0 ? void 0 : rectA.top) === (rectB === null || rectB === void 0 ? void 0 : rectB.top) &&\n            (rectA === null || rectA === void 0 ? void 0 : rectA.width) === (rectB === null || rectB === void 0 ? void 0 : rectB.width));\n};\nexports.rectsAreEqual = rectsAreEqual;\nvar createContainer = function (_a) {\n    var containerStyle = _a.containerStyle, containerClassName = _a.containerClassName;\n    var container = window.document.createElement('div');\n    if (containerClassName)\n        container.className = containerClassName;\n    Object.assign(container.style, containerStyle);\n    return container;\n};\nexports.createContainer = createContainer;\nvar popoverRectForPosition = function (position, childRect, popoverRect, padding, align) {\n    var targetMidX = childRect.left + childRect.width / 2;\n    var targetMidY = childRect.top + childRect.height / 2;\n    var width = popoverRect.width, height = popoverRect.height;\n    var top;\n    var left;\n    switch (position) {\n        case 'left':\n            top = targetMidY - height / 2;\n            left = childRect.left - padding - width;\n            if (align === 'start') {\n                top = childRect.top;\n            }\n            if (align === 'end') {\n                top = childRect.bottom - height;\n            }\n            break;\n        case 'bottom':\n            top = childRect.bottom + padding;\n            left = targetMidX - width / 2;\n            if (align === 'start') {\n                left = childRect.left;\n            }\n            if (align === 'end') {\n                left = childRect.right - width;\n            }\n            break;\n        case 'right':\n            top = targetMidY - height / 2;\n            left = childRect.right + padding;\n            if (align === 'start') {\n                top = childRect.top;\n            }\n            if (align === 'end') {\n                top = childRect.bottom - height;\n            }\n            break;\n        default:\n            top = childRect.top - height - padding;\n            left = targetMidX - width / 2;\n            if (align === 'start') {\n                left = childRect.left;\n            }\n            if (align === 'end') {\n                left = childRect.right - width;\n            }\n            break;\n    }\n    return (0, exports.createRect)({ left: left, top: top, width: width, height: height });\n};\nexports.popoverRectForPosition = popoverRectForPosition;\nvar getNewPopoverRect = function (_a, boundaryInset) {\n    var position = _a.position, align = _a.align, childRect = _a.childRect, popoverRect = _a.popoverRect, boundaryRect = _a.boundaryRect, padding = _a.padding, reposition = _a.reposition;\n    var rect = (0, exports.popoverRectForPosition)(position, childRect, popoverRect, padding, align);\n    var boundaryViolation = reposition &&\n        ((position === 'top' && rect.top < boundaryRect.top + boundaryInset) ||\n            (position === 'left' && rect.left < boundaryRect.left + boundaryInset) ||\n            (position === 'right' && rect.right > boundaryRect.right - boundaryInset) ||\n            (position === 'bottom' && rect.bottom > boundaryRect.bottom - boundaryInset));\n    return {\n        rect: rect,\n        boundaryViolation: boundaryViolation,\n    };\n};\nexports.getNewPopoverRect = getNewPopoverRect;\nvar getNudgedPopoverRect = function (popoverRect, boundaryRect, boundaryInset) {\n    var topBoundary = boundaryRect.top + boundaryInset;\n    var leftBoundary = boundaryRect.left + boundaryInset;\n    var rightBoundary = boundaryRect.right - boundaryInset;\n    var bottomBoundary = boundaryRect.bottom - boundaryInset;\n    var top = popoverRect.top < topBoundary ? topBoundary : popoverRect.top;\n    top = top + popoverRect.height > bottomBoundary ? bottomBoundary - popoverRect.height : top;\n    var left = popoverRect.left < leftBoundary ? leftBoundary : popoverRect.left;\n    left = left + popoverRect.width > rightBoundary ? rightBoundary - popoverRect.width : left;\n    return (0, exports.createRect)(__assign(__assign({}, popoverRect), { top: top, left: left }));\n};\nexports.getNudgedPopoverRect = getNudgedPopoverRect;\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXRpbnktcG9wb3Zlci9kaXN0L3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXRpbnktcG9wb3Zlci9kaXN0L3V0aWwuanM/ZjA0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldE51ZGdlZFBvcG92ZXJSZWN0ID0gZXhwb3J0cy5nZXROZXdQb3BvdmVyUmVjdCA9IGV4cG9ydHMucG9wb3ZlclJlY3RGb3JQb3NpdGlvbiA9IGV4cG9ydHMuY3JlYXRlQ29udGFpbmVyID0gZXhwb3J0cy5yZWN0c0FyZUVxdWFsID0gZXhwb3J0cy5jcmVhdGVSZWN0ID0gZXhwb3J0cy5FTVBUWV9SRUNUID0gdm9pZCAwO1xuZXhwb3J0cy5FTVBUWV9SRUNUID0ge1xuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG59O1xudmFyIGNyZWF0ZVJlY3QgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgdG9wID0gX2EudG9wLCBsZWZ0ID0gX2EubGVmdCwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgIHJldHVybiAoe1xuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgcmlnaHQ6IGxlZnQgKyB3aWR0aCxcbiAgICAgICAgYm90dG9tOiB0b3AgKyBoZWlnaHQsXG4gICAgfSk7XG59O1xuZXhwb3J0cy5jcmVhdGVSZWN0ID0gY3JlYXRlUmVjdDtcbnZhciByZWN0c0FyZUVxdWFsID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0Qikge1xuICAgIHJldHVybiByZWN0QSA9PT0gcmVjdEIgfHxcbiAgICAgICAgKChyZWN0QSA9PT0gbnVsbCB8fCByZWN0QSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVjdEEuYm90dG9tKSA9PT0gKHJlY3RCID09PSBudWxsIHx8IHJlY3RCID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWN0Qi5ib3R0b20pICYmXG4gICAgICAgICAgICAocmVjdEEgPT09IG51bGwgfHwgcmVjdEEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlY3RBLmhlaWdodCkgPT09IChyZWN0QiA9PT0gbnVsbCB8fCByZWN0QiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVjdEIuaGVpZ2h0KSAmJlxuICAgICAgICAgICAgKHJlY3RBID09PSBudWxsIHx8IHJlY3RBID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWN0QS5sZWZ0KSA9PT0gKHJlY3RCID09PSBudWxsIHx8IHJlY3RCID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWN0Qi5sZWZ0KSAmJlxuICAgICAgICAgICAgKHJlY3RBID09PSBudWxsIHx8IHJlY3RBID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWN0QS5yaWdodCkgPT09IChyZWN0QiA9PT0gbnVsbCB8fCByZWN0QiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVjdEIucmlnaHQpICYmXG4gICAgICAgICAgICAocmVjdEEgPT09IG51bGwgfHwgcmVjdEEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlY3RBLnRvcCkgPT09IChyZWN0QiA9PT0gbnVsbCB8fCByZWN0QiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVjdEIudG9wKSAmJlxuICAgICAgICAgICAgKHJlY3RBID09PSBudWxsIHx8IHJlY3RBID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWN0QS53aWR0aCkgPT09IChyZWN0QiA9PT0gbnVsbCB8fCByZWN0QiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVjdEIud2lkdGgpKTtcbn07XG5leHBvcnRzLnJlY3RzQXJlRXF1YWwgPSByZWN0c0FyZUVxdWFsO1xudmFyIGNyZWF0ZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjb250YWluZXJTdHlsZSA9IF9hLmNvbnRhaW5lclN0eWxlLCBjb250YWluZXJDbGFzc05hbWUgPSBfYS5jb250YWluZXJDbGFzc05hbWU7XG4gICAgdmFyIGNvbnRhaW5lciA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpZiAoY29udGFpbmVyQ2xhc3NOYW1lKVxuICAgICAgICBjb250YWluZXIuY2xhc3NOYW1lID0gY29udGFpbmVyQ2xhc3NOYW1lO1xuICAgIE9iamVjdC5hc3NpZ24oY29udGFpbmVyLnN0eWxlLCBjb250YWluZXJTdHlsZSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbn07XG5leHBvcnRzLmNyZWF0ZUNvbnRhaW5lciA9IGNyZWF0ZUNvbnRhaW5lcjtcbnZhciBwb3BvdmVyUmVjdEZvclBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBjaGlsZFJlY3QsIHBvcG92ZXJSZWN0LCBwYWRkaW5nLCBhbGlnbikge1xuICAgIHZhciB0YXJnZXRNaWRYID0gY2hpbGRSZWN0LmxlZnQgKyBjaGlsZFJlY3Qud2lkdGggLyAyO1xuICAgIHZhciB0YXJnZXRNaWRZID0gY2hpbGRSZWN0LnRvcCArIGNoaWxkUmVjdC5oZWlnaHQgLyAyO1xuICAgIHZhciB3aWR0aCA9IHBvcG92ZXJSZWN0LndpZHRoLCBoZWlnaHQgPSBwb3BvdmVyUmVjdC5oZWlnaHQ7XG4gICAgdmFyIHRvcDtcbiAgICB2YXIgbGVmdDtcbiAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgdG9wID0gdGFyZ2V0TWlkWSAtIGhlaWdodCAvIDI7XG4gICAgICAgICAgICBsZWZ0ID0gY2hpbGRSZWN0LmxlZnQgLSBwYWRkaW5nIC0gd2lkdGg7XG4gICAgICAgICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBjaGlsZFJlY3QudG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICAgICAgICAgIHRvcCA9IGNoaWxkUmVjdC5ib3R0b20gLSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIHRvcCA9IGNoaWxkUmVjdC5ib3R0b20gKyBwYWRkaW5nO1xuICAgICAgICAgICAgbGVmdCA9IHRhcmdldE1pZFggLSB3aWR0aCAvIDI7XG4gICAgICAgICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gY2hpbGRSZWN0LmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGNoaWxkUmVjdC5yaWdodCAtIHdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHRvcCA9IHRhcmdldE1pZFkgLSBoZWlnaHQgLyAyO1xuICAgICAgICAgICAgbGVmdCA9IGNoaWxkUmVjdC5yaWdodCArIHBhZGRpbmc7XG4gICAgICAgICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBjaGlsZFJlY3QudG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICAgICAgICAgIHRvcCA9IGNoaWxkUmVjdC5ib3R0b20gLSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRvcCA9IGNoaWxkUmVjdC50b3AgLSBoZWlnaHQgLSBwYWRkaW5nO1xuICAgICAgICAgICAgbGVmdCA9IHRhcmdldE1pZFggLSB3aWR0aCAvIDI7XG4gICAgICAgICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gY2hpbGRSZWN0LmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGNoaWxkUmVjdC5yaWdodCAtIHdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiAoMCwgZXhwb3J0cy5jcmVhdGVSZWN0KSh7IGxlZnQ6IGxlZnQsIHRvcDogdG9wLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xufTtcbmV4cG9ydHMucG9wb3ZlclJlY3RGb3JQb3NpdGlvbiA9IHBvcG92ZXJSZWN0Rm9yUG9zaXRpb247XG52YXIgZ2V0TmV3UG9wb3ZlclJlY3QgPSBmdW5jdGlvbiAoX2EsIGJvdW5kYXJ5SW5zZXQpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBfYS5wb3NpdGlvbiwgYWxpZ24gPSBfYS5hbGlnbiwgY2hpbGRSZWN0ID0gX2EuY2hpbGRSZWN0LCBwb3BvdmVyUmVjdCA9IF9hLnBvcG92ZXJSZWN0LCBib3VuZGFyeVJlY3QgPSBfYS5ib3VuZGFyeVJlY3QsIHBhZGRpbmcgPSBfYS5wYWRkaW5nLCByZXBvc2l0aW9uID0gX2EucmVwb3NpdGlvbjtcbiAgICB2YXIgcmVjdCA9ICgwLCBleHBvcnRzLnBvcG92ZXJSZWN0Rm9yUG9zaXRpb24pKHBvc2l0aW9uLCBjaGlsZFJlY3QsIHBvcG92ZXJSZWN0LCBwYWRkaW5nLCBhbGlnbik7XG4gICAgdmFyIGJvdW5kYXJ5VmlvbGF0aW9uID0gcmVwb3NpdGlvbiAmJlxuICAgICAgICAoKHBvc2l0aW9uID09PSAndG9wJyAmJiByZWN0LnRvcCA8IGJvdW5kYXJ5UmVjdC50b3AgKyBib3VuZGFyeUluc2V0KSB8fFxuICAgICAgICAgICAgKHBvc2l0aW9uID09PSAnbGVmdCcgJiYgcmVjdC5sZWZ0IDwgYm91bmRhcnlSZWN0LmxlZnQgKyBib3VuZGFyeUluc2V0KSB8fFxuICAgICAgICAgICAgKHBvc2l0aW9uID09PSAncmlnaHQnICYmIHJlY3QucmlnaHQgPiBib3VuZGFyeVJlY3QucmlnaHQgLSBib3VuZGFyeUluc2V0KSB8fFxuICAgICAgICAgICAgKHBvc2l0aW9uID09PSAnYm90dG9tJyAmJiByZWN0LmJvdHRvbSA+IGJvdW5kYXJ5UmVjdC5ib3R0b20gLSBib3VuZGFyeUluc2V0KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVjdDogcmVjdCxcbiAgICAgICAgYm91bmRhcnlWaW9sYXRpb246IGJvdW5kYXJ5VmlvbGF0aW9uLFxuICAgIH07XG59O1xuZXhwb3J0cy5nZXROZXdQb3BvdmVyUmVjdCA9IGdldE5ld1BvcG92ZXJSZWN0O1xudmFyIGdldE51ZGdlZFBvcG92ZXJSZWN0ID0gZnVuY3Rpb24gKHBvcG92ZXJSZWN0LCBib3VuZGFyeVJlY3QsIGJvdW5kYXJ5SW5zZXQpIHtcbiAgICB2YXIgdG9wQm91bmRhcnkgPSBib3VuZGFyeVJlY3QudG9wICsgYm91bmRhcnlJbnNldDtcbiAgICB2YXIgbGVmdEJvdW5kYXJ5ID0gYm91bmRhcnlSZWN0LmxlZnQgKyBib3VuZGFyeUluc2V0O1xuICAgIHZhciByaWdodEJvdW5kYXJ5ID0gYm91bmRhcnlSZWN0LnJpZ2h0IC0gYm91bmRhcnlJbnNldDtcbiAgICB2YXIgYm90dG9tQm91bmRhcnkgPSBib3VuZGFyeVJlY3QuYm90dG9tIC0gYm91bmRhcnlJbnNldDtcbiAgICB2YXIgdG9wID0gcG9wb3ZlclJlY3QudG9wIDwgdG9wQm91bmRhcnkgPyB0b3BCb3VuZGFyeSA6IHBvcG92ZXJSZWN0LnRvcDtcbiAgICB0b3AgPSB0b3AgKyBwb3BvdmVyUmVjdC5oZWlnaHQgPiBib3R0b21Cb3VuZGFyeSA/IGJvdHRvbUJvdW5kYXJ5IC0gcG9wb3ZlclJlY3QuaGVpZ2h0IDogdG9wO1xuICAgIHZhciBsZWZ0ID0gcG9wb3ZlclJlY3QubGVmdCA8IGxlZnRCb3VuZGFyeSA/IGxlZnRCb3VuZGFyeSA6IHBvcG92ZXJSZWN0LmxlZnQ7XG4gICAgbGVmdCA9IGxlZnQgKyBwb3BvdmVyUmVjdC53aWR0aCA+IHJpZ2h0Qm91bmRhcnkgPyByaWdodEJvdW5kYXJ5IC0gcG9wb3ZlclJlY3Qud2lkdGggOiBsZWZ0O1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5jcmVhdGVSZWN0KShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcG9wb3ZlclJlY3QpLCB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0pKTtcbn07XG5leHBvcnRzLmdldE51ZGdlZFBvcG92ZXJSZWN0ID0gZ2V0TnVkZ2VkUG9wb3ZlclJlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/react-tiny-popover/dist/util.js\n");

/***/ }),

/***/ "../../node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.Math === Math) {\r\n        return __webpack_require__.g;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbC9kaXN0L1Jlc2l6ZU9ic2VydmVyLmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbC9kaXN0L1Jlc2l6ZU9ic2VydmVyLmVzLmpzPzJkYTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiBzaGltcyB0aGF0IHByb3ZpZGUgbWluaW1hbCBmdW5jdGlvbmFsaXR5IG9mIHRoZSBFUzYgY29sbGVjdGlvbnMuXHJcbiAqXHJcbiAqIFRoZXNlIGltcGxlbWVudGF0aW9ucyBhcmUgbm90IG1lYW50IHRvIGJlIHVzZWQgb3V0c2lkZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJcclxuICogbW9kdWxlcyBhcyB0aGV5IGNvdmVyIG9ubHkgYSBsaW1pdGVkIHJhbmdlIG9mIHVzZSBjYXNlcy5cclxuICovXHJcbi8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtanNkb2MsIHZhbGlkLWpzZG9jICovXHJcbnZhciBNYXBTaGltID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBNYXA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaW5kZXggaW4gcHJvdmlkZWQgYXJyYXkgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk+fSBhcnJcclxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRJbmRleChhcnIsIGtleSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAtMTtcclxuICAgICAgICBhcnIuc29tZShmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeVswXSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9fZW50cmllc19fID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18xLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2VudHJpZXNfXy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9fZW50cmllc19fW2luZGV4XTtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzFdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfX1tpbmRleF1bMV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18ucHVzaChba2V5LCB2YWx1ZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLl9fZW50cmllc19fO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleChlbnRyaWVzLCBrZXkpO1xyXG4gICAgICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF+Z2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnNwbGljZSgwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBbY3R4PW51bGxdXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY3R4KSB7XHJcbiAgICAgICAgICAgIGlmIChjdHggPT09IHZvaWQgMCkgeyBjdHggPSBudWxsOyB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9fZW50cmllc19fOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGVudHJ5WzFdLCBlbnRyeVswXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBjbGFzc18xO1xyXG4gICAgfSgpKTtcclxufSkoKTtcblxuLyoqXHJcbiAqIERldGVjdHMgd2hldGhlciB3aW5kb3cgYW5kIGRvY3VtZW50IG9iamVjdHMgYXJlIGF2YWlsYWJsZSBpbiBjdXJyZW50IGVudmlyb25tZW50LlxyXG4gKi9cclxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ID09PSBkb2N1bWVudDtcblxuLy8gUmV0dXJucyBnbG9iYWwgb2JqZWN0IG9mIGEgY3VycmVudCBlbnZpcm9ubWVudC5cclxudmFyIGdsb2JhbCQxID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWw7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xyXG4gICAgcmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XHJcbn0pKCk7XG5cbi8qKlxyXG4gKiBBIHNoaW0gZm9yIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd2hpY2ggZmFsbHMgYmFjayB0byB0aGUgc2V0VGltZW91dCBpZlxyXG4gKiBmaXJzdCBvbmUgaXMgbm90IHN1cHBvcnRlZC5cclxuICpcclxuICogQHJldHVybnMge251bWJlcn0gUmVxdWVzdHMnIGlkZW50aWZpZXIuXHJcbiAqL1xyXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBJdCdzIHJlcXVpcmVkIHRvIHVzZSBhIGJvdW5kZWQgZnVuY3Rpb24gYmVjYXVzZSBJRSBzb21ldGltZXMgdGhyb3dzXHJcbiAgICAgICAgLy8gYW4gXCJJbnZhbGlkIGNhbGxpbmcgb2JqZWN0XCIgZXJyb3IgaWYgckFGIGlzIGludm9rZWQgd2l0aG91dCB0aGUgZ2xvYmFsXHJcbiAgICAgICAgLy8gb2JqZWN0IG9uIHRoZSBsZWZ0IGhhbmQgc2lkZS5cclxuICAgICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQoZ2xvYmFsJDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhEYXRlLm5vdygpKTsgfSwgMTAwMCAvIDYwKTsgfTtcclxufSkoKTtcblxuLy8gRGVmaW5lcyBtaW5pbXVtIHRpbWVvdXQgYmVmb3JlIGFkZGluZyBhIHRyYWlsaW5nIGNhbGwuXHJcbnZhciB0cmFpbGluZ1RpbWVvdXQgPSAyO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHdyYXBwZXIgZnVuY3Rpb24gd2hpY2ggZW5zdXJlcyB0aGF0IHByb3ZpZGVkIGNhbGxiYWNrIHdpbGwgYmVcclxuICogaW52b2tlZCBvbmx5IG9uY2UgZHVyaW5nIHRoZSBzcGVjaWZpZWQgZGVsYXkgcGVyaW9kLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIGRlbGF5IHBlcmlvZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IC0gRGVsYXkgYWZ0ZXIgd2hpY2ggdG8gaW52b2tlIGNhbGxiYWNrLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcbiAqL1xyXG5mdW5jdGlvbiB0aHJvdHRsZSAoY2FsbGJhY2ssIGRlbGF5KSB7XHJcbiAgICB2YXIgbGVhZGluZ0NhbGwgPSBmYWxzZSwgdHJhaWxpbmdDYWxsID0gZmFsc2UsIGxhc3RDYWxsVGltZSA9IDA7XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgdGhlIG9yaWdpbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZCBzY2hlZHVsZXMgbmV3IGludm9jYXRpb24gaWZcclxuICAgICAqIHRoZSBcInByb3h5XCIgd2FzIGNhbGxlZCBkdXJpbmcgY3VycmVudCByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZXNvbHZlUGVuZGluZygpIHtcclxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgbGVhZGluZ0NhbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRyYWlsaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICBwcm94eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgaW52b2tlZCBhZnRlciB0aGUgc3BlY2lmaWVkIGRlbGF5LiBJdCB3aWxsIGZ1cnRoZXIgcG9zdHBvbmVcclxuICAgICAqIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGRlbGVnYXRpbmcgaXQgdG8gdGhlXHJcbiAgICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMShyZXNvbHZlUGVuZGluZyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNjaGVkdWxlcyBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcHJveHkoKSB7XHJcbiAgICAgICAgdmFyIHRpbWVTdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFJlamVjdCBpbW1lZGlhdGVseSBmb2xsb3dpbmcgY2FsbHMuXHJcbiAgICAgICAgICAgIGlmICh0aW1lU3RhbXAgLSBsYXN0Q2FsbFRpbWUgPCB0cmFpbGluZ1RpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBuZXcgY2FsbCB0byBiZSBpbiBpbnZva2VkIHdoZW4gdGhlIHBlbmRpbmcgb25lIGlzIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBmb3IgXCJ0cmFuc2l0aW9uc1wiIHdoaWNoIG5ldmVyIGFjdHVhbGx5IHN0YXJ0XHJcbiAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IHNvIHRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgd2UgbWlnaHQgbWlzcyBvbmUgaWYgY2hhbmdlXHJcbiAgICAgICAgICAgIC8vIGhhcHBlbnMgYW1pZHMgdGhlIHBlbmRpbmcgaW52b2NhdGlvbi5cclxuICAgICAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxlYWRpbmdDYWxsID0gdHJ1ZTtcclxuICAgICAgICAgICAgdHJhaWxpbmdDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGltZW91dENhbGxiYWNrLCBkZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWVTdGFtcDtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm94eTtcclxufVxuXG4vLyBNaW5pbXVtIGRlbGF5IGJlZm9yZSBpbnZva2luZyB0aGUgdXBkYXRlIG9mIG9ic2VydmVycy5cclxudmFyIFJFRlJFU0hfREVMQVkgPSAyMDtcclxuLy8gQSBsaXN0IG9mIHN1YnN0cmluZ3Mgb2YgQ1NTIHByb3BlcnRpZXMgdXNlZCB0byBmaW5kIHRyYW5zaXRpb24gZXZlbnRzIHRoYXRcclxuLy8gbWlnaHQgYWZmZWN0IGRpbWVuc2lvbnMgb2Ygb2JzZXJ2ZWQgZWxlbWVudHMuXHJcbnZhciB0cmFuc2l0aW9uS2V5cyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JywgJ3dpZHRoJywgJ2hlaWdodCcsICdzaXplJywgJ3dlaWdodCddO1xyXG4vLyBDaGVjayBpZiBNdXRhdGlvbk9ic2VydmVyIGlzIGF2YWlsYWJsZS5cclxudmFyIG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XHJcbi8qKlxyXG4gKiBTaW5nbGV0b24gY29udHJvbGxlciBjbGFzcyB3aGljaCBoYW5kbGVzIHVwZGF0ZXMgb2YgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2VzLlxyXG4gKi9cclxudmFyIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIERPTSBsaXN0ZW5lcnMgaGF2ZSBiZWVuIGFkZGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVsbHMgdGhhdCBjb250cm9sbGVyIGhhcyBzdWJzY3JpYmVkIGZvciBNdXRhdGlvbiBFdmVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogS2VlcHMgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSBvZiBNdXRhdGlvbk9ic2VydmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge011dGF0aW9uT2JzZXJ2ZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbGlzdCBvZiBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0FycmF5PFJlc2l6ZU9ic2VydmVyU1BJPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9ic2VydmVyc18gPSBbXTtcclxuICAgICAgICB0aGlzLm9uVHJhbnNpdGlvbkVuZF8gPSB0aGlzLm9uVHJhbnNpdGlvbkVuZF8uYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlZnJlc2ggPSB0aHJvdHRsZSh0aGlzLnJlZnJlc2guYmluZCh0aGlzKSwgUkVGUkVTSF9ERUxBWSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgb2JzZXJ2ZXIgdG8gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSBhZGRlZC5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmFkZE9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgaWYgKCF+dGhpcy5vYnNlcnZlcnNfLmluZGV4T2Yob2JzZXJ2ZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzXy5wdXNoKG9ic2VydmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIGxpc3RlbmVycyBpZiB0aGV5IGhhdmVuJ3QgYmVlbiBhZGRlZCB5ZXQuXHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyU1BJfSBvYnNlcnZlciAtIE9ic2VydmVyIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmVPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc187XHJcbiAgICAgICAgdmFyIGluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpO1xyXG4gICAgICAgIC8vIFJlbW92ZSBvYnNlcnZlciBpZiBpdCdzIHByZXNlbnQgaW4gcmVnaXN0cnkuXHJcbiAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtb3ZlIGxpc3RlbmVycyBpZiBjb250cm9sbGVyIGhhcyBubyBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICAgIGlmICghb2JzZXJ2ZXJzLmxlbmd0aCAmJiB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuIEl0IHdpbGwgY29udGludWUgcnVubmluZyB1cGRhdGVzIGluc29mYXJcclxuICAgICAqIGl0IGRldGVjdHMgY2hhbmdlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjaGFuZ2VzRGV0ZWN0ZWQgPSB0aGlzLnVwZGF0ZU9ic2VydmVyc18oKTtcclxuICAgICAgICAvLyBDb250aW51ZSBydW5uaW5nIHVwZGF0ZXMgaWYgY2hhbmdlcyBoYXZlIGJlZW4gZGV0ZWN0ZWQgYXMgdGhlcmUgbWlnaHRcclxuICAgICAgICAvLyBiZSBmdXR1cmUgb25lcyBjYXVzZWQgYnkgQ1NTIHRyYW5zaXRpb25zLlxyXG4gICAgICAgIGlmIChjaGFuZ2VzRGV0ZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBldmVyeSBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0IGFuZCBub3RpZmllcyB0aGVtIG9mIHF1ZXVlZFxyXG4gICAgICogZW50cmllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgXCJ0cnVlXCIgaWYgYW55IG9ic2VydmVyIGhhcyBkZXRlY3RlZCBjaGFuZ2VzIGluXHJcbiAgICAgKiAgICAgIGRpbWVuc2lvbnMgb2YgaXQncyBlbGVtZW50cy5cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVPYnNlcnZlcnNfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIENvbGxlY3Qgb2JzZXJ2ZXJzIHRoYXQgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIHZhciBhY3RpdmVPYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc18uZmlsdGVyKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZ2F0aGVyQWN0aXZlKCksIG9ic2VydmVyLmhhc0FjdGl2ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIERlbGl2ZXIgbm90aWZpY2F0aW9ucyBpbiBhIHNlcGFyYXRlIGN5Y2xlIGluIG9yZGVyIHRvIGF2b2lkIGFueVxyXG4gICAgICAgIC8vIGNvbGxpc2lvbnMgYmV0d2VlbiBvYnNlcnZlcnMsIGUuZy4gd2hlbiBtdWx0aXBsZSBpbnN0YW5jZXMgb2ZcclxuICAgICAgICAvLyBSZXNpemVPYnNlcnZlciBhcmUgdHJhY2tpbmcgdGhlIHNhbWUgZWxlbWVudCBhbmQgdGhlIGNhbGxiYWNrIG9mIG9uZVxyXG4gICAgICAgIC8vIG9mIHRoZW0gY2hhbmdlcyBjb250ZW50IGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIHRhcmdldC4gU29tZXRpbWVzXHJcbiAgICAgICAgLy8gdGhpcyBtYXkgcmVzdWx0IGluIG5vdGlmaWNhdGlvbnMgYmVpbmcgYmxvY2tlZCBmb3IgdGhlIHJlc3Qgb2Ygb2JzZXJ2ZXJzLlxyXG4gICAgICAgIGFjdGl2ZU9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikgeyByZXR1cm4gb2JzZXJ2ZXIuYnJvYWRjYXN0QWN0aXZlKCk7IH0pO1xyXG4gICAgICAgIHJldHVybiBhY3RpdmVPYnNlcnZlcnMubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmNvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG4gICAgICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IGFkZGVkLlxyXG4gICAgICAgIGlmICghaXNCcm93c2VyIHx8IHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFN1YnNjcmlwdGlvbiB0byB0aGUgXCJUcmFuc2l0aW9uZW5kXCIgZXZlbnQgaXMgdXNlZCBhcyBhIHdvcmthcm91bmQgZm9yXHJcbiAgICAgICAgLy8gZGVsYXllZCB0cmFuc2l0aW9ucy4gVGhpcyB3YXkgaXQncyBwb3NzaWJsZSB0byBjYXB0dXJlIGF0IGxlYXN0IHRoZVxyXG4gICAgICAgIC8vIGZpbmFsIHN0YXRlIG9mIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5vYnNlcnZlKGRvY3VtZW50LCB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHN1YnRyZWU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01TdWJ0cmVlTW9kaWZpZWQnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgRE9NIGxpc3RlbmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuZGlzY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBydW5uaW5nIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQgb3IgaWYgbGlzdGVuZXJzXHJcbiAgICAgICAgLy8gaGF2ZSBiZWVuIGFscmVhZHkgcmVtb3ZlZC5cclxuICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCAhdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8pIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7VHJhbnNpdGlvbkV2ZW50fSBldmVudFxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUub25UcmFuc2l0aW9uRW5kXyA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hLnByb3BlcnR5TmFtZSwgcHJvcGVydHlOYW1lID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2I7XHJcbiAgICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgdHJhbnNpdGlvbiBtYXkgYWZmZWN0IGRpbWVuc2lvbnMgb2YgYW4gZWxlbWVudC5cclxuICAgICAgICB2YXIgaXNSZWZsb3dQcm9wZXJ0eSA9IHRyYW5zaXRpb25LZXlzLnNvbWUoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF+cHJvcGVydHlOYW1lLmluZGV4T2Yoa2V5KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaXNSZWZsb3dQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGluc3RhbmNlIG9mIHRoZSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbnN0YW5jZV8pIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZV8gPSBuZXcgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlXztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEhvbGRzIHJlZmVyZW5jZSB0byB0aGUgY29udHJvbGxlcidzIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5pbnN0YW5jZV8gPSBudWxsO1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjtcclxufSgpKTtcblxuLyoqXHJcbiAqIERlZmluZXMgbm9uLXdyaXRhYmxlL2VudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgcHJvdmlkZWQgdGFyZ2V0IG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIE9iamVjdCBmb3Igd2hpY2ggdG8gZGVmaW5lIHByb3BlcnRpZXMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIFByb3BlcnRpZXMgdG8gYmUgZGVmaW5lZC5cclxuICogQHJldHVybnMge09iamVjdH0gVGFyZ2V0IG9iamVjdC5cclxuICovXHJcbnZhciBkZWZpbmVDb25maWd1cmFibGUgPSAoZnVuY3Rpb24gKHRhcmdldCwgcHJvcHMpIHtcclxuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhwcm9wcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IF9hW19pXTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcclxuICAgICAgICAgICAgdmFsdWU6IHByb3BzW2tleV0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufSk7XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBnbG9iYWwgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCBwcm92aWRlZCBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XHJcbiAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAqL1xyXG52YXIgZ2V0V2luZG93T2YgPSAoZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgLy8gQXNzdW1lIHRoYXQgdGhlIGVsZW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgTm9kZSwgd2hpY2ggbWVhbnMgdGhhdCBpdFxyXG4gICAgLy8gaGFzIHRoZSBcIm93bmVyRG9jdW1lbnRcIiBwcm9wZXJ0eSBmcm9tIHdoaWNoIHdlIGNhbiByZXRyaWV2ZSBhXHJcbiAgICAvLyBjb3JyZXNwb25kaW5nIGdsb2JhbCBvYmplY3QuXHJcbiAgICB2YXIgb3duZXJHbG9iYWwgPSB0YXJnZXQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XHJcbiAgICAvLyBSZXR1cm4gdGhlIGxvY2FsIGdsb2JhbCBvYmplY3QgaWYgaXQncyBub3QgcG9zc2libGUgZXh0cmFjdCBvbmUgZnJvbVxyXG4gICAgLy8gcHJvdmlkZWQgZWxlbWVudC5cclxuICAgIHJldHVybiBvd25lckdsb2JhbCB8fCBnbG9iYWwkMTtcclxufSk7XG5cbi8vIFBsYWNlaG9sZGVyIG9mIGFuIGVtcHR5IGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG52YXIgZW1wdHlSZWN0ID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBwcm92aWRlZCBzdHJpbmcgdG8gYSBudW1iZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcclxuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBib3JkZXJzIHNpemUgZnJvbSBwcm92aWRlZCBzdHlsZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXHJcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwb3NpdGlvbnMgLSBCb3JkZXJzIHBvc2l0aW9ucyAodG9wLCByaWdodCwgLi4uKVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzKSB7XHJcbiAgICB2YXIgcG9zaXRpb25zID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHBvc2l0aW9uc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBwb3NpdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChzaXplLCBwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlc1snYm9yZGVyLScgKyBwb3NpdGlvbiArICctd2lkdGgnXTtcclxuICAgICAgICByZXR1cm4gc2l6ZSArIHRvRmxvYXQodmFsdWUpO1xyXG4gICAgfSwgMCk7XHJcbn1cclxuLyoqXHJcbiAqIEV4dHJhY3RzIHBhZGRpbmdzIHNpemVzIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBQYWRkaW5ncyBib3guXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQYWRkaW5ncyhzdHlsZXMpIHtcclxuICAgIHZhciBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xyXG4gICAgdmFyIHBhZGRpbmdzID0ge307XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIHBvc2l0aW9uc18xID0gcG9zaXRpb25zOyBfaSA8IHBvc2l0aW9uc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHBvc2l0aW9uc18xW19pXTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ3BhZGRpbmctJyArIHBvc2l0aW9uXTtcclxuICAgICAgICBwYWRkaW5nc1twb3NpdGlvbl0gPSB0b0Zsb2F0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYWRkaW5ncztcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBjb250ZW50IHJlY3RhbmdsZSBvZiBwcm92aWRlZCBTVkcgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtTVkdHcmFwaGljc0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHNcclxuICogICAgICB0byBiZSBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgIHZhciBiYm94ID0gdGFyZ2V0LmdldEJCb3goKTtcclxuICAgIHJldHVybiBjcmVhdGVSZWN0SW5pdCgwLCAwLCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgSFRNTEVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgY29udGVudCByZWN0YW5nbGUuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICAvLyBDbGllbnQgd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBjYW4ndCBiZVxyXG4gICAgLy8gdXNlZCBleGNsdXNpdmVseSBhcyB0aGV5IHByb3ZpZGUgcm91bmRlZCB2YWx1ZXMuXHJcbiAgICB2YXIgY2xpZW50V2lkdGggPSB0YXJnZXQuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCA9IHRhcmdldC5jbGllbnRIZWlnaHQ7XHJcbiAgICAvLyBCeSB0aGlzIGNvbmRpdGlvbiB3ZSBjYW4gY2F0Y2ggYWxsIG5vbi1yZXBsYWNlZCBpbmxpbmUsIGhpZGRlbiBhbmRcclxuICAgIC8vIGRldGFjaGVkIGVsZW1lbnRzLiBUaG91Z2ggZWxlbWVudHMgd2l0aCB3aWR0aCAmIGhlaWdodCBwcm9wZXJ0aWVzIGxlc3NcclxuICAgIC8vIHRoYW4gMC41IHdpbGwgYmUgZGlzY2FyZGVkIGFzIHdlbGwuXHJcbiAgICAvL1xyXG4gICAgLy8gV2l0aG91dCBpdCB3ZSB3b3VsZCBuZWVkIHRvIGltcGxlbWVudCBzZXBhcmF0ZSBtZXRob2RzIGZvciBlYWNoIG9mXHJcbiAgICAvLyB0aG9zZSBjYXNlcyBhbmQgaXQncyBub3QgcG9zc2libGUgdG8gcGVyZm9ybSBhIHByZWNpc2UgYW5kIHBlcmZvcm1hbmNlXHJcbiAgICAvLyBlZmZlY3RpdmUgdGVzdCBmb3IgaGlkZGVuIGVsZW1lbnRzLiBFLmcuIGV2ZW4galF1ZXJ5J3MgJzp2aXNpYmxlJyBmaWx0ZXJcclxuICAgIC8vIGdpdmVzIHdyb25nIHJlc3VsdHMgZm9yIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgbGVzcyB0aGFuIDAuNS5cclxuICAgIGlmICghY2xpZW50V2lkdGggJiYgIWNsaWVudEhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiBlbXB0eVJlY3Q7XHJcbiAgICB9XHJcbiAgICB2YXIgc3R5bGVzID0gZ2V0V2luZG93T2YodGFyZ2V0KS5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XHJcbiAgICB2YXIgcGFkZGluZ3MgPSBnZXRQYWRkaW5ncyhzdHlsZXMpO1xyXG4gICAgdmFyIGhvcml6UGFkID0gcGFkZGluZ3MubGVmdCArIHBhZGRpbmdzLnJpZ2h0O1xyXG4gICAgdmFyIHZlcnRQYWQgPSBwYWRkaW5ncy50b3AgKyBwYWRkaW5ncy5ib3R0b207XHJcbiAgICAvLyBDb21wdXRlZCBzdHlsZXMgb2Ygd2lkdGggJiBoZWlnaHQgYXJlIGJlaW5nIHVzZWQgYmVjYXVzZSB0aGV5IGFyZSB0aGVcclxuICAgIC8vIG9ubHkgZGltZW5zaW9ucyBhdmFpbGFibGUgdG8gSlMgdGhhdCBjb250YWluIG5vbi1yb3VuZGVkIHZhbHVlcy4gSXQgY291bGRcclxuICAgIC8vIGJlIHBvc3NpYmxlIHRvIHV0aWxpemUgdGhlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpZiBvbmx5IGl0J3MgZGF0YSB3YXNuJ3RcclxuICAgIC8vIGFmZmVjdGVkIGJ5IENTUyB0cmFuc2Zvcm1hdGlvbnMgbGV0IGFsb25lIHBhZGRpbmdzLCBib3JkZXJzIGFuZCBzY3JvbGwgYmFycy5cclxuICAgIHZhciB3aWR0aCA9IHRvRmxvYXQoc3R5bGVzLndpZHRoKSwgaGVpZ2h0ID0gdG9GbG9hdChzdHlsZXMuaGVpZ2h0KTtcclxuICAgIC8vIFdpZHRoICYgaGVpZ2h0IGluY2x1ZGUgcGFkZGluZ3MgYW5kIGJvcmRlcnMgd2hlbiB0aGUgJ2JvcmRlci1ib3gnIGJveFxyXG4gICAgLy8gbW9kZWwgaXMgYXBwbGllZCAoZXhjZXB0IGZvciBJRSkuXHJcbiAgICBpZiAoc3R5bGVzLmJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnKSB7XHJcbiAgICAgICAgLy8gRm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIHJlcXVpcmVkIHRvIGhhbmRsZSBJbnRlcm5ldCBFeHBsb3JlciB3aGljaFxyXG4gICAgICAgIC8vIGRvZXNuJ3QgaW5jbHVkZSBwYWRkaW5ncyBhbmQgYm9yZGVycyB0byBjb21wdXRlZCBDU1MgZGltZW5zaW9ucy5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFdlIGNhbiBzYXkgdGhhdCBpZiBDU1MgZGltZW5zaW9ucyArIHBhZGRpbmdzIGFyZSBlcXVhbCB0byB0aGUgXCJjbGllbnRcIlxyXG4gICAgICAgIC8vIHByb3BlcnRpZXMgdGhlbiBpdCdzIGVpdGhlciBJRSwgYW5kIHRodXMgd2UgZG9uJ3QgbmVlZCB0byBzdWJ0cmFjdFxyXG4gICAgICAgIC8vIGFueXRoaW5nLCBvciBhbiBlbGVtZW50IG1lcmVseSBkb2Vzbid0IGhhdmUgcGFkZGluZ3MvYm9yZGVycyBzdHlsZXMuXHJcbiAgICAgICAgaWYgKE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgIT09IGNsaWVudFdpZHRoKSB7XHJcbiAgICAgICAgICAgIHdpZHRoIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ2xlZnQnLCAncmlnaHQnKSArIGhvcml6UGFkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAhPT0gY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGhlaWdodCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd0b3AnLCAnYm90dG9tJykgKyB2ZXJ0UGFkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEZvbGxvd2luZyBzdGVwcyBjYW4ndCBiZSBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudCdzIHJvb3QgZWxlbWVudCBhcyBpdHNcclxuICAgIC8vIGNsaWVudFtXaWR0aC9IZWlnaHRdIHByb3BlcnRpZXMgcmVwcmVzZW50IHZpZXdwb3J0IGFyZWEgb2YgdGhlIHdpbmRvdy5cclxuICAgIC8vIEJlc2lkZXMsIGl0J3MgYXMgd2VsbCBub3QgbmVjZXNzYXJ5IGFzIHRoZSA8aHRtbD4gaXRzZWxmIG5laXRoZXIgaGFzXHJcbiAgICAvLyByZW5kZXJlZCBzY3JvbGwgYmFycyBub3IgaXQgY2FuIGJlIGNsaXBwZWQuXHJcbiAgICBpZiAoIWlzRG9jdW1lbnRFbGVtZW50KHRhcmdldCkpIHtcclxuICAgICAgICAvLyBJbiBzb21lIGJyb3dzZXJzIChvbmx5IGluIEZpcmVmb3gsIGFjdHVhbGx5KSBDU1Mgd2lkdGggJiBoZWlnaHRcclxuICAgICAgICAvLyBpbmNsdWRlIHNjcm9sbCBiYXJzIHNpemUgd2hpY2ggY2FuIGJlIHJlbW92ZWQgYXQgdGhpcyBzdGVwIGFzIHNjcm9sbFxyXG4gICAgICAgIC8vIGJhcnMgYXJlIHRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiByb3VuZGVkIGRpbWVuc2lvbnMgKyBwYWRkaW5nc1xyXG4gICAgICAgIC8vIGFuZCBcImNsaWVudFwiIHByb3BlcnRpZXMsIHRob3VnaCB0aGF0IGlzIG5vdCBhbHdheXMgdHJ1ZSBpbiBDaHJvbWUuXHJcbiAgICAgICAgdmFyIHZlcnRTY3JvbGxiYXIgPSBNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpIC0gY2xpZW50V2lkdGg7XHJcbiAgICAgICAgdmFyIGhvcml6U2Nyb2xsYmFyID0gTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAtIGNsaWVudEhlaWdodDtcclxuICAgICAgICAvLyBDaHJvbWUgaGFzIGEgcmF0aGVyIHdlaXJkIHJvdW5kaW5nIG9mIFwiY2xpZW50XCIgcHJvcGVydGllcy5cclxuICAgICAgICAvLyBFLmcuIGZvciBhbiBlbGVtZW50IHdpdGggY29udGVudCB3aWR0aCBvZiAzMTQuMnB4IGl0IHNvbWV0aW1lcyBnaXZlc1xyXG4gICAgICAgIC8vIHRoZSBjbGllbnQgd2lkdGggb2YgMzE1cHggYW5kIGZvciB0aGUgd2lkdGggb2YgMzE0LjdweCBpdCBtYXkgZ2l2ZVxyXG4gICAgICAgIC8vIDMxNHB4LiBBbmQgaXQgZG9lc24ndCBoYXBwZW4gYWxsIHRoZSB0aW1lLiBTbyBqdXN0IGlnbm9yZSB0aGlzIGRlbHRhXHJcbiAgICAgICAgLy8gYXMgYSBub24tcmVsZXZhbnQuXHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHZlcnRTY3JvbGxiYXIpICE9PSAxKSB7XHJcbiAgICAgICAgICAgIHdpZHRoIC09IHZlcnRTY3JvbGxiYXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChNYXRoLmFicyhob3JpelNjcm9sbGJhcikgIT09IDEpIHtcclxuICAgICAgICAgICAgaGVpZ2h0IC09IGhvcml6U2Nyb2xsYmFyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVSZWN0SW5pdChwYWRkaW5ncy5sZWZ0LCBwYWRkaW5ncy50b3AsIHdpZHRoLCBoZWlnaHQpO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBTVkdHcmFwaGljc0VsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbnZhciBpc1NWR0dyYXBoaWNzRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBTb21lIGJyb3dzZXJzLCBuYW1lbHkgSUUgYW5kIEVkZ2UsIGRvbid0IGhhdmUgdGhlIFNWR0dyYXBoaWNzRWxlbWVudFxyXG4gICAgLy8gaW50ZXJmYWNlLlxyXG4gICAgaWYgKHR5cGVvZiBTVkdHcmFwaGljc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuU1ZHR3JhcGhpY3NFbGVtZW50OyB9O1xyXG4gICAgfVxyXG4gICAgLy8gSWYgaXQncyBzbywgdGhlbiBjaGVjayB0aGF0IGVsZW1lbnQgaXMgYXQgbGVhc3QgYW4gaW5zdGFuY2Ugb2YgdGhlXHJcbiAgICAvLyBTVkdFbGVtZW50IGFuZCB0aGF0IGl0IGhhcyB0aGUgXCJnZXRCQm94XCIgbWV0aG9kLlxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuICh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0VsZW1lbnQgJiZcclxuICAgICAgICB0eXBlb2YgdGFyZ2V0LmdldEJCb3ggPT09ICdmdW5jdGlvbicpOyB9O1xyXG59KSgpO1xyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhIGRvY3VtZW50IGVsZW1lbnQgKDxodG1sPikuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzRG9jdW1lbnRFbGVtZW50KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIHRhcmdldCA9PT0gZ2V0V2luZG93T2YodGFyZ2V0KS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYW4gYXBwcm9wcmlhdGUgY29udGVudCByZWN0YW5nbGUgZm9yIHByb3ZpZGVkIGh0bWwgb3Igc3ZnIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBjb250ZW50IHJlY3RhbmdsZSBvZiB3aGljaCBuZWVkcyB0byBiZSBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgIGlmICghaXNCcm93c2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIGVtcHR5UmVjdDtcclxuICAgIH1cclxuICAgIGlmIChpc1NWR0dyYXBoaWNzRWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCh0YXJnZXQpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIHJlY3RhbmdsZSB3aXRoIGFuIGludGVyZmFjZSBvZiB0aGUgRE9NUmVjdFJlYWRPbmx5LlxyXG4gKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZG9tcmVjdHJlYWRvbmx5XHJcbiAqXHJcbiAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gT2JqZWN0IHdpdGggcmVjdGFuZ2xlJ3MgeC95IGNvb3JkaW5hdGVzIGFuZCBkaW1lbnNpb25zLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdFJlYWRPbmx5fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVhZE9ubHlSZWN0KF9hKSB7XHJcbiAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAvLyBJZiBET01SZWN0UmVhZE9ubHkgaXMgYXZhaWxhYmxlIHVzZSBpdCBhcyBhIHByb3RvdHlwZSBmb3IgdGhlIHJlY3RhbmdsZS5cclxuICAgIHZhciBDb25zdHIgPSB0eXBlb2YgRE9NUmVjdFJlYWRPbmx5ICE9PSAndW5kZWZpbmVkJyA/IERPTVJlY3RSZWFkT25seSA6IE9iamVjdDtcclxuICAgIHZhciByZWN0ID0gT2JqZWN0LmNyZWF0ZShDb25zdHIucHJvdG90eXBlKTtcclxuICAgIC8vIFJlY3RhbmdsZSdzIHByb3BlcnRpZXMgYXJlIG5vdCB3cml0YWJsZSBhbmQgbm9uLWVudW1lcmFibGUuXHJcbiAgICBkZWZpbmVDb25maWd1cmFibGUocmVjdCwge1xyXG4gICAgICAgIHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgdG9wOiB5LFxyXG4gICAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXHJcbiAgICAgICAgYm90dG9tOiBoZWlnaHQgKyB5LFxyXG4gICAgICAgIGxlZnQ6IHhcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgRE9NUmVjdEluaXQgb2JqZWN0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBkaW1lbnNpb25zIGFuZCB0aGUgeC95IGNvb3JkaW5hdGVzLlxyXG4gKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZGljdGRlZi1kb21yZWN0aW5pdFxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFggY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFJlY3RhbmdsZSdzIHdpZHRoLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gUmVjdGFuZ2xlJ3MgaGVpZ2h0LlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZWN0SW5pdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICByZXR1cm4geyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XHJcbn1cblxuLyoqXHJcbiAqIENsYXNzIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIGNvbXB1dGF0aW9ucyBvZiB0aGUgY29udGVudCByZWN0YW5nbGUgb2ZcclxuICogcHJvdmlkZWQgRE9NIGVsZW1lbnQgYW5kIGZvciBrZWVwaW5nIHRyYWNrIG9mIGl0J3MgY2hhbmdlcy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmF0aW9uKHRhcmdldCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJyb2FkY2FzdGVkIHdpZHRoIG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJyb2FkY2FzdFdpZHRoID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCcm9hZGNhc3RlZCBoZWlnaHQgb2YgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7RE9NUmVjdEluaXR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdF8gPSBjcmVhdGVSZWN0SW5pdCgwLCAwLCAwLCAwKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBjb250ZW50IHJlY3RhbmdsZSBhbmQgdGVsbHMgd2hldGhlciBpdCdzIHdpZHRoIG9yIGhlaWdodCBwcm9wZXJ0aWVzXHJcbiAgICAgKiBoYXZlIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYnJvYWRjYXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSBnZXRDb250ZW50UmVjdCh0aGlzLnRhcmdldCk7XHJcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdF8gPSByZWN0O1xyXG4gICAgICAgIHJldHVybiAocmVjdC53aWR0aCAhPT0gdGhpcy5icm9hZGNhc3RXaWR0aCB8fFxyXG4gICAgICAgICAgICByZWN0LmhlaWdodCAhPT0gdGhpcy5icm9hZGNhc3RIZWlnaHQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyAnYnJvYWRjYXN0V2lkdGgnIGFuZCAnYnJvYWRjYXN0SGVpZ2h0JyBwcm9wZXJ0aWVzIHdpdGggYSBkYXRhXHJcbiAgICAgKiBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXMgb2YgdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0RPTVJlY3RJbml0fSBMYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuYnJvYWRjYXN0UmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY29udGVudFJlY3RfO1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmF0aW9uO1xyXG59KCkpO1xuXG52YXIgUmVzaXplT2JzZXJ2ZXJFbnRyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckVudHJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0aGF0IGlzIGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICogQHBhcmFtIHtET01SZWN0SW5pdH0gcmVjdEluaXQgLSBEYXRhIG9mIHRoZSBlbGVtZW50J3MgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyRW50cnkodGFyZ2V0LCByZWN0SW5pdCkge1xyXG4gICAgICAgIHZhciBjb250ZW50UmVjdCA9IGNyZWF0ZVJlYWRPbmx5UmVjdChyZWN0SW5pdCk7XHJcbiAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpY2F0aW9uIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGVcclxuICAgICAgICAvLyBhbmQgYXJlIGFsc28gbm90IGVudW1lcmFibGUgaW4gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFByb3BlcnR5IGFjY2Vzc29ycyBhcmUgbm90IGJlaW5nIHVzZWQgYXMgdGhleSdkIHJlcXVpcmUgdG8gZGVmaW5lIGFcclxuICAgICAgICAvLyBwcml2YXRlIFdlYWtNYXAgc3RvcmFnZSB3aGljaCBtYXkgY2F1c2UgbWVtb3J5IGxlYWtzIGluIGJyb3dzZXJzIHRoYXRcclxuICAgICAgICAvLyBkb24ndCBzdXBwb3J0IHRoaXMgdHlwZSBvZiBjb2xsZWN0aW9ucy5cclxuICAgICAgICBkZWZpbmVDb25maWd1cmFibGUodGhpcywgeyB0YXJnZXQ6IHRhcmdldCwgY29udGVudFJlY3Q6IGNvbnRlbnRSZWN0IH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyRW50cnk7XHJcbn0oKSk7XG5cbnZhciBSZXNpemVPYnNlcnZlclNQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkXHJcbiAgICAgKiAgICAgIHdoZW4gb25lIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2VzIGl0J3MgY29udGVudCBkaW1lbnNpb25zLlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9IGNvbnRyb2xsZXIgLSBDb250cm9sbGVyIGluc3RhbmNlIHdoaWNoXHJcbiAgICAgKiAgICAgIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgdXBkYXRlcyBvZiBvYnNlcnZlci5cclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJ9IGNhbGxiYWNrQ3R4IC0gUmVmZXJlbmNlIHRvIHRoZSBwdWJsaWNcclxuICAgICAqICAgICAgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2Ugd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyU1BJKGNhbGxiYWNrLCBjb250cm9sbGVyLCBjYWxsYmFja0N0eCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgcmVzaXplIG9ic2VydmF0aW9ucyB0aGF0IGhhdmUgZGV0ZWN0ZWQgY2hhbmdlcyBpbiBkaW1lbnNpb25zXHJcbiAgICAgICAgICogb2YgZWxlbWVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8UmVzaXplT2JzZXJ2YXRpb24+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdHJ5IG9mIHRoZSBSZXNpemVPYnNlcnZhdGlvbiBpbnN0YW5jZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7TWFwPEVsZW1lbnQsIFJlc2l6ZU9ic2VydmF0aW9uPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18gPSBuZXcgTWFwU2hpbSgpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNhbGxiYWNrIHByb3ZpZGVkIGFzIHBhcmFtZXRlciAxIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8gPSBjb250cm9sbGVyO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tDdHhfID0gY2FsbGJhY2tDdHg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBvYnNlcnZpbmcgcHJvdmlkZWQgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSB0aGUgRWxlbWVudCBpbnRlcmZhY2UuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhKEVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICBpZiAob2JzZXJ2YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JzZXJ2YXRpb25zLnNldCh0YXJnZXQsIG5ldyBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLmFkZE9ic2VydmVyKHRoaXMpO1xyXG4gICAgICAgIC8vIEZvcmNlIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVmcmVzaCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIHN0b3Agb2JzZXJ2aW5nLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS51bm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSB0aGUgRWxlbWVudCBpbnRlcmZhY2UuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhKEVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgbm90IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgIGlmICghb2JzZXJ2YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JzZXJ2YXRpb25zLmRlbGV0ZSh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghb2JzZXJ2YXRpb25zLnNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBvYnNlcnZpbmcgYWxsIGVsZW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3RzIG9ic2VydmF0aW9uIGluc3RhbmNlcyB0aGUgYXNzb2NpYXRlZCBlbGVtZW50IG9mIHdoaWNoIGhhcyBjaGFuZ2VkXHJcbiAgICAgKiBpdCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZ2F0aGVyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAob2JzZXJ2YXRpb24uaXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5wdXNoKG9ic2VydmF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlcyBpbml0aWFsIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYSBsaXN0IG9mIFJlc2l6ZU9ic2VydmVyRW50cnlcclxuICAgICAqIGluc3RhbmNlcyBjb2xsZWN0ZWQgZnJvbSBhY3RpdmUgcmVzaXplIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmJyb2FkY2FzdEFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIG9ic2VydmVyIGRvZXNuJ3QgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIGlmICghdGhpcy5oYXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNhbGxiYWNrQ3R4XztcclxuICAgICAgICAvLyBDcmVhdGUgUmVzaXplT2JzZXJ2ZXJFbnRyeSBpbnN0YW5jZSBmb3IgZXZlcnkgYWN0aXZlIG9ic2VydmF0aW9uLlxyXG4gICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLm1hcChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlckVudHJ5KG9ic2VydmF0aW9uLnRhcmdldCwgb2JzZXJ2YXRpb24uYnJvYWRjYXN0UmVjdCgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrXy5jYWxsKGN0eCwgZW50cmllcywgY3R4KTtcclxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGNvbGxlY3Rpb24gb2YgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmNsZWFyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5zcGxpY2UoMCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB3aGV0aGVyIG9ic2VydmVyIGhhcyBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuaGFzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJTUEk7XHJcbn0oKSk7XG5cbi8vIFJlZ2lzdHJ5IG9mIGludGVybmFsIG9ic2VydmVycy4gSWYgV2Vha01hcCBpcyBub3QgYXZhaWxhYmxlIHVzZSBjdXJyZW50IHNoaW1cclxuLy8gZm9yIHRoZSBNYXAgY29sbGVjdGlvbiBhcyBpdCBoYXMgYWxsIHJlcXVpcmVkIG1ldGhvZHMgYW5kIGJlY2F1c2UgV2Vha01hcFxyXG4vLyBjYW4ndCBiZSBmdWxseSBwb2x5ZmlsbGVkIGFueXdheS5cclxudmFyIG9ic2VydmVycyA9IHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyA/IG5ldyBXZWFrTWFwKCkgOiBuZXcgTWFwU2hpbSgpO1xyXG4vKipcclxuICogUmVzaXplT2JzZXJ2ZXIgQVBJLiBFbmNhcHN1bGF0ZXMgdGhlIFJlc2l6ZU9ic2VydmVyIFNQSSBpbXBsZW1lbnRhdGlvblxyXG4gKiBleHBvc2luZyBvbmx5IHRob3NlIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgdGhhdCBhcmUgZGVmaW5lZCBpbiB0aGUgc3BlYy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIHdoZW5cclxuICAgICAqICAgICAgZGltZW5zaW9ucyBvZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudHMgY2hhbmdlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlcihjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNpemVPYnNlcnZlcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29udHJvbGxlciA9IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgdGhpcyk7XHJcbiAgICAgICAgb2JzZXJ2ZXJzLnNldCh0aGlzLCBvYnNlcnZlcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXI7XHJcbn0oKSk7XHJcbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcyBvZiBSZXNpemVPYnNlcnZlci5cclxuW1xyXG4gICAgJ29ic2VydmUnLFxyXG4gICAgJ3Vub2JzZXJ2ZScsXHJcbiAgICAnZGlzY29ubmVjdCdcclxuXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcclxuICAgIFJlc2l6ZU9ic2VydmVyLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gb2JzZXJ2ZXJzLmdldCh0aGlzKSlbbWV0aG9kXS5hcHBseShfYSwgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbn0pO1xuXG52YXIgaW5kZXggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gRXhwb3J0IGV4aXN0aW5nIGltcGxlbWVudGF0aW9uIGlmIGF2YWlsYWJsZS5cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsJDEuUmVzaXplT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xyXG59KSgpO1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\n");

/***/ }),

/***/ "../../node_modules/react-grid-layout/css/styles.css":
/*!***********************************************************!*\
  !*** ../../node_modules/react-grid-layout/css/styles.css ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _style_loader_dist_runtime_singletonStyleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../style-loader/dist/runtime/singletonStyleDomAPI.js */ \"../../node_modules/style-loader/dist/runtime/singletonStyleDomAPI.js\");\n/* harmony import */ var _style_loader_dist_runtime_singletonStyleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_singletonStyleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertBySelector.js */ \"../../node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertStyleElement.js */ \"../../node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js!./styles.css */ \"../../node_modules/css-loader/dist/cjs.js!../../node_modules/react-grid-layout/css/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\n;\noptions.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_style_loader_dist_runtime_singletonStyleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"] && _css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"].locals ? _css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"].locals : undefined);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2Nzcy9zdHlsZXMuY3NzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvc3QvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2Nzcy9zdHlsZXMuY3NzPzZjOTIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NpbmdsZXRvblN0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgXG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGVzLmNzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGVzLmNzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/react-grid-layout/css/styles.css\n");

/***/ }),

/***/ "../../node_modules/react-resizable/css/styles.css":
/*!*********************************************************!*\
  !*** ../../node_modules/react-resizable/css/styles.css ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _style_loader_dist_runtime_singletonStyleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../style-loader/dist/runtime/singletonStyleDomAPI.js */ \"../../node_modules/style-loader/dist/runtime/singletonStyleDomAPI.js\");\n/* harmony import */ var _style_loader_dist_runtime_singletonStyleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_singletonStyleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertBySelector.js */ \"../../node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertStyleElement.js */ \"../../node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js!./styles.css */ \"../../node_modules/css-loader/dist/cjs.js!../../node_modules/react-resizable/css/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\n;\noptions.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_style_loader_dist_runtime_singletonStyleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"] && _css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"].locals ? _css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"].locals : undefined);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc2l6YWJsZS9jc3Mvc3R5bGVzLmNzcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNpemFibGUvY3NzL3N0eWxlcy5jc3M/MzM4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2luZ2xldG9uU3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZXMuY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xuXG4gICAgICBvcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xuICAgIFxub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZXMuY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/react-resizable/css/styles.css\n");

/***/ }),

/***/ "../../node_modules/tiny-case/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/tiny-case/index.js ***!
  \*********************************************/
/***/ ((module) => {

eval("const reWords = /[A-Z\\xc0-\\xd6\\xd8-\\xde]?[a-z\\xdf-\\xf6\\xf8-\\xff]+(?:['’](?:d|ll|m|re|s|t|ve))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde]|$)|(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde](?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])|$)|[A-Z\\xc0-\\xd6\\xd8-\\xde]?(?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['’](?:d|ll|m|re|s|t|ve))?|[A-Z\\xc0-\\xd6\\xd8-\\xde]+(?:['’](?:D|LL|M|RE|S|T|VE))?|\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])|\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])|\\d+|(?:[\\u2700-\\u27bf]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?)*/g\n\nconst words = (str) => str.match(reWords) || []\n\nconst upperFirst = (str) => str[0].toUpperCase() + str.slice(1)\n\nconst join = (str, d) => words(str).join(d).toLowerCase()\n\nconst camelCase = (str) =>\n  words(str).reduce(\n    (acc, next) =>\n      `${acc}${\n        !acc\n          ? next.toLowerCase()\n          : next[0].toUpperCase() + next.slice(1).toLowerCase()\n      }`,\n    '',\n  )\n\nconst pascalCase = (str) => upperFirst(camelCase(str))\n\nconst snakeCase = (str) => join(str, '_')\n\nconst kebabCase = (str) => join(str, '-')\n\nconst sentenceCase = (str) => upperFirst(join(str, ' '))\n\nconst titleCase = (str) => words(str).map(upperFirst).join(' ')\n\nmodule.exports = {\n  words,\n  upperFirst,\n  camelCase,\n  pascalCase,\n  snakeCase,\n  kebabCase,\n  sentenceCase,\n  titleCase,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3RpbnktY2FzZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy90aW55LWNhc2UvaW5kZXguanM/YWI2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCByZVdvcmRzID0gL1tBLVpcXHhjMC1cXHhkNlxceGQ4LVxceGRlXT9bYS16XFx4ZGYtXFx4ZjZcXHhmOC1cXHhmZl0rKD86WyfigJldKD86ZHxsbHxtfHJlfHN8dHx2ZSkpPyg/PVtcXHhhY1xceGIxXFx4ZDdcXHhmN1xceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceGJmXFx1MjAwMC1cXHUyMDZmIFxcdFxceDBiXFxmXFx4YTBcXHVmZWZmXFxuXFxyXFx1MjAyOFxcdTIwMjlcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXXxbQS1aXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZV18JCl8KD86W0EtWlxceGMwLVxceGQ2XFx4ZDgtXFx4ZGVdfFteXFx1ZDgwMC1cXHVkZmZmXFx4YWNcXHhiMVxceGQ3XFx4ZjdcXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHhiZlxcdTIwMDAtXFx1MjA2ZiBcXHRcXHgwYlxcZlxceGEwXFx1ZmVmZlxcblxcclxcdTIwMjhcXHUyMDI5XFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcZCtcXHUyNzAwLVxcdTI3YmZhLXpcXHhkZi1cXHhmNlxceGY4LVxceGZmQS1aXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZV0pKyg/Olsn4oCZXSg/OkR8TEx8TXxSRXxTfFR8VkUpKT8oPz1bXFx4YWNcXHhiMVxceGQ3XFx4ZjdcXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHhiZlxcdTIwMDAtXFx1MjA2ZiBcXHRcXHgwYlxcZlxceGEwXFx1ZmVmZlxcblxcclxcdTIwMjhcXHUyMDI5XFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMF18W0EtWlxceGMwLVxceGQ2XFx4ZDgtXFx4ZGVdKD86W2EtelxceGRmLVxceGY2XFx4ZjgtXFx4ZmZdfFteXFx1ZDgwMC1cXHVkZmZmXFx4YWNcXHhiMVxceGQ3XFx4ZjdcXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHhiZlxcdTIwMDAtXFx1MjA2ZiBcXHRcXHgwYlxcZlxceGEwXFx1ZmVmZlxcblxcclxcdTIwMjhcXHUyMDI5XFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcZCtcXHUyNzAwLVxcdTI3YmZhLXpcXHhkZi1cXHhmNlxceGY4LVxceGZmQS1aXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZV0pfCQpfFtBLVpcXHhjMC1cXHhkNlxceGQ4LVxceGRlXT8oPzpbYS16XFx4ZGYtXFx4ZjZcXHhmOC1cXHhmZl18W15cXHVkODAwLVxcdWRmZmZcXHhhY1xceGIxXFx4ZDdcXHhmN1xceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceGJmXFx1MjAwMC1cXHUyMDZmIFxcdFxceDBiXFxmXFx4YTBcXHVmZWZmXFxuXFxyXFx1MjAyOFxcdTIwMjlcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFxkK1xcdTI3MDAtXFx1MjdiZmEtelxceGRmLVxceGY2XFx4ZjgtXFx4ZmZBLVpcXHhjMC1cXHhkNlxceGQ4LVxceGRlXSkrKD86WyfigJldKD86ZHxsbHxtfHJlfHN8dHx2ZSkpP3xbQS1aXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZV0rKD86WyfigJldKD86RHxMTHxNfFJFfFN8VHxWRSkpP3xcXGQqKD86MVNUfDJORHwzUkR8KD8hWzEyM10pXFxkVEgpKD89XFxifFthLXpfXSl8XFxkKig/OjFzdHwybmR8M3JkfCg/IVsxMjNdKVxcZHRoKSg/PVxcYnxbQS1aX10pfFxcZCt8KD86W1xcdTI3MDAtXFx1MjdiZl18KD86XFx1ZDgzY1tcXHVkZGU2LVxcdWRkZmZdKXsyfXxbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdKVtcXHVmZTBlXFx1ZmUwZl0/KD86W1xcdTAzMDAtXFx1MDM2ZlxcdWZlMjAtXFx1ZmUyZlxcdTIwZDAtXFx1MjBmZl18XFx1ZDgzY1tcXHVkZmZiLVxcdWRmZmZdKT8oPzpcXHUyMDBkKD86W15cXHVkODAwLVxcdWRmZmZdfCg/OlxcdWQ4M2NbXFx1ZGRlNi1cXHVkZGZmXSl7Mn18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXSlbXFx1ZmUwZVxcdWZlMGZdPyg/OltcXHUwMzAwLVxcdTAzNmZcXHVmZTIwLVxcdWZlMmZcXHUyMGQwLVxcdTIwZmZdfFxcdWQ4M2NbXFx1ZGZmYi1cXHVkZmZmXSk/KSovZ1xuXG5jb25zdCB3b3JkcyA9IChzdHIpID0+IHN0ci5tYXRjaChyZVdvcmRzKSB8fCBbXVxuXG5jb25zdCB1cHBlckZpcnN0ID0gKHN0cikgPT4gc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcblxuY29uc3Qgam9pbiA9IChzdHIsIGQpID0+IHdvcmRzKHN0cikuam9pbihkKS50b0xvd2VyQ2FzZSgpXG5cbmNvbnN0IGNhbWVsQ2FzZSA9IChzdHIpID0+XG4gIHdvcmRzKHN0cikucmVkdWNlKFxuICAgIChhY2MsIG5leHQpID0+XG4gICAgICBgJHthY2N9JHtcbiAgICAgICAgIWFjY1xuICAgICAgICAgID8gbmV4dC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgOiBuZXh0WzBdLnRvVXBwZXJDYXNlKCkgKyBuZXh0LnNsaWNlKDEpLnRvTG93ZXJDYXNlKClcbiAgICAgIH1gLFxuICAgICcnLFxuICApXG5cbmNvbnN0IHBhc2NhbENhc2UgPSAoc3RyKSA9PiB1cHBlckZpcnN0KGNhbWVsQ2FzZShzdHIpKVxuXG5jb25zdCBzbmFrZUNhc2UgPSAoc3RyKSA9PiBqb2luKHN0ciwgJ18nKVxuXG5jb25zdCBrZWJhYkNhc2UgPSAoc3RyKSA9PiBqb2luKHN0ciwgJy0nKVxuXG5jb25zdCBzZW50ZW5jZUNhc2UgPSAoc3RyKSA9PiB1cHBlckZpcnN0KGpvaW4oc3RyLCAnICcpKVxuXG5jb25zdCB0aXRsZUNhc2UgPSAoc3RyKSA9PiB3b3JkcyhzdHIpLm1hcCh1cHBlckZpcnN0KS5qb2luKCcgJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHdvcmRzLFxuICB1cHBlckZpcnN0LFxuICBjYW1lbENhc2UsXG4gIHBhc2NhbENhc2UsXG4gIHNuYWtlQ2FzZSxcbiAga2ViYWJDYXNlLFxuICBzZW50ZW5jZUNhc2UsXG4gIHRpdGxlQ2FzZSxcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/tiny-case/index.js\n");

/***/ }),

/***/ "../../node_modules/toposort/index.js":
/*!********************************************!*\
  !*** ../../node_modules/toposort/index.js ***!
  \********************************************/
/***/ ((module) => {

eval("\n/**\n * Topological sorting function\n *\n * @param {Array} edges\n * @returns {Array}\n */\n\nmodule.exports = function(edges) {\n  return toposort(uniqueNodes(edges), edges)\n}\n\nmodule.exports.array = toposort\n\nfunction toposort(nodes, edges) {\n  var cursor = nodes.length\n    , sorted = new Array(cursor)\n    , visited = {}\n    , i = cursor\n    // Better data structures make algorithm much faster.\n    , outgoingEdges = makeOutgoingEdges(edges)\n    , nodesHash = makeNodesHash(nodes)\n\n  // check for unknown nodes\n  edges.forEach(function(edge) {\n    if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {\n      throw new Error('Unknown node. There is an unknown node in the supplied edges.')\n    }\n  })\n\n  while (i--) {\n    if (!visited[i]) visit(nodes[i], i, new Set())\n  }\n\n  return sorted\n\n  function visit(node, i, predecessors) {\n    if(predecessors.has(node)) {\n      var nodeRep\n      try {\n        nodeRep = \", node was:\" + JSON.stringify(node)\n      } catch(e) {\n        nodeRep = \"\"\n      }\n      throw new Error('Cyclic dependency' + nodeRep)\n    }\n\n    if (!nodesHash.has(node)) {\n      throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: '+JSON.stringify(node))\n    }\n\n    if (visited[i]) return;\n    visited[i] = true\n\n    var outgoing = outgoingEdges.get(node) || new Set()\n    outgoing = Array.from(outgoing)\n\n    if (i = outgoing.length) {\n      predecessors.add(node)\n      do {\n        var child = outgoing[--i]\n        visit(child, nodesHash.get(child), predecessors)\n      } while (i)\n      predecessors.delete(node)\n    }\n\n    sorted[--cursor] = node\n  }\n}\n\nfunction uniqueNodes(arr){\n  var res = new Set()\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var edge = arr[i]\n    res.add(edge[0])\n    res.add(edge[1])\n  }\n  return Array.from(res)\n}\n\nfunction makeOutgoingEdges(arr){\n  var edges = new Map()\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var edge = arr[i]\n    if (!edges.has(edge[0])) edges.set(edge[0], new Set())\n    if (!edges.has(edge[1])) edges.set(edge[1], new Set())\n    edges.get(edge[0]).add(edge[1])\n  }\n  return edges\n}\n\nfunction makeNodesHash(arr){\n  var res = new Map()\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res.set(arr[i], i)\n  }\n  return res\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3RvcG9zb3J0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob3N0Ly4uLy4uL25vZGVfbW9kdWxlcy90b3Bvc29ydC9pbmRleC5qcz81NGQyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUb3BvbG9naWNhbCBzb3J0aW5nIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZWRnZXNcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVkZ2VzKSB7XG4gIHJldHVybiB0b3Bvc29ydCh1bmlxdWVOb2RlcyhlZGdlcyksIGVkZ2VzKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5hcnJheSA9IHRvcG9zb3J0XG5cbmZ1bmN0aW9uIHRvcG9zb3J0KG5vZGVzLCBlZGdlcykge1xuICB2YXIgY3Vyc29yID0gbm9kZXMubGVuZ3RoXG4gICAgLCBzb3J0ZWQgPSBuZXcgQXJyYXkoY3Vyc29yKVxuICAgICwgdmlzaXRlZCA9IHt9XG4gICAgLCBpID0gY3Vyc29yXG4gICAgLy8gQmV0dGVyIGRhdGEgc3RydWN0dXJlcyBtYWtlIGFsZ29yaXRobSBtdWNoIGZhc3Rlci5cbiAgICAsIG91dGdvaW5nRWRnZXMgPSBtYWtlT3V0Z29pbmdFZGdlcyhlZGdlcylcbiAgICAsIG5vZGVzSGFzaCA9IG1ha2VOb2Rlc0hhc2gobm9kZXMpXG5cbiAgLy8gY2hlY2sgZm9yIHVua25vd24gbm9kZXNcbiAgZWRnZXMuZm9yRWFjaChmdW5jdGlvbihlZGdlKSB7XG4gICAgaWYgKCFub2Rlc0hhc2guaGFzKGVkZ2VbMF0pIHx8ICFub2Rlc0hhc2guaGFzKGVkZ2VbMV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZS4gVGhlcmUgaXMgYW4gdW5rbm93biBub2RlIGluIHRoZSBzdXBwbGllZCBlZGdlcy4nKVxuICAgIH1cbiAgfSlcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKCF2aXNpdGVkW2ldKSB2aXNpdChub2Rlc1tpXSwgaSwgbmV3IFNldCgpKVxuICB9XG5cbiAgcmV0dXJuIHNvcnRlZFxuXG4gIGZ1bmN0aW9uIHZpc2l0KG5vZGUsIGksIHByZWRlY2Vzc29ycykge1xuICAgIGlmKHByZWRlY2Vzc29ycy5oYXMobm9kZSkpIHtcbiAgICAgIHZhciBub2RlUmVwXG4gICAgICB0cnkge1xuICAgICAgICBub2RlUmVwID0gXCIsIG5vZGUgd2FzOlwiICsgSlNPTi5zdHJpbmdpZnkobm9kZSlcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBub2RlUmVwID0gXCJcIlxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDeWNsaWMgZGVwZW5kZW5jeScgKyBub2RlUmVwKVxuICAgIH1cblxuICAgIGlmICghbm9kZXNIYXNoLmhhcyhub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1bmtub3duIG5vZGUuIE1ha2Ugc3VyZSB0byBwcm92aWRlZCBhbGwgaW52b2x2ZWQgbm9kZXMuIFVua25vd24gbm9kZTogJytKU09OLnN0cmluZ2lmeShub2RlKSlcbiAgICB9XG5cbiAgICBpZiAodmlzaXRlZFtpXSkgcmV0dXJuO1xuICAgIHZpc2l0ZWRbaV0gPSB0cnVlXG5cbiAgICB2YXIgb3V0Z29pbmcgPSBvdXRnb2luZ0VkZ2VzLmdldChub2RlKSB8fCBuZXcgU2V0KClcbiAgICBvdXRnb2luZyA9IEFycmF5LmZyb20ob3V0Z29pbmcpXG5cbiAgICBpZiAoaSA9IG91dGdvaW5nLmxlbmd0aCkge1xuICAgICAgcHJlZGVjZXNzb3JzLmFkZChub2RlKVxuICAgICAgZG8ge1xuICAgICAgICB2YXIgY2hpbGQgPSBvdXRnb2luZ1stLWldXG4gICAgICAgIHZpc2l0KGNoaWxkLCBub2Rlc0hhc2guZ2V0KGNoaWxkKSwgcHJlZGVjZXNzb3JzKVxuICAgICAgfSB3aGlsZSAoaSlcbiAgICAgIHByZWRlY2Vzc29ycy5kZWxldGUobm9kZSlcbiAgICB9XG5cbiAgICBzb3J0ZWRbLS1jdXJzb3JdID0gbm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZU5vZGVzKGFycil7XG4gIHZhciByZXMgPSBuZXcgU2V0KClcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBlZGdlID0gYXJyW2ldXG4gICAgcmVzLmFkZChlZGdlWzBdKVxuICAgIHJlcy5hZGQoZWRnZVsxXSlcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShyZXMpXG59XG5cbmZ1bmN0aW9uIG1ha2VPdXRnb2luZ0VkZ2VzKGFycil7XG4gIHZhciBlZGdlcyA9IG5ldyBNYXAoKVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGVkZ2UgPSBhcnJbaV1cbiAgICBpZiAoIWVkZ2VzLmhhcyhlZGdlWzBdKSkgZWRnZXMuc2V0KGVkZ2VbMF0sIG5ldyBTZXQoKSlcbiAgICBpZiAoIWVkZ2VzLmhhcyhlZGdlWzFdKSkgZWRnZXMuc2V0KGVkZ2VbMV0sIG5ldyBTZXQoKSlcbiAgICBlZGdlcy5nZXQoZWRnZVswXSkuYWRkKGVkZ2VbMV0pXG4gIH1cbiAgcmV0dXJuIGVkZ2VzXG59XG5cbmZ1bmN0aW9uIG1ha2VOb2Rlc0hhc2goYXJyKXtcbiAgdmFyIHJlcyA9IG5ldyBNYXAoKVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzLnNldChhcnJbaV0sIGkpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/toposort/index.js\n");

/***/ }),

/***/ "../../node_modules/yup/index.esm.js":
/*!*******************************************!*\
  !*** ../../node_modules/yup/index.esm.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArraySchema: () => (/* binding */ ArraySchema),\n/* harmony export */   BooleanSchema: () => (/* binding */ BooleanSchema),\n/* harmony export */   DateSchema: () => (/* binding */ DateSchema),\n/* harmony export */   LazySchema: () => (/* binding */ Lazy),\n/* harmony export */   MixedSchema: () => (/* binding */ MixedSchema),\n/* harmony export */   NumberSchema: () => (/* binding */ NumberSchema),\n/* harmony export */   ObjectSchema: () => (/* binding */ ObjectSchema),\n/* harmony export */   Schema: () => (/* binding */ Schema),\n/* harmony export */   StringSchema: () => (/* binding */ StringSchema),\n/* harmony export */   TupleSchema: () => (/* binding */ TupleSchema),\n/* harmony export */   ValidationError: () => (/* binding */ ValidationError),\n/* harmony export */   addMethod: () => (/* binding */ addMethod),\n/* harmony export */   array: () => (/* binding */ create$2),\n/* harmony export */   bool: () => (/* binding */ create$7),\n/* harmony export */   boolean: () => (/* binding */ create$7),\n/* harmony export */   date: () => (/* binding */ create$4),\n/* harmony export */   defaultLocale: () => (/* binding */ locale),\n/* harmony export */   getIn: () => (/* binding */ getIn),\n/* harmony export */   isSchema: () => (/* binding */ isSchema),\n/* harmony export */   lazy: () => (/* binding */ create),\n/* harmony export */   mixed: () => (/* binding */ create$8),\n/* harmony export */   number: () => (/* binding */ create$5),\n/* harmony export */   object: () => (/* binding */ create$3),\n/* harmony export */   printValue: () => (/* binding */ printValue),\n/* harmony export */   reach: () => (/* binding */ reach),\n/* harmony export */   ref: () => (/* binding */ create$9),\n/* harmony export */   setLocale: () => (/* binding */ setLocale),\n/* harmony export */   string: () => (/* binding */ create$6),\n/* harmony export */   tuple: () => (/* binding */ create$1)\n/* harmony export */ });\n/* harmony import */ var property_expr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! property-expr */ \"../../node_modules/property-expr/index.js\");\n/* harmony import */ var property_expr__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(property_expr__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var tiny_case__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-case */ \"../../node_modules/tiny-case/index.js\");\n/* harmony import */ var tiny_case__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tiny_case__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var toposort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! toposort */ \"../../node_modules/toposort/index.js\");\n/* harmony import */ var toposort__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(toposort__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nconst toString = Object.prototype.toString;\nconst errorToString = Error.prototype.toString;\nconst regExpToString = RegExp.prototype.toString;\nconst symbolToString = typeof Symbol !== 'undefined' ? Symbol.prototype.toString : () => '';\nconst SYMBOL_REGEXP = /^Symbol\\((.*)\\)(.*)$/;\nfunction printNumber(val) {\n  if (val != +val) return 'NaN';\n  const isNegativeZero = val === 0 && 1 / val < 0;\n  return isNegativeZero ? '-0' : '' + val;\n}\nfunction printSimpleValue(val, quoteStrings = false) {\n  if (val == null || val === true || val === false) return '' + val;\n  const typeOf = typeof val;\n  if (typeOf === 'number') return printNumber(val);\n  if (typeOf === 'string') return quoteStrings ? `\"${val}\"` : val;\n  if (typeOf === 'function') return '[Function ' + (val.name || 'anonymous') + ']';\n  if (typeOf === 'symbol') return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');\n  const tag = toString.call(val).slice(8, -1);\n  if (tag === 'Date') return isNaN(val.getTime()) ? '' + val : val.toISOString(val);\n  if (tag === 'Error' || val instanceof Error) return '[' + errorToString.call(val) + ']';\n  if (tag === 'RegExp') return regExpToString.call(val);\n  return null;\n}\nfunction printValue(value, quoteStrings) {\n  let result = printSimpleValue(value, quoteStrings);\n  if (result !== null) return result;\n  return JSON.stringify(value, function (key, value) {\n    let result = printSimpleValue(this[key], quoteStrings);\n    if (result !== null) return result;\n    return value;\n  }, 2);\n}\n\nfunction toArray(value) {\n  return value == null ? [] : [].concat(value);\n}\n\nlet _Symbol$toStringTag, _Symbol$hasInstance, _Symbol$toStringTag2;\nlet strReg = /\\$\\{\\s*(\\w+)\\s*\\}/g;\n_Symbol$toStringTag = Symbol.toStringTag;\nclass ValidationErrorNoStack {\n  constructor(errorOrErrors, value, field, type) {\n    this.name = void 0;\n    this.message = void 0;\n    this.value = void 0;\n    this.path = void 0;\n    this.type = void 0;\n    this.params = void 0;\n    this.errors = void 0;\n    this.inner = void 0;\n    this[_Symbol$toStringTag] = 'Error';\n    this.name = 'ValidationError';\n    this.value = value;\n    this.path = field;\n    this.type = type;\n    this.errors = [];\n    this.inner = [];\n    toArray(errorOrErrors).forEach(err => {\n      if (ValidationError.isError(err)) {\n        this.errors.push(...err.errors);\n        const innerErrors = err.inner.length ? err.inner : [err];\n        this.inner.push(...innerErrors);\n      } else {\n        this.errors.push(err);\n      }\n    });\n    this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];\n  }\n}\n_Symbol$hasInstance = Symbol.hasInstance;\n_Symbol$toStringTag2 = Symbol.toStringTag;\nclass ValidationError extends Error {\n  static formatError(message, params) {\n    // Attempt to make the path more friendly for error message interpolation.\n    const path = params.label || params.path || 'this';\n    // Store the original path under `originalPath` so it isn't lost to custom\n    // message functions; e.g., ones provided in `setLocale()` calls.\n    params = Object.assign({}, params, {\n      path,\n      originalPath: params.path\n    });\n    if (typeof message === 'string') return message.replace(strReg, (_, key) => printValue(params[key]));\n    if (typeof message === 'function') return message(params);\n    return message;\n  }\n  static isError(err) {\n    return err && err.name === 'ValidationError';\n  }\n  constructor(errorOrErrors, value, field, type, disableStack) {\n    const errorNoStack = new ValidationErrorNoStack(errorOrErrors, value, field, type);\n    if (disableStack) {\n      return errorNoStack;\n    }\n    super();\n    this.value = void 0;\n    this.path = void 0;\n    this.type = void 0;\n    this.params = void 0;\n    this.errors = [];\n    this.inner = [];\n    this[_Symbol$toStringTag2] = 'Error';\n    this.name = errorNoStack.name;\n    this.message = errorNoStack.message;\n    this.type = errorNoStack.type;\n    this.value = errorNoStack.value;\n    this.path = errorNoStack.path;\n    this.errors = errorNoStack.errors;\n    this.inner = errorNoStack.inner;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ValidationError);\n    }\n  }\n  static [_Symbol$hasInstance](inst) {\n    return ValidationErrorNoStack[Symbol.hasInstance](inst) || super[Symbol.hasInstance](inst);\n  }\n}\n\nlet mixed = {\n  default: '${path} is invalid',\n  required: '${path} is a required field',\n  defined: '${path} must be defined',\n  notNull: '${path} cannot be null',\n  oneOf: '${path} must be one of the following values: ${values}',\n  notOneOf: '${path} must not be one of the following values: ${values}',\n  notType: ({\n    path,\n    type,\n    value,\n    originalValue\n  }) => {\n    const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \\`${printValue(originalValue, true)}\\`).` : '.';\n    return type !== 'mixed' ? `${path} must be a \\`${type}\\` type, ` + `but the final value was: \\`${printValue(value, true)}\\`` + castMsg : `${path} must match the configured type. ` + `The validated value was: \\`${printValue(value, true)}\\`` + castMsg;\n  }\n};\nlet string = {\n  length: '${path} must be exactly ${length} characters',\n  min: '${path} must be at least ${min} characters',\n  max: '${path} must be at most ${max} characters',\n  matches: '${path} must match the following: \"${regex}\"',\n  email: '${path} must be a valid email',\n  url: '${path} must be a valid URL',\n  uuid: '${path} must be a valid UUID',\n  datetime: '${path} must be a valid ISO date-time',\n  datetime_precision: '${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits',\n  datetime_offset: '${path} must be a valid ISO date-time with UTC \"Z\" timezone',\n  trim: '${path} must be a trimmed string',\n  lowercase: '${path} must be a lowercase string',\n  uppercase: '${path} must be a upper case string'\n};\nlet number = {\n  min: '${path} must be greater than or equal to ${min}',\n  max: '${path} must be less than or equal to ${max}',\n  lessThan: '${path} must be less than ${less}',\n  moreThan: '${path} must be greater than ${more}',\n  positive: '${path} must be a positive number',\n  negative: '${path} must be a negative number',\n  integer: '${path} must be an integer'\n};\nlet date = {\n  min: '${path} field must be later than ${min}',\n  max: '${path} field must be at earlier than ${max}'\n};\nlet boolean = {\n  isValue: '${path} field must be ${value}'\n};\nlet object = {\n  noUnknown: '${path} field has unspecified keys: ${unknown}',\n  exact: '${path} object contains unknown properties: ${properties}'\n};\nlet array = {\n  min: '${path} field must have at least ${min} items',\n  max: '${path} field must have less than or equal to ${max} items',\n  length: '${path} must have ${length} items'\n};\nlet tuple = {\n  notType: params => {\n    const {\n      path,\n      value,\n      spec\n    } = params;\n    const typeLen = spec.types.length;\n    if (Array.isArray(value)) {\n      if (value.length < typeLen) return `${path} tuple value has too few items, expected a length of ${typeLen} but got ${value.length} for value: \\`${printValue(value, true)}\\``;\n      if (value.length > typeLen) return `${path} tuple value has too many items, expected a length of ${typeLen} but got ${value.length} for value: \\`${printValue(value, true)}\\``;\n    }\n    return ValidationError.formatError(mixed.notType, params);\n  }\n};\nvar locale = Object.assign(Object.create(null), {\n  mixed,\n  string,\n  number,\n  date,\n  object,\n  array,\n  boolean,\n  tuple\n});\n\nconst isSchema = obj => obj && obj.__isYupSchema__;\n\nclass Condition {\n  static fromOptions(refs, config) {\n    if (!config.then && !config.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');\n    let {\n      is,\n      then,\n      otherwise\n    } = config;\n    let check = typeof is === 'function' ? is : (...values) => values.every(value => value === is);\n    return new Condition(refs, (values, schema) => {\n      var _branch;\n      let branch = check(...values) ? then : otherwise;\n      return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;\n    });\n  }\n  constructor(refs, builder) {\n    this.fn = void 0;\n    this.refs = refs;\n    this.refs = refs;\n    this.fn = builder;\n  }\n  resolve(base, options) {\n    let values = this.refs.map(ref =>\n    // TODO: ? operator here?\n    ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));\n    let schema = this.fn(values, base, options);\n    if (schema === undefined ||\n    // @ts-ignore this can be base\n    schema === base) {\n      return base;\n    }\n    if (!isSchema(schema)) throw new TypeError('conditions must return a schema object');\n    return schema.resolve(options);\n  }\n}\n\nconst prefixes = {\n  context: '$',\n  value: '.'\n};\nfunction create$9(key, options) {\n  return new Reference(key, options);\n}\nclass Reference {\n  constructor(key, options = {}) {\n    this.key = void 0;\n    this.isContext = void 0;\n    this.isValue = void 0;\n    this.isSibling = void 0;\n    this.path = void 0;\n    this.getter = void 0;\n    this.map = void 0;\n    if (typeof key !== 'string') throw new TypeError('ref must be a string, got: ' + key);\n    this.key = key.trim();\n    if (key === '') throw new TypeError('ref must be a non-empty string');\n    this.isContext = this.key[0] === prefixes.context;\n    this.isValue = this.key[0] === prefixes.value;\n    this.isSibling = !this.isContext && !this.isValue;\n    let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : '';\n    this.path = this.key.slice(prefix.length);\n    this.getter = this.path && (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)(this.path, true);\n    this.map = options.map;\n  }\n  getValue(value, parent, context) {\n    let result = this.isContext ? context : this.isValue ? value : parent;\n    if (this.getter) result = this.getter(result || {});\n    if (this.map) result = this.map(result);\n    return result;\n  }\n\n  /**\n   *\n   * @param {*} value\n   * @param {Object} options\n   * @param {Object=} options.context\n   * @param {Object=} options.parent\n   */\n  cast(value, options) {\n    return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);\n  }\n  resolve() {\n    return this;\n  }\n  describe() {\n    return {\n      type: 'ref',\n      key: this.key\n    };\n  }\n  toString() {\n    return `Ref(${this.key})`;\n  }\n  static isRef(value) {\n    return value && value.__isYupRef;\n  }\n}\n\n// @ts-ignore\nReference.prototype.__isYupRef = true;\n\nconst isAbsent = value => value == null;\n\nfunction createValidation(config) {\n  function validate({\n    value,\n    path = '',\n    options,\n    originalValue,\n    schema\n  }, panic, next) {\n    const {\n      name,\n      test,\n      params,\n      message,\n      skipAbsent\n    } = config;\n    let {\n      parent,\n      context,\n      abortEarly = schema.spec.abortEarly,\n      disableStackTrace = schema.spec.disableStackTrace\n    } = options;\n    function resolve(item) {\n      return Reference.isRef(item) ? item.getValue(value, parent, context) : item;\n    }\n    function createError(overrides = {}) {\n      const nextParams = Object.assign({\n        value,\n        originalValue,\n        label: schema.spec.label,\n        path: overrides.path || path,\n        spec: schema.spec,\n        disableStackTrace: overrides.disableStackTrace || disableStackTrace\n      }, params, overrides.params);\n      for (const key of Object.keys(nextParams)) nextParams[key] = resolve(nextParams[key]);\n      const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name, nextParams.disableStackTrace);\n      error.params = nextParams;\n      return error;\n    }\n    const invalid = abortEarly ? panic : next;\n    let ctx = {\n      path,\n      parent,\n      type: name,\n      from: options.from,\n      createError,\n      resolve,\n      options,\n      originalValue,\n      schema\n    };\n    const handleResult = validOrError => {\n      if (ValidationError.isError(validOrError)) invalid(validOrError);else if (!validOrError) invalid(createError());else next(null);\n    };\n    const handleError = err => {\n      if (ValidationError.isError(err)) invalid(err);else panic(err);\n    };\n    const shouldSkip = skipAbsent && isAbsent(value);\n    if (shouldSkip) {\n      return handleResult(true);\n    }\n    let result;\n    try {\n      var _result;\n      result = test.call(ctx, value, ctx);\n      if (typeof ((_result = result) == null ? void 0 : _result.then) === 'function') {\n        if (options.sync) {\n          throw new Error(`Validation test of type: \"${ctx.type}\" returned a Promise during a synchronous validate. ` + `This test will finish after the validate call has returned`);\n        }\n        return Promise.resolve(result).then(handleResult, handleError);\n      }\n    } catch (err) {\n      handleError(err);\n      return;\n    }\n    handleResult(result);\n  }\n  validate.OPTIONS = config;\n  return validate;\n}\n\nfunction getIn(schema, path, value, context = value) {\n  let parent, lastPart, lastPartDebug;\n\n  // root path: ''\n  if (!path) return {\n    parent,\n    parentPath: path,\n    schema\n  };\n  (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.forEach)(path, (_part, isBracket, isArray) => {\n    let part = isBracket ? _part.slice(1, _part.length - 1) : _part;\n    schema = schema.resolve({\n      context,\n      parent,\n      value\n    });\n    let isTuple = schema.type === 'tuple';\n    let idx = isArray ? parseInt(part, 10) : 0;\n    if (schema.innerType || isTuple) {\n      if (isTuple && !isArray) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part \"${lastPartDebug}\" must contain an index to the tuple element, e.g. \"${lastPartDebug}[0]\"`);\n      if (value && idx >= value.length) {\n        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. ` + `because there is no value at that index. `);\n      }\n      parent = value;\n      value = value && value[idx];\n      schema = isTuple ? schema.spec.types[idx] : schema.innerType;\n    }\n\n    // sometimes the array index part of a path doesn't exist: \"nested.arr.child\"\n    // in these cases the current part is the next schema and should be processed\n    // in this iteration. For cases where the index signature is included this\n    // check will fail and we'll handle the `child` part on the next iteration like normal\n    if (!isArray) {\n      if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. ` + `(failed at: ${lastPartDebug} which is a type: \"${schema.type}\")`);\n      parent = value;\n      value = value && value[part];\n      schema = schema.fields[part];\n    }\n    lastPart = part;\n    lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;\n  });\n  return {\n    schema,\n    parent,\n    parentPath: lastPart\n  };\n}\nfunction reach(obj, path, value, context) {\n  return getIn(obj, path, value, context).schema;\n}\n\nclass ReferenceSet extends Set {\n  describe() {\n    const description = [];\n    for (const item of this.values()) {\n      description.push(Reference.isRef(item) ? item.describe() : item);\n    }\n    return description;\n  }\n  resolveAll(resolve) {\n    let result = [];\n    for (const item of this.values()) {\n      result.push(resolve(item));\n    }\n    return result;\n  }\n  clone() {\n    return new ReferenceSet(this.values());\n  }\n  merge(newItems, removeItems) {\n    const next = this.clone();\n    newItems.forEach(value => next.add(value));\n    removeItems.forEach(value => next.delete(value));\n    return next;\n  }\n}\n\n// tweaked from https://github.com/Kelin2025/nanoclone/blob/0abeb7635bda9b68ef2277093f76dbe3bf3948e1/src/index.js\nfunction clone(src, seen = new Map()) {\n  if (isSchema(src) || !src || typeof src !== 'object') return src;\n  if (seen.has(src)) return seen.get(src);\n  let copy;\n  if (src instanceof Date) {\n    // Date\n    copy = new Date(src.getTime());\n    seen.set(src, copy);\n  } else if (src instanceof RegExp) {\n    // RegExp\n    copy = new RegExp(src);\n    seen.set(src, copy);\n  } else if (Array.isArray(src)) {\n    // Array\n    copy = new Array(src.length);\n    seen.set(src, copy);\n    for (let i = 0; i < src.length; i++) copy[i] = clone(src[i], seen);\n  } else if (src instanceof Map) {\n    // Map\n    copy = new Map();\n    seen.set(src, copy);\n    for (const [k, v] of src.entries()) copy.set(k, clone(v, seen));\n  } else if (src instanceof Set) {\n    // Set\n    copy = new Set();\n    seen.set(src, copy);\n    for (const v of src) copy.add(clone(v, seen));\n  } else if (src instanceof Object) {\n    // Object\n    copy = {};\n    seen.set(src, copy);\n    for (const [k, v] of Object.entries(src)) copy[k] = clone(v, seen);\n  } else {\n    throw Error(`Unable to clone ${src}`);\n  }\n  return copy;\n}\n\n// If `CustomSchemaMeta` isn't extended with any keys, we'll fall back to a\n// loose Record definition allowing free form usage.\nclass Schema {\n  constructor(options) {\n    this.type = void 0;\n    this.deps = [];\n    this.tests = void 0;\n    this.transforms = void 0;\n    this.conditions = [];\n    this._mutate = void 0;\n    this.internalTests = {};\n    this._whitelist = new ReferenceSet();\n    this._blacklist = new ReferenceSet();\n    this.exclusiveTests = Object.create(null);\n    this._typeCheck = void 0;\n    this.spec = void 0;\n    this.tests = [];\n    this.transforms = [];\n    this.withMutation(() => {\n      this.typeError(mixed.notType);\n    });\n    this.type = options.type;\n    this._typeCheck = options.check;\n    this.spec = Object.assign({\n      strip: false,\n      strict: false,\n      abortEarly: true,\n      recursive: true,\n      disableStackTrace: false,\n      nullable: false,\n      optional: true,\n      coerce: true\n    }, options == null ? void 0 : options.spec);\n    this.withMutation(s => {\n      s.nonNullable();\n    });\n  }\n\n  // TODO: remove\n  get _type() {\n    return this.type;\n  }\n  clone(spec) {\n    if (this._mutate) {\n      if (spec) Object.assign(this.spec, spec);\n      return this;\n    }\n\n    // if the nested value is a schema we can skip cloning, since\n    // they are already immutable\n    const next = Object.create(Object.getPrototypeOf(this));\n\n    // @ts-expect-error this is readonly\n    next.type = this.type;\n    next._typeCheck = this._typeCheck;\n    next._whitelist = this._whitelist.clone();\n    next._blacklist = this._blacklist.clone();\n    next.internalTests = Object.assign({}, this.internalTests);\n    next.exclusiveTests = Object.assign({}, this.exclusiveTests);\n\n    // @ts-expect-error this is readonly\n    next.deps = [...this.deps];\n    next.conditions = [...this.conditions];\n    next.tests = [...this.tests];\n    next.transforms = [...this.transforms];\n    next.spec = clone(Object.assign({}, this.spec, spec));\n    return next;\n  }\n  label(label) {\n    let next = this.clone();\n    next.spec.label = label;\n    return next;\n  }\n  meta(...args) {\n    if (args.length === 0) return this.spec.meta;\n    let next = this.clone();\n    next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);\n    return next;\n  }\n  withMutation(fn) {\n    let before = this._mutate;\n    this._mutate = true;\n    let result = fn(this);\n    this._mutate = before;\n    return result;\n  }\n  concat(schema) {\n    if (!schema || schema === this) return this;\n    if (schema.type !== this.type && this.type !== 'mixed') throw new TypeError(`You cannot \\`concat()\\` schema's of different types: ${this.type} and ${schema.type}`);\n    let base = this;\n    let combined = schema.clone();\n    const mergedSpec = Object.assign({}, base.spec, combined.spec);\n    combined.spec = mergedSpec;\n    combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);\n\n    // manually merge the blacklist/whitelist (the other `schema` takes\n    // precedence in case of conflicts)\n    combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);\n    combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);\n\n    // start with the current tests\n    combined.tests = base.tests;\n    combined.exclusiveTests = base.exclusiveTests;\n\n    // manually add the new tests to ensure\n    // the deduping logic is consistent\n    combined.withMutation(next => {\n      schema.tests.forEach(fn => {\n        next.test(fn.OPTIONS);\n      });\n    });\n    combined.transforms = [...base.transforms, ...combined.transforms];\n    return combined;\n  }\n  isType(v) {\n    if (v == null) {\n      if (this.spec.nullable && v === null) return true;\n      if (this.spec.optional && v === undefined) return true;\n      return false;\n    }\n    return this._typeCheck(v);\n  }\n  resolve(options) {\n    let schema = this;\n    if (schema.conditions.length) {\n      let conditions = schema.conditions;\n      schema = schema.clone();\n      schema.conditions = [];\n      schema = conditions.reduce((prevSchema, condition) => condition.resolve(prevSchema, options), schema);\n      schema = schema.resolve(options);\n    }\n    return schema;\n  }\n  resolveOptions(options) {\n    var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;\n    return Object.assign({}, options, {\n      from: options.from || [],\n      strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,\n      abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,\n      recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive,\n      disableStackTrace: (_options$disableStack = options.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace\n    });\n  }\n\n  /**\n   * Run the configured transform pipeline over an input value.\n   */\n\n  cast(value, options = {}) {\n    let resolvedSchema = this.resolve(Object.assign({\n      value\n    }, options));\n    let allowOptionality = options.assert === 'ignore-optionality';\n    let result = resolvedSchema._cast(value, options);\n    if (options.assert !== false && !resolvedSchema.isType(result)) {\n      if (allowOptionality && isAbsent(result)) {\n        return result;\n      }\n      let formattedValue = printValue(value);\n      let formattedResult = printValue(result);\n      throw new TypeError(`The value of ${options.path || 'field'} could not be cast to a value ` + `that satisfies the schema type: \"${resolvedSchema.type}\". \\n\\n` + `attempted value: ${formattedValue} \\n` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ''));\n    }\n    return result;\n  }\n  _cast(rawValue, options) {\n    let value = rawValue === undefined ? rawValue : this.transforms.reduce((prevValue, fn) => fn.call(this, prevValue, rawValue, this), rawValue);\n    if (value === undefined) {\n      value = this.getDefault(options);\n    }\n    return value;\n  }\n  _validate(_value, options = {}, panic, next) {\n    let {\n      path,\n      originalValue = _value,\n      strict = this.spec.strict\n    } = options;\n    let value = _value;\n    if (!strict) {\n      value = this._cast(value, Object.assign({\n        assert: false\n      }, options));\n    }\n    let initialTests = [];\n    for (let test of Object.values(this.internalTests)) {\n      if (test) initialTests.push(test);\n    }\n    this.runTests({\n      path,\n      value,\n      originalValue,\n      options,\n      tests: initialTests\n    }, panic, initialErrors => {\n      // even if we aren't ending early we can't proceed further if the types aren't correct\n      if (initialErrors.length) {\n        return next(initialErrors, value);\n      }\n      this.runTests({\n        path,\n        value,\n        originalValue,\n        options,\n        tests: this.tests\n      }, panic, next);\n    });\n  }\n\n  /**\n   * Executes a set of validations, either schema, produced Tests or a nested\n   * schema validate result.\n   */\n  runTests(runOptions, panic, next) {\n    let fired = false;\n    let {\n      tests,\n      value,\n      originalValue,\n      path,\n      options\n    } = runOptions;\n    let panicOnce = arg => {\n      if (fired) return;\n      fired = true;\n      panic(arg, value);\n    };\n    let nextOnce = arg => {\n      if (fired) return;\n      fired = true;\n      next(arg, value);\n    };\n    let count = tests.length;\n    let nestedErrors = [];\n    if (!count) return nextOnce([]);\n    let args = {\n      value,\n      originalValue,\n      path,\n      options,\n      schema: this\n    };\n    for (let i = 0; i < tests.length; i++) {\n      const test = tests[i];\n      test(args, panicOnce, function finishTestRun(err) {\n        if (err) {\n          Array.isArray(err) ? nestedErrors.push(...err) : nestedErrors.push(err);\n        }\n        if (--count <= 0) {\n          nextOnce(nestedErrors);\n        }\n      });\n    }\n  }\n  asNestedTest({\n    key,\n    index,\n    parent,\n    parentPath,\n    originalParent,\n    options\n  }) {\n    const k = key != null ? key : index;\n    if (k == null) {\n      throw TypeError('Must include `key` or `index` for nested validations');\n    }\n    const isIndex = typeof k === 'number';\n    let value = parent[k];\n    const testOptions = Object.assign({}, options, {\n      // Nested validations fields are always strict:\n      //    1. parent isn't strict so the casting will also have cast inner values\n      //    2. parent is strict in which case the nested values weren't cast either\n      strict: true,\n      parent,\n      value,\n      originalValue: originalParent[k],\n      // FIXME: tests depend on `index` being passed around deeply,\n      //   we should not let the options.key/index bleed through\n      key: undefined,\n      // index: undefined,\n      [isIndex ? 'index' : 'key']: k,\n      path: isIndex || k.includes('.') ? `${parentPath || ''}[${isIndex ? k : `\"${k}\"`}]` : (parentPath ? `${parentPath}.` : '') + key\n    });\n    return (_, panic, next) => this.resolve(testOptions)._validate(value, testOptions, panic, next);\n  }\n  validate(value, options) {\n    var _options$disableStack2;\n    let schema = this.resolve(Object.assign({}, options, {\n      value\n    }));\n    let disableStackTrace = (_options$disableStack2 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;\n    return new Promise((resolve, reject) => schema._validate(value, options, (error, parsed) => {\n      if (ValidationError.isError(error)) error.value = parsed;\n      reject(error);\n    }, (errors, validated) => {\n      if (errors.length) reject(new ValidationError(errors, validated, undefined, undefined, disableStackTrace));else resolve(validated);\n    }));\n  }\n  validateSync(value, options) {\n    var _options$disableStack3;\n    let schema = this.resolve(Object.assign({}, options, {\n      value\n    }));\n    let result;\n    let disableStackTrace = (_options$disableStack3 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;\n    schema._validate(value, Object.assign({}, options, {\n      sync: true\n    }), (error, parsed) => {\n      if (ValidationError.isError(error)) error.value = parsed;\n      throw error;\n    }, (errors, validated) => {\n      if (errors.length) throw new ValidationError(errors, value, undefined, undefined, disableStackTrace);\n      result = validated;\n    });\n    return result;\n  }\n  isValid(value, options) {\n    return this.validate(value, options).then(() => true, err => {\n      if (ValidationError.isError(err)) return false;\n      throw err;\n    });\n  }\n  isValidSync(value, options) {\n    try {\n      this.validateSync(value, options);\n      return true;\n    } catch (err) {\n      if (ValidationError.isError(err)) return false;\n      throw err;\n    }\n  }\n  _getDefault(options) {\n    let defaultValue = this.spec.default;\n    if (defaultValue == null) {\n      return defaultValue;\n    }\n    return typeof defaultValue === 'function' ? defaultValue.call(this, options) : clone(defaultValue);\n  }\n  getDefault(options\n  // If schema is defaulted we know it's at least not undefined\n  ) {\n    let schema = this.resolve(options || {});\n    return schema._getDefault(options);\n  }\n  default(def) {\n    if (arguments.length === 0) {\n      return this._getDefault();\n    }\n    let next = this.clone({\n      default: def\n    });\n    return next;\n  }\n  strict(isStrict = true) {\n    return this.clone({\n      strict: isStrict\n    });\n  }\n  nullability(nullable, message) {\n    const next = this.clone({\n      nullable\n    });\n    next.internalTests.nullable = createValidation({\n      message,\n      name: 'nullable',\n      test(value) {\n        return value === null ? this.schema.spec.nullable : true;\n      }\n    });\n    return next;\n  }\n  optionality(optional, message) {\n    const next = this.clone({\n      optional\n    });\n    next.internalTests.optionality = createValidation({\n      message,\n      name: 'optionality',\n      test(value) {\n        return value === undefined ? this.schema.spec.optional : true;\n      }\n    });\n    return next;\n  }\n  optional() {\n    return this.optionality(true);\n  }\n  defined(message = mixed.defined) {\n    return this.optionality(false, message);\n  }\n  nullable() {\n    return this.nullability(true);\n  }\n  nonNullable(message = mixed.notNull) {\n    return this.nullability(false, message);\n  }\n  required(message = mixed.required) {\n    return this.clone().withMutation(next => next.nonNullable(message).defined(message));\n  }\n  notRequired() {\n    return this.clone().withMutation(next => next.nullable().optional());\n  }\n  transform(fn) {\n    let next = this.clone();\n    next.transforms.push(fn);\n    return next;\n  }\n\n  /**\n   * Adds a test function to the schema's queue of tests.\n   * tests can be exclusive or non-exclusive.\n   *\n   * - exclusive tests, will replace any existing tests of the same name.\n   * - non-exclusive: can be stacked\n   *\n   * If a non-exclusive test is added to a schema with an exclusive test of the same name\n   * the exclusive test is removed and further tests of the same name will be stacked.\n   *\n   * If an exclusive test is added to a schema with non-exclusive tests of the same name\n   * the previous tests are removed and further tests of the same name will replace each other.\n   */\n\n  test(...args) {\n    let opts;\n    if (args.length === 1) {\n      if (typeof args[0] === 'function') {\n        opts = {\n          test: args[0]\n        };\n      } else {\n        opts = args[0];\n      }\n    } else if (args.length === 2) {\n      opts = {\n        name: args[0],\n        test: args[1]\n      };\n    } else {\n      opts = {\n        name: args[0],\n        message: args[1],\n        test: args[2]\n      };\n    }\n    if (opts.message === undefined) opts.message = mixed.default;\n    if (typeof opts.test !== 'function') throw new TypeError('`test` is a required parameters');\n    let next = this.clone();\n    let validate = createValidation(opts);\n    let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;\n    if (opts.exclusive) {\n      if (!opts.name) throw new TypeError('Exclusive tests must provide a unique `name` identifying the test');\n    }\n    if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;\n    next.tests = next.tests.filter(fn => {\n      if (fn.OPTIONS.name === opts.name) {\n        if (isExclusive) return false;\n        if (fn.OPTIONS.test === validate.OPTIONS.test) return false;\n      }\n      return true;\n    });\n    next.tests.push(validate);\n    return next;\n  }\n  when(keys, options) {\n    if (!Array.isArray(keys) && typeof keys !== 'string') {\n      options = keys;\n      keys = '.';\n    }\n    let next = this.clone();\n    let deps = toArray(keys).map(key => new Reference(key));\n    deps.forEach(dep => {\n      // @ts-ignore readonly array\n      if (dep.isSibling) next.deps.push(dep.key);\n    });\n    next.conditions.push(typeof options === 'function' ? new Condition(deps, options) : Condition.fromOptions(deps, options));\n    return next;\n  }\n  typeError(message) {\n    let next = this.clone();\n    next.internalTests.typeError = createValidation({\n      message,\n      name: 'typeError',\n      skipAbsent: true,\n      test(value) {\n        if (!this.schema._typeCheck(value)) return this.createError({\n          params: {\n            type: this.schema.type\n          }\n        });\n        return true;\n      }\n    });\n    return next;\n  }\n  oneOf(enums, message = mixed.oneOf) {\n    let next = this.clone();\n    enums.forEach(val => {\n      next._whitelist.add(val);\n      next._blacklist.delete(val);\n    });\n    next.internalTests.whiteList = createValidation({\n      message,\n      name: 'oneOf',\n      skipAbsent: true,\n      test(value) {\n        let valids = this.schema._whitelist;\n        let resolved = valids.resolveAll(this.resolve);\n        return resolved.includes(value) ? true : this.createError({\n          params: {\n            values: Array.from(valids).join(', '),\n            resolved\n          }\n        });\n      }\n    });\n    return next;\n  }\n  notOneOf(enums, message = mixed.notOneOf) {\n    let next = this.clone();\n    enums.forEach(val => {\n      next._blacklist.add(val);\n      next._whitelist.delete(val);\n    });\n    next.internalTests.blacklist = createValidation({\n      message,\n      name: 'notOneOf',\n      test(value) {\n        let invalids = this.schema._blacklist;\n        let resolved = invalids.resolveAll(this.resolve);\n        if (resolved.includes(value)) return this.createError({\n          params: {\n            values: Array.from(invalids).join(', '),\n            resolved\n          }\n        });\n        return true;\n      }\n    });\n    return next;\n  }\n  strip(strip = true) {\n    let next = this.clone();\n    next.spec.strip = strip;\n    return next;\n  }\n\n  /**\n   * Return a serialized description of the schema including validations, flags, types etc.\n   *\n   * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).\n   */\n  describe(options) {\n    const next = (options ? this.resolve(options) : this).clone();\n    const {\n      label,\n      meta,\n      optional,\n      nullable\n    } = next.spec;\n    const description = {\n      meta,\n      label,\n      optional,\n      nullable,\n      default: next.getDefault(options),\n      type: next.type,\n      oneOf: next._whitelist.describe(),\n      notOneOf: next._blacklist.describe(),\n      tests: next.tests.map(fn => ({\n        name: fn.OPTIONS.name,\n        params: fn.OPTIONS.params\n      })).filter((n, idx, list) => list.findIndex(c => c.name === n.name) === idx)\n    };\n    return description;\n  }\n}\n// @ts-expect-error\nSchema.prototype.__isYupSchema__ = true;\nfor (const method of ['validate', 'validateSync']) Schema.prototype[`${method}At`] = function (path, value, options = {}) {\n  const {\n    parent,\n    parentPath,\n    schema\n  } = getIn(this, path, value, options.context);\n  return schema[method](parent && parent[parentPath], Object.assign({}, options, {\n    parent,\n    path\n  }));\n};\nfor (const alias of ['equals', 'is']) Schema.prototype[alias] = Schema.prototype.oneOf;\nfor (const alias of ['not', 'nope']) Schema.prototype[alias] = Schema.prototype.notOneOf;\n\nconst returnsTrue = () => true;\nfunction create$8(spec) {\n  return new MixedSchema(spec);\n}\nclass MixedSchema extends Schema {\n  constructor(spec) {\n    super(typeof spec === 'function' ? {\n      type: 'mixed',\n      check: spec\n    } : Object.assign({\n      type: 'mixed',\n      check: returnsTrue\n    }, spec));\n  }\n}\ncreate$8.prototype = MixedSchema.prototype;\n\nfunction create$7() {\n  return new BooleanSchema();\n}\nclass BooleanSchema extends Schema {\n  constructor() {\n    super({\n      type: 'boolean',\n      check(v) {\n        if (v instanceof Boolean) v = v.valueOf();\n        return typeof v === 'boolean';\n      }\n    });\n    this.withMutation(() => {\n      this.transform((value, _raw, ctx) => {\n        if (ctx.spec.coerce && !ctx.isType(value)) {\n          if (/^(true|1)$/i.test(String(value))) return true;\n          if (/^(false|0)$/i.test(String(value))) return false;\n        }\n        return value;\n      });\n    });\n  }\n  isTrue(message = boolean.isValue) {\n    return this.test({\n      message,\n      name: 'is-value',\n      exclusive: true,\n      params: {\n        value: 'true'\n      },\n      test(value) {\n        return isAbsent(value) || value === true;\n      }\n    });\n  }\n  isFalse(message = boolean.isValue) {\n    return this.test({\n      message,\n      name: 'is-value',\n      exclusive: true,\n      params: {\n        value: 'false'\n      },\n      test(value) {\n        return isAbsent(value) || value === false;\n      }\n    });\n  }\n  default(def) {\n    return super.default(def);\n  }\n  defined(msg) {\n    return super.defined(msg);\n  }\n  optional() {\n    return super.optional();\n  }\n  required(msg) {\n    return super.required(msg);\n  }\n  notRequired() {\n    return super.notRequired();\n  }\n  nullable() {\n    return super.nullable();\n  }\n  nonNullable(msg) {\n    return super.nonNullable(msg);\n  }\n  strip(v) {\n    return super.strip(v);\n  }\n}\ncreate$7.prototype = BooleanSchema.prototype;\n\n/**\n * This file is a modified version of the file from the following repository:\n * Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>\n * NON-CONFORMANT EDITION.\n * © 2011 Colin Snover <http://zetafleet.com>\n * Released under MIT license.\n */\n\n// prettier-ignore\n//                1 YYYY                2 MM        3 DD              4 HH     5 mm        6 ss           7 msec         8 Z 9 ±   10 tzHH    11 tzmm\nconst isoReg = /^(\\d{4}|[+-]\\d{6})(?:-?(\\d{2})(?:-?(\\d{2}))?)?(?:[ T]?(\\d{2}):?(\\d{2})(?::?(\\d{2})(?:[,.](\\d{1,}))?)?(?:(Z)|([+-])(\\d{2})(?::?(\\d{2}))?)?)?$/;\nfunction parseIsoDate(date) {\n  const struct = parseDateStruct(date);\n  if (!struct) return Date.parse ? Date.parse(date) : Number.NaN;\n\n  // timestamps without timezone identifiers should be considered local time\n  if (struct.z === undefined && struct.plusMinus === undefined) {\n    return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();\n  }\n  let totalMinutesOffset = 0;\n  if (struct.z !== 'Z' && struct.plusMinus !== undefined) {\n    totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;\n    if (struct.plusMinus === '+') totalMinutesOffset = 0 - totalMinutesOffset;\n  }\n  return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);\n}\nfunction parseDateStruct(date) {\n  var _regexResult$7$length, _regexResult$;\n  const regexResult = isoReg.exec(date);\n  if (!regexResult) return null;\n\n  // use of toNumber() avoids NaN timestamps caused by “undefined”\n  // values being passed to Date constructor\n  return {\n    year: toNumber(regexResult[1]),\n    month: toNumber(regexResult[2], 1) - 1,\n    day: toNumber(regexResult[3], 1),\n    hour: toNumber(regexResult[4]),\n    minute: toNumber(regexResult[5]),\n    second: toNumber(regexResult[6]),\n    millisecond: regexResult[7] ?\n    // allow arbitrary sub-second precision beyond milliseconds\n    toNumber(regexResult[7].substring(0, 3)) : 0,\n    precision: (_regexResult$7$length = (_regexResult$ = regexResult[7]) == null ? void 0 : _regexResult$.length) != null ? _regexResult$7$length : undefined,\n    z: regexResult[8] || undefined,\n    plusMinus: regexResult[9] || undefined,\n    hourOffset: toNumber(regexResult[10]),\n    minuteOffset: toNumber(regexResult[11])\n  };\n}\nfunction toNumber(str, defaultValue = 0) {\n  return Number(str) || defaultValue;\n}\n\n// Taken from HTML spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address\nlet rEmail =\n// eslint-disable-next-line\n/^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nlet rUrl =\n// eslint-disable-next-line\n/^((https?|ftp):)?\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i;\n\n// eslint-disable-next-line\nlet rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nlet yearMonthDay = '^\\\\d{4}-\\\\d{2}-\\\\d{2}';\nlet hourMinuteSecond = '\\\\d{2}:\\\\d{2}:\\\\d{2}';\nlet zOrOffset = '(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)';\nlet rIsoDateTime = new RegExp(`${yearMonthDay}T${hourMinuteSecond}(\\\\.\\\\d+)?${zOrOffset}$`);\nlet isTrimmed = value => isAbsent(value) || value === value.trim();\nlet objStringTag = {}.toString();\nfunction create$6() {\n  return new StringSchema();\n}\nclass StringSchema extends Schema {\n  constructor() {\n    super({\n      type: 'string',\n      check(value) {\n        if (value instanceof String) value = value.valueOf();\n        return typeof value === 'string';\n      }\n    });\n    this.withMutation(() => {\n      this.transform((value, _raw, ctx) => {\n        if (!ctx.spec.coerce || ctx.isType(value)) return value;\n\n        // don't ever convert arrays\n        if (Array.isArray(value)) return value;\n        const strValue = value != null && value.toString ? value.toString() : value;\n\n        // no one wants plain objects converted to [Object object]\n        if (strValue === objStringTag) return value;\n        return strValue;\n      });\n    });\n  }\n  required(message) {\n    return super.required(message).withMutation(schema => schema.test({\n      message: message || mixed.required,\n      name: 'required',\n      skipAbsent: true,\n      test: value => !!value.length\n    }));\n  }\n  notRequired() {\n    return super.notRequired().withMutation(schema => {\n      schema.tests = schema.tests.filter(t => t.OPTIONS.name !== 'required');\n      return schema;\n    });\n  }\n  length(length, message = string.length) {\n    return this.test({\n      message,\n      name: 'length',\n      exclusive: true,\n      params: {\n        length\n      },\n      skipAbsent: true,\n      test(value) {\n        return value.length === this.resolve(length);\n      }\n    });\n  }\n  min(min, message = string.min) {\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        min\n      },\n      skipAbsent: true,\n      test(value) {\n        return value.length >= this.resolve(min);\n      }\n    });\n  }\n  max(max, message = string.max) {\n    return this.test({\n      name: 'max',\n      exclusive: true,\n      message,\n      params: {\n        max\n      },\n      skipAbsent: true,\n      test(value) {\n        return value.length <= this.resolve(max);\n      }\n    });\n  }\n  matches(regex, options) {\n    let excludeEmptyString = false;\n    let message;\n    let name;\n    if (options) {\n      if (typeof options === 'object') {\n        ({\n          excludeEmptyString = false,\n          message,\n          name\n        } = options);\n      } else {\n        message = options;\n      }\n    }\n    return this.test({\n      name: name || 'matches',\n      message: message || string.matches,\n      params: {\n        regex\n      },\n      skipAbsent: true,\n      test: value => value === '' && excludeEmptyString || value.search(regex) !== -1\n    });\n  }\n  email(message = string.email) {\n    return this.matches(rEmail, {\n      name: 'email',\n      message,\n      excludeEmptyString: true\n    });\n  }\n  url(message = string.url) {\n    return this.matches(rUrl, {\n      name: 'url',\n      message,\n      excludeEmptyString: true\n    });\n  }\n  uuid(message = string.uuid) {\n    return this.matches(rUUID, {\n      name: 'uuid',\n      message,\n      excludeEmptyString: false\n    });\n  }\n  datetime(options) {\n    let message = '';\n    let allowOffset;\n    let precision;\n    if (options) {\n      if (typeof options === 'object') {\n        ({\n          message = '',\n          allowOffset = false,\n          precision = undefined\n        } = options);\n      } else {\n        message = options;\n      }\n    }\n    return this.matches(rIsoDateTime, {\n      name: 'datetime',\n      message: message || string.datetime,\n      excludeEmptyString: true\n    }).test({\n      name: 'datetime_offset',\n      message: message || string.datetime_offset,\n      params: {\n        allowOffset\n      },\n      skipAbsent: true,\n      test: value => {\n        if (!value || allowOffset) return true;\n        const struct = parseDateStruct(value);\n        if (!struct) return false;\n        return !!struct.z;\n      }\n    }).test({\n      name: 'datetime_precision',\n      message: message || string.datetime_precision,\n      params: {\n        precision\n      },\n      skipAbsent: true,\n      test: value => {\n        if (!value || precision == undefined) return true;\n        const struct = parseDateStruct(value);\n        if (!struct) return false;\n        return struct.precision === precision;\n      }\n    });\n  }\n\n  //-- transforms --\n  ensure() {\n    return this.default('').transform(val => val === null ? '' : val);\n  }\n  trim(message = string.trim) {\n    return this.transform(val => val != null ? val.trim() : val).test({\n      message,\n      name: 'trim',\n      test: isTrimmed\n    });\n  }\n  lowercase(message = string.lowercase) {\n    return this.transform(value => !isAbsent(value) ? value.toLowerCase() : value).test({\n      message,\n      name: 'string_case',\n      exclusive: true,\n      skipAbsent: true,\n      test: value => isAbsent(value) || value === value.toLowerCase()\n    });\n  }\n  uppercase(message = string.uppercase) {\n    return this.transform(value => !isAbsent(value) ? value.toUpperCase() : value).test({\n      message,\n      name: 'string_case',\n      exclusive: true,\n      skipAbsent: true,\n      test: value => isAbsent(value) || value === value.toUpperCase()\n    });\n  }\n}\ncreate$6.prototype = StringSchema.prototype;\n\n//\n// String Interfaces\n//\n\nlet isNaN$1 = value => value != +value;\nfunction create$5() {\n  return new NumberSchema();\n}\nclass NumberSchema extends Schema {\n  constructor() {\n    super({\n      type: 'number',\n      check(value) {\n        if (value instanceof Number) value = value.valueOf();\n        return typeof value === 'number' && !isNaN$1(value);\n      }\n    });\n    this.withMutation(() => {\n      this.transform((value, _raw, ctx) => {\n        if (!ctx.spec.coerce) return value;\n        let parsed = value;\n        if (typeof parsed === 'string') {\n          parsed = parsed.replace(/\\s/g, '');\n          if (parsed === '') return NaN;\n          // don't use parseFloat to avoid positives on alpha-numeric strings\n          parsed = +parsed;\n        }\n\n        // null -> NaN isn't useful; treat all nulls as null and let it fail on\n        // nullability check vs TypeErrors\n        if (ctx.isType(parsed) || parsed === null) return parsed;\n        return parseFloat(parsed);\n      });\n    });\n  }\n  min(min, message = number.min) {\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        min\n      },\n      skipAbsent: true,\n      test(value) {\n        return value >= this.resolve(min);\n      }\n    });\n  }\n  max(max, message = number.max) {\n    return this.test({\n      message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        max\n      },\n      skipAbsent: true,\n      test(value) {\n        return value <= this.resolve(max);\n      }\n    });\n  }\n  lessThan(less, message = number.lessThan) {\n    return this.test({\n      message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        less\n      },\n      skipAbsent: true,\n      test(value) {\n        return value < this.resolve(less);\n      }\n    });\n  }\n  moreThan(more, message = number.moreThan) {\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        more\n      },\n      skipAbsent: true,\n      test(value) {\n        return value > this.resolve(more);\n      }\n    });\n  }\n  positive(msg = number.positive) {\n    return this.moreThan(0, msg);\n  }\n  negative(msg = number.negative) {\n    return this.lessThan(0, msg);\n  }\n  integer(message = number.integer) {\n    return this.test({\n      name: 'integer',\n      message,\n      skipAbsent: true,\n      test: val => Number.isInteger(val)\n    });\n  }\n  truncate() {\n    return this.transform(value => !isAbsent(value) ? value | 0 : value);\n  }\n  round(method) {\n    var _method;\n    let avail = ['ceil', 'floor', 'round', 'trunc'];\n    method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || 'round';\n\n    // this exists for symemtry with the new Math.trunc\n    if (method === 'trunc') return this.truncate();\n    if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError('Only valid options for round() are: ' + avail.join(', '));\n    return this.transform(value => !isAbsent(value) ? Math[method](value) : value);\n  }\n}\ncreate$5.prototype = NumberSchema.prototype;\n\n//\n// Number Interfaces\n//\n\nlet invalidDate = new Date('');\nlet isDate = obj => Object.prototype.toString.call(obj) === '[object Date]';\nfunction create$4() {\n  return new DateSchema();\n}\nclass DateSchema extends Schema {\n  constructor() {\n    super({\n      type: 'date',\n      check(v) {\n        return isDate(v) && !isNaN(v.getTime());\n      }\n    });\n    this.withMutation(() => {\n      this.transform((value, _raw, ctx) => {\n        // null -> InvalidDate isn't useful; treat all nulls as null and let it fail on\n        // nullability check vs TypeErrors\n        if (!ctx.spec.coerce || ctx.isType(value) || value === null) return value;\n        value = parseIsoDate(value);\n\n        // 0 is a valid timestamp equivalent to 1970-01-01T00:00:00Z(unix epoch) or before.\n        return !isNaN(value) ? new Date(value) : DateSchema.INVALID_DATE;\n      });\n    });\n  }\n  prepareParam(ref, name) {\n    let param;\n    if (!Reference.isRef(ref)) {\n      let cast = this.cast(ref);\n      if (!this._typeCheck(cast)) throw new TypeError(`\\`${name}\\` must be a Date or a value that can be \\`cast()\\` to a Date`);\n      param = cast;\n    } else {\n      param = ref;\n    }\n    return param;\n  }\n  min(min, message = date.min) {\n    let limit = this.prepareParam(min, 'min');\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        min\n      },\n      skipAbsent: true,\n      test(value) {\n        return value >= this.resolve(limit);\n      }\n    });\n  }\n  max(max, message = date.max) {\n    let limit = this.prepareParam(max, 'max');\n    return this.test({\n      message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        max\n      },\n      skipAbsent: true,\n      test(value) {\n        return value <= this.resolve(limit);\n      }\n    });\n  }\n}\nDateSchema.INVALID_DATE = invalidDate;\ncreate$4.prototype = DateSchema.prototype;\ncreate$4.INVALID_DATE = invalidDate;\n\n// @ts-expect-error\nfunction sortFields(fields, excludedEdges = []) {\n  let edges = [];\n  let nodes = new Set();\n  let excludes = new Set(excludedEdges.map(([a, b]) => `${a}-${b}`));\n  function addNode(depPath, key) {\n    let node = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.split)(depPath)[0];\n    nodes.add(node);\n    if (!excludes.has(`${key}-${node}`)) edges.push([key, node]);\n  }\n  for (const key of Object.keys(fields)) {\n    let value = fields[key];\n    nodes.add(key);\n    if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);else if (isSchema(value) && 'deps' in value) value.deps.forEach(path => addNode(path, key));\n  }\n  return toposort__WEBPACK_IMPORTED_MODULE_2___default().array(Array.from(nodes), edges).reverse();\n}\n\nfunction findIndex(arr, err) {\n  let idx = Infinity;\n  arr.some((key, ii) => {\n    var _err$path;\n    if ((_err$path = err.path) != null && _err$path.includes(key)) {\n      idx = ii;\n      return true;\n    }\n  });\n  return idx;\n}\nfunction sortByKeyOrder(keys) {\n  return (a, b) => {\n    return findIndex(keys, a) - findIndex(keys, b);\n  };\n}\n\nconst parseJson = (value, _, ctx) => {\n  if (typeof value !== 'string') {\n    return value;\n  }\n  let parsed = value;\n  try {\n    parsed = JSON.parse(value);\n  } catch (err) {\n    /* */\n  }\n  return ctx.isType(parsed) ? parsed : value;\n};\n\n// @ts-ignore\nfunction deepPartial(schema) {\n  if ('fields' in schema) {\n    const partial = {};\n    for (const [key, fieldSchema] of Object.entries(schema.fields)) {\n      partial[key] = deepPartial(fieldSchema);\n    }\n    return schema.setFields(partial);\n  }\n  if (schema.type === 'array') {\n    const nextArray = schema.optional();\n    if (nextArray.innerType) nextArray.innerType = deepPartial(nextArray.innerType);\n    return nextArray;\n  }\n  if (schema.type === 'tuple') {\n    return schema.optional().clone({\n      types: schema.spec.types.map(deepPartial)\n    });\n  }\n  if ('optional' in schema) {\n    return schema.optional();\n  }\n  return schema;\n}\nconst deepHas = (obj, p) => {\n  const path = [...(0,property_expr__WEBPACK_IMPORTED_MODULE_0__.normalizePath)(p)];\n  if (path.length === 1) return path[0] in obj;\n  let last = path.pop();\n  let parent = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)((0,property_expr__WEBPACK_IMPORTED_MODULE_0__.join)(path), true)(obj);\n  return !!(parent && last in parent);\n};\nlet isObject = obj => Object.prototype.toString.call(obj) === '[object Object]';\nfunction unknown(ctx, value) {\n  let known = Object.keys(ctx.fields);\n  return Object.keys(value).filter(key => known.indexOf(key) === -1);\n}\nconst defaultSort = sortByKeyOrder([]);\nfunction create$3(spec) {\n  return new ObjectSchema(spec);\n}\nclass ObjectSchema extends Schema {\n  constructor(spec) {\n    super({\n      type: 'object',\n      check(value) {\n        return isObject(value) || typeof value === 'function';\n      }\n    });\n    this.fields = Object.create(null);\n    this._sortErrors = defaultSort;\n    this._nodes = [];\n    this._excludedEdges = [];\n    this.withMutation(() => {\n      if (spec) {\n        this.shape(spec);\n      }\n    });\n  }\n  _cast(_value, options = {}) {\n    var _options$stripUnknown;\n    let value = super._cast(_value, options);\n\n    //should ignore nulls here\n    if (value === undefined) return this.getDefault(options);\n    if (!this._typeCheck(value)) return value;\n    let fields = this.fields;\n    let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;\n    let props = [].concat(this._nodes, Object.keys(value).filter(v => !this._nodes.includes(v)));\n    let intermediateValue = {}; // is filled during the transform below\n    let innerOptions = Object.assign({}, options, {\n      parent: intermediateValue,\n      __validating: options.__validating || false\n    });\n    let isChanged = false;\n    for (const prop of props) {\n      let field = fields[prop];\n      let exists = (prop in value);\n      if (field) {\n        let fieldValue;\n        let inputValue = value[prop];\n\n        // safe to mutate since this is fired in sequence\n        innerOptions.path = (options.path ? `${options.path}.` : '') + prop;\n        field = field.resolve({\n          value: inputValue,\n          context: options.context,\n          parent: intermediateValue\n        });\n        let fieldSpec = field instanceof Schema ? field.spec : undefined;\n        let strict = fieldSpec == null ? void 0 : fieldSpec.strict;\n        if (fieldSpec != null && fieldSpec.strip) {\n          isChanged = isChanged || prop in value;\n          continue;\n        }\n        fieldValue = !options.__validating || !strict ?\n        // TODO: use _cast, this is double resolving\n        field.cast(value[prop], innerOptions) : value[prop];\n        if (fieldValue !== undefined) {\n          intermediateValue[prop] = fieldValue;\n        }\n      } else if (exists && !strip) {\n        intermediateValue[prop] = value[prop];\n      }\n      if (exists !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {\n        isChanged = true;\n      }\n    }\n    return isChanged ? intermediateValue : value;\n  }\n  _validate(_value, options = {}, panic, next) {\n    let {\n      from = [],\n      originalValue = _value,\n      recursive = this.spec.recursive\n    } = options;\n    options.from = [{\n      schema: this,\n      value: originalValue\n    }, ...from];\n    // this flag is needed for handling `strict` correctly in the context of\n    // validation vs just casting. e.g strict() on a field is only used when validating\n    options.__validating = true;\n    options.originalValue = originalValue;\n    super._validate(_value, options, panic, (objectErrors, value) => {\n      if (!recursive || !isObject(value)) {\n        next(objectErrors, value);\n        return;\n      }\n      originalValue = originalValue || value;\n      let tests = [];\n      for (let key of this._nodes) {\n        let field = this.fields[key];\n        if (!field || Reference.isRef(field)) {\n          continue;\n        }\n        tests.push(field.asNestedTest({\n          options,\n          key,\n          parent: value,\n          parentPath: options.path,\n          originalParent: originalValue\n        }));\n      }\n      this.runTests({\n        tests,\n        value,\n        originalValue,\n        options\n      }, panic, fieldErrors => {\n        next(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);\n      });\n    });\n  }\n  clone(spec) {\n    const next = super.clone(spec);\n    next.fields = Object.assign({}, this.fields);\n    next._nodes = this._nodes;\n    next._excludedEdges = this._excludedEdges;\n    next._sortErrors = this._sortErrors;\n    return next;\n  }\n  concat(schema) {\n    let next = super.concat(schema);\n    let nextFields = next.fields;\n    for (let [field, schemaOrRef] of Object.entries(this.fields)) {\n      const target = nextFields[field];\n      nextFields[field] = target === undefined ? schemaOrRef : target;\n    }\n    return next.withMutation(s =>\n    // XXX: excludes here is wrong\n    s.setFields(nextFields, [...this._excludedEdges, ...schema._excludedEdges]));\n  }\n  _getDefault(options) {\n    if ('default' in this.spec) {\n      return super._getDefault(options);\n    }\n\n    // if there is no default set invent one\n    if (!this._nodes.length) {\n      return undefined;\n    }\n    let dft = {};\n    this._nodes.forEach(key => {\n      var _innerOptions;\n      const field = this.fields[key];\n      let innerOptions = options;\n      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n        innerOptions = Object.assign({}, innerOptions, {\n          parent: innerOptions.value,\n          value: innerOptions.value[key]\n        });\n      }\n      dft[key] = field && 'getDefault' in field ? field.getDefault(innerOptions) : undefined;\n    });\n    return dft;\n  }\n  setFields(shape, excludedEdges) {\n    let next = this.clone();\n    next.fields = shape;\n    next._nodes = sortFields(shape, excludedEdges);\n    next._sortErrors = sortByKeyOrder(Object.keys(shape));\n    // XXX: this carries over edges which may not be what you want\n    if (excludedEdges) next._excludedEdges = excludedEdges;\n    return next;\n  }\n  shape(additions, excludes = []) {\n    return this.clone().withMutation(next => {\n      let edges = next._excludedEdges;\n      if (excludes.length) {\n        if (!Array.isArray(excludes[0])) excludes = [excludes];\n        edges = [...next._excludedEdges, ...excludes];\n      }\n\n      // XXX: excludes here is wrong\n      return next.setFields(Object.assign(next.fields, additions), edges);\n    });\n  }\n  partial() {\n    const partial = {};\n    for (const [key, schema] of Object.entries(this.fields)) {\n      partial[key] = 'optional' in schema && schema.optional instanceof Function ? schema.optional() : schema;\n    }\n    return this.setFields(partial);\n  }\n  deepPartial() {\n    const next = deepPartial(this);\n    return next;\n  }\n  pick(keys) {\n    const picked = {};\n    for (const key of keys) {\n      if (this.fields[key]) picked[key] = this.fields[key];\n    }\n    return this.setFields(picked, this._excludedEdges.filter(([a, b]) => keys.includes(a) && keys.includes(b)));\n  }\n  omit(keys) {\n    const remaining = [];\n    for (const key of Object.keys(this.fields)) {\n      if (keys.includes(key)) continue;\n      remaining.push(key);\n    }\n    return this.pick(remaining);\n  }\n  from(from, to, alias) {\n    let fromGetter = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)(from, true);\n    return this.transform(obj => {\n      if (!obj) return obj;\n      let newObj = obj;\n      if (deepHas(obj, from)) {\n        newObj = Object.assign({}, obj);\n        if (!alias) delete newObj[from];\n        newObj[to] = fromGetter(obj);\n      }\n      return newObj;\n    });\n  }\n\n  /** Parse an input JSON string to an object */\n  json() {\n    return this.transform(parseJson);\n  }\n\n  /**\n   * Similar to `noUnknown` but only validates that an object is the right shape without stripping the unknown keys\n   */\n  exact(message) {\n    return this.test({\n      name: 'exact',\n      exclusive: true,\n      message: message || object.exact,\n      test(value) {\n        if (value == null) return true;\n        const unknownKeys = unknown(this.schema, value);\n        return unknownKeys.length === 0 || this.createError({\n          params: {\n            properties: unknownKeys.join(', ')\n          }\n        });\n      }\n    });\n  }\n  stripUnknown() {\n    return this.clone({\n      noUnknown: true\n    });\n  }\n  noUnknown(noAllow = true, message = object.noUnknown) {\n    if (typeof noAllow !== 'boolean') {\n      message = noAllow;\n      noAllow = true;\n    }\n    let next = this.test({\n      name: 'noUnknown',\n      exclusive: true,\n      message: message,\n      test(value) {\n        if (value == null) return true;\n        const unknownKeys = unknown(this.schema, value);\n        return !noAllow || unknownKeys.length === 0 || this.createError({\n          params: {\n            unknown: unknownKeys.join(', ')\n          }\n        });\n      }\n    });\n    next.spec.noUnknown = noAllow;\n    return next;\n  }\n  unknown(allow = true, message = object.noUnknown) {\n    return this.noUnknown(!allow, message);\n  }\n  transformKeys(fn) {\n    return this.transform(obj => {\n      if (!obj) return obj;\n      const result = {};\n      for (const key of Object.keys(obj)) result[fn(key)] = obj[key];\n      return result;\n    });\n  }\n  camelCase() {\n    return this.transformKeys(tiny_case__WEBPACK_IMPORTED_MODULE_1__.camelCase);\n  }\n  snakeCase() {\n    return this.transformKeys(tiny_case__WEBPACK_IMPORTED_MODULE_1__.snakeCase);\n  }\n  constantCase() {\n    return this.transformKeys(key => (0,tiny_case__WEBPACK_IMPORTED_MODULE_1__.snakeCase)(key).toUpperCase());\n  }\n  describe(options) {\n    const next = (options ? this.resolve(options) : this).clone();\n    const base = super.describe(options);\n    base.fields = {};\n    for (const [key, value] of Object.entries(next.fields)) {\n      var _innerOptions2;\n      let innerOptions = options;\n      if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {\n        innerOptions = Object.assign({}, innerOptions, {\n          parent: innerOptions.value,\n          value: innerOptions.value[key]\n        });\n      }\n      base.fields[key] = value.describe(innerOptions);\n    }\n    return base;\n  }\n}\ncreate$3.prototype = ObjectSchema.prototype;\n\nfunction create$2(type) {\n  return new ArraySchema(type);\n}\nclass ArraySchema extends Schema {\n  constructor(type) {\n    super({\n      type: 'array',\n      spec: {\n        types: type\n      },\n      check(v) {\n        return Array.isArray(v);\n      }\n    });\n\n    // `undefined` specifically means uninitialized, as opposed to \"no subtype\"\n    this.innerType = void 0;\n    this.innerType = type;\n  }\n  _cast(_value, _opts) {\n    const value = super._cast(_value, _opts);\n\n    // should ignore nulls here\n    if (!this._typeCheck(value) || !this.innerType) {\n      return value;\n    }\n    let isChanged = false;\n    const castArray = value.map((v, idx) => {\n      const castElement = this.innerType.cast(v, Object.assign({}, _opts, {\n        path: `${_opts.path || ''}[${idx}]`\n      }));\n      if (castElement !== v) {\n        isChanged = true;\n      }\n      return castElement;\n    });\n    return isChanged ? castArray : value;\n  }\n  _validate(_value, options = {}, panic, next) {\n    var _options$recursive;\n    // let sync = options.sync;\n    // let path = options.path;\n    let innerType = this.innerType;\n    // let endEarly = options.abortEarly ?? this.spec.abortEarly;\n    let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;\n    options.originalValue != null ? options.originalValue : _value;\n    super._validate(_value, options, panic, (arrayErrors, value) => {\n      var _options$originalValu2;\n      if (!recursive || !innerType || !this._typeCheck(value)) {\n        next(arrayErrors, value);\n        return;\n      }\n\n      // #950 Ensure that sparse array empty slots are validated\n      let tests = new Array(value.length);\n      for (let index = 0; index < value.length; index++) {\n        var _options$originalValu;\n        tests[index] = innerType.asNestedTest({\n          options,\n          index,\n          parent: value,\n          parentPath: options.path,\n          originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value\n        });\n      }\n      this.runTests({\n        value,\n        tests,\n        originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,\n        options\n      }, panic, innerTypeErrors => next(innerTypeErrors.concat(arrayErrors), value));\n    });\n  }\n  clone(spec) {\n    const next = super.clone(spec);\n    // @ts-expect-error readonly\n    next.innerType = this.innerType;\n    return next;\n  }\n\n  /** Parse an input JSON string to an object */\n  json() {\n    return this.transform(parseJson);\n  }\n  concat(schema) {\n    let next = super.concat(schema);\n\n    // @ts-expect-error readonly\n    next.innerType = this.innerType;\n    if (schema.innerType)\n      // @ts-expect-error readonly\n      next.innerType = next.innerType ?\n      // @ts-expect-error Lazy doesn't have concat and will break\n      next.innerType.concat(schema.innerType) : schema.innerType;\n    return next;\n  }\n  of(schema) {\n    // FIXME: this should return a new instance of array without the default to be\n    let next = this.clone();\n    if (!isSchema(schema)) throw new TypeError('`array.of()` sub-schema must be a valid yup schema not: ' + printValue(schema));\n\n    // @ts-expect-error readonly\n    next.innerType = schema;\n    next.spec = Object.assign({}, next.spec, {\n      types: schema\n    });\n    return next;\n  }\n  length(length, message = array.length) {\n    return this.test({\n      message,\n      name: 'length',\n      exclusive: true,\n      params: {\n        length\n      },\n      skipAbsent: true,\n      test(value) {\n        return value.length === this.resolve(length);\n      }\n    });\n  }\n  min(min, message) {\n    message = message || array.min;\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        min\n      },\n      skipAbsent: true,\n      // FIXME(ts): Array<typeof T>\n      test(value) {\n        return value.length >= this.resolve(min);\n      }\n    });\n  }\n  max(max, message) {\n    message = message || array.max;\n    return this.test({\n      message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        max\n      },\n      skipAbsent: true,\n      test(value) {\n        return value.length <= this.resolve(max);\n      }\n    });\n  }\n  ensure() {\n    return this.default(() => []).transform((val, original) => {\n      // We don't want to return `null` for nullable schema\n      if (this._typeCheck(val)) return val;\n      return original == null ? [] : [].concat(original);\n    });\n  }\n  compact(rejector) {\n    let reject = !rejector ? v => !!v : (v, i, a) => !rejector(v, i, a);\n    return this.transform(values => values != null ? values.filter(reject) : values);\n  }\n  describe(options) {\n    const next = (options ? this.resolve(options) : this).clone();\n    const base = super.describe(options);\n    if (next.innerType) {\n      var _innerOptions;\n      let innerOptions = options;\n      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n        innerOptions = Object.assign({}, innerOptions, {\n          parent: innerOptions.value,\n          value: innerOptions.value[0]\n        });\n      }\n      base.innerType = next.innerType.describe(innerOptions);\n    }\n    return base;\n  }\n}\ncreate$2.prototype = ArraySchema.prototype;\n\n// @ts-ignore\nfunction create$1(schemas) {\n  return new TupleSchema(schemas);\n}\nclass TupleSchema extends Schema {\n  constructor(schemas) {\n    super({\n      type: 'tuple',\n      spec: {\n        types: schemas\n      },\n      check(v) {\n        const types = this.spec.types;\n        return Array.isArray(v) && v.length === types.length;\n      }\n    });\n    this.withMutation(() => {\n      this.typeError(tuple.notType);\n    });\n  }\n  _cast(inputValue, options) {\n    const {\n      types\n    } = this.spec;\n    const value = super._cast(inputValue, options);\n    if (!this._typeCheck(value)) {\n      return value;\n    }\n    let isChanged = false;\n    const castArray = types.map((type, idx) => {\n      const castElement = type.cast(value[idx], Object.assign({}, options, {\n        path: `${options.path || ''}[${idx}]`\n      }));\n      if (castElement !== value[idx]) isChanged = true;\n      return castElement;\n    });\n    return isChanged ? castArray : value;\n  }\n  _validate(_value, options = {}, panic, next) {\n    let itemTypes = this.spec.types;\n    super._validate(_value, options, panic, (tupleErrors, value) => {\n      var _options$originalValu2;\n      // intentionally not respecting recursive\n      if (!this._typeCheck(value)) {\n        next(tupleErrors, value);\n        return;\n      }\n      let tests = [];\n      for (let [index, itemSchema] of itemTypes.entries()) {\n        var _options$originalValu;\n        tests[index] = itemSchema.asNestedTest({\n          options,\n          index,\n          parent: value,\n          parentPath: options.path,\n          originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value\n        });\n      }\n      this.runTests({\n        value,\n        tests,\n        originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,\n        options\n      }, panic, innerTypeErrors => next(innerTypeErrors.concat(tupleErrors), value));\n    });\n  }\n  describe(options) {\n    const next = (options ? this.resolve(options) : this).clone();\n    const base = super.describe(options);\n    base.innerType = next.spec.types.map((schema, index) => {\n      var _innerOptions;\n      let innerOptions = options;\n      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n        innerOptions = Object.assign({}, innerOptions, {\n          parent: innerOptions.value,\n          value: innerOptions.value[index]\n        });\n      }\n      return schema.describe(innerOptions);\n    });\n    return base;\n  }\n}\ncreate$1.prototype = TupleSchema.prototype;\n\nfunction create(builder) {\n  return new Lazy(builder);\n}\nfunction catchValidationError(fn) {\n  try {\n    return fn();\n  } catch (err) {\n    if (ValidationError.isError(err)) return Promise.reject(err);\n    throw err;\n  }\n}\nclass Lazy {\n  constructor(builder) {\n    this.type = 'lazy';\n    this.__isYupSchema__ = true;\n    this.spec = void 0;\n    this._resolve = (value, options = {}) => {\n      let schema = this.builder(value, options);\n      if (!isSchema(schema)) throw new TypeError('lazy() functions must return a valid schema');\n      if (this.spec.optional) schema = schema.optional();\n      return schema.resolve(options);\n    };\n    this.builder = builder;\n    this.spec = {\n      meta: undefined,\n      optional: false\n    };\n  }\n  clone(spec) {\n    const next = new Lazy(this.builder);\n    next.spec = Object.assign({}, this.spec, spec);\n    return next;\n  }\n  optionality(optional) {\n    const next = this.clone({\n      optional\n    });\n    return next;\n  }\n  optional() {\n    return this.optionality(true);\n  }\n  resolve(options) {\n    return this._resolve(options.value, options);\n  }\n  cast(value, options) {\n    return this._resolve(value, options).cast(value, options);\n  }\n  asNestedTest(config) {\n    let {\n      key,\n      index,\n      parent,\n      options\n    } = config;\n    let value = parent[index != null ? index : key];\n    return this._resolve(value, Object.assign({}, options, {\n      value,\n      parent\n    })).asNestedTest(config);\n  }\n  validate(value, options) {\n    return catchValidationError(() => this._resolve(value, options).validate(value, options));\n  }\n  validateSync(value, options) {\n    return this._resolve(value, options).validateSync(value, options);\n  }\n  validateAt(path, value, options) {\n    return catchValidationError(() => this._resolve(value, options).validateAt(path, value, options));\n  }\n  validateSyncAt(path, value, options) {\n    return this._resolve(value, options).validateSyncAt(path, value, options);\n  }\n  isValid(value, options) {\n    try {\n      return this._resolve(value, options).isValid(value, options);\n    } catch (err) {\n      if (ValidationError.isError(err)) {\n        return Promise.resolve(false);\n      }\n      throw err;\n    }\n  }\n  isValidSync(value, options) {\n    return this._resolve(value, options).isValidSync(value, options);\n  }\n  describe(options) {\n    return options ? this.resolve(options).describe(options) : {\n      type: 'lazy',\n      meta: this.spec.meta,\n      label: undefined\n    };\n  }\n  meta(...args) {\n    if (args.length === 0) return this.spec.meta;\n    let next = this.clone();\n    next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);\n    return next;\n  }\n}\n\nfunction setLocale(custom) {\n  Object.keys(custom).forEach(type => {\n    // @ts-ignore\n    Object.keys(custom[type]).forEach(method => {\n      // @ts-ignore\n      locale[type][method] = custom[type][method];\n    });\n  });\n}\n\nfunction addMethod(schemaType, name, fn) {\n  if (!schemaType || !isSchema(schemaType.prototype)) throw new TypeError('You must provide a yup schema constructor function');\n  if (typeof name !== 'string') throw new TypeError('A Method name must be provided');\n  if (typeof fn !== 'function') throw new TypeError('Method function must be provided');\n  schemaType.prototype[name] = fn;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3l1cC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9zdC8uLi8uLi9ub2RlX21vZHVsZXMveXVwL2luZGV4LmVzbS5qcz9kOTYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldHRlciwgZm9yRWFjaCwgc3BsaXQsIG5vcm1hbGl6ZVBhdGgsIGpvaW4gfSBmcm9tICdwcm9wZXJ0eS1leHByJztcbmltcG9ydCB7IGNhbWVsQ2FzZSwgc25ha2VDYXNlIH0gZnJvbSAndGlueS1jYXNlJztcbmltcG9ydCB0b3Bvc29ydCBmcm9tICd0b3Bvc29ydCc7XG5cbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IGVycm9yVG9TdHJpbmcgPSBFcnJvci5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCByZWdFeHBUb1N0cmluZyA9IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCBzeW1ib2xUb1N0cmluZyA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyA6ICgpID0+ICcnO1xuY29uc3QgU1lNQk9MX1JFR0VYUCA9IC9eU3ltYm9sXFwoKC4qKVxcKSguKikkLztcbmZ1bmN0aW9uIHByaW50TnVtYmVyKHZhbCkge1xuICBpZiAodmFsICE9ICt2YWwpIHJldHVybiAnTmFOJztcbiAgY29uc3QgaXNOZWdhdGl2ZVplcm8gPSB2YWwgPT09IDAgJiYgMSAvIHZhbCA8IDA7XG4gIHJldHVybiBpc05lZ2F0aXZlWmVybyA/ICctMCcgOiAnJyArIHZhbDtcbn1cbmZ1bmN0aW9uIHByaW50U2ltcGxlVmFsdWUodmFsLCBxdW90ZVN0cmluZ3MgPSBmYWxzZSkge1xuICBpZiAodmFsID09IG51bGwgfHwgdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2UpIHJldHVybiAnJyArIHZhbDtcbiAgY29uc3QgdHlwZU9mID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGVPZiA9PT0gJ251bWJlcicpIHJldHVybiBwcmludE51bWJlcih2YWwpO1xuICBpZiAodHlwZU9mID09PSAnc3RyaW5nJykgcmV0dXJuIHF1b3RlU3RyaW5ncyA/IGBcIiR7dmFsfVwiYCA6IHZhbDtcbiAgaWYgKHR5cGVPZiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuICdbRnVuY3Rpb24gJyArICh2YWwubmFtZSB8fCAnYW5vbnltb3VzJykgKyAnXSc7XG4gIGlmICh0eXBlT2YgPT09ICdzeW1ib2wnKSByZXR1cm4gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWwpLnJlcGxhY2UoU1lNQk9MX1JFR0VYUCwgJ1N5bWJvbCgkMSknKTtcbiAgY29uc3QgdGFnID0gdG9TdHJpbmcuY2FsbCh2YWwpLnNsaWNlKDgsIC0xKTtcbiAgaWYgKHRhZyA9PT0gJ0RhdGUnKSByZXR1cm4gaXNOYU4odmFsLmdldFRpbWUoKSkgPyAnJyArIHZhbCA6IHZhbC50b0lTT1N0cmluZyh2YWwpO1xuICBpZiAodGFnID09PSAnRXJyb3InIHx8IHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gJ1snICsgZXJyb3JUb1N0cmluZy5jYWxsKHZhbCkgKyAnXSc7XG4gIGlmICh0YWcgPT09ICdSZWdFeHAnKSByZXR1cm4gcmVnRXhwVG9TdHJpbmcuY2FsbCh2YWwpO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHByaW50VmFsdWUodmFsdWUsIHF1b3RlU3RyaW5ncykge1xuICBsZXQgcmVzdWx0ID0gcHJpbnRTaW1wbGVWYWx1ZSh2YWx1ZSwgcXVvdGVTdHJpbmdzKTtcbiAgaWYgKHJlc3VsdCAhPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSBwcmludFNpbXBsZVZhbHVlKHRoaXNba2V5XSwgcXVvdGVTdHJpbmdzKTtcbiAgICBpZiAocmVzdWx0ICE9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSwgMik7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBbXSA6IFtdLmNvbmNhdCh2YWx1ZSk7XG59XG5cbmxldCBfU3ltYm9sJHRvU3RyaW5nVGFnLCBfU3ltYm9sJGhhc0luc3RhbmNlLCBfU3ltYm9sJHRvU3RyaW5nVGFnMjtcbmxldCBzdHJSZWcgPSAvXFwkXFx7XFxzKihcXHcrKVxccypcXH0vZztcbl9TeW1ib2wkdG9TdHJpbmdUYWcgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG5jbGFzcyBWYWxpZGF0aW9uRXJyb3JOb1N0YWNrIHtcbiAgY29uc3RydWN0b3IoZXJyb3JPckVycm9ycywgdmFsdWUsIGZpZWxkLCB0eXBlKSB7XG4gICAgdGhpcy5uYW1lID0gdm9pZCAwO1xuICAgIHRoaXMubWVzc2FnZSA9IHZvaWQgMDtcbiAgICB0aGlzLnZhbHVlID0gdm9pZCAwO1xuICAgIHRoaXMucGF0aCA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJhbXMgPSB2b2lkIDA7XG4gICAgdGhpcy5lcnJvcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5pbm5lciA9IHZvaWQgMDtcbiAgICB0aGlzW19TeW1ib2wkdG9TdHJpbmdUYWddID0gJ0Vycm9yJztcbiAgICB0aGlzLm5hbWUgPSAnVmFsaWRhdGlvbkVycm9yJztcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5wYXRoID0gZmllbGQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMuaW5uZXIgPSBbXTtcbiAgICB0b0FycmF5KGVycm9yT3JFcnJvcnMpLmZvckVhY2goZXJyID0+IHtcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnIpKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2goLi4uZXJyLmVycm9ycyk7XG4gICAgICAgIGNvbnN0IGlubmVyRXJyb3JzID0gZXJyLmlubmVyLmxlbmd0aCA/IGVyci5pbm5lciA6IFtlcnJdO1xuICAgICAgICB0aGlzLmlubmVyLnB1c2goLi4uaW5uZXJFcnJvcnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuZXJyb3JzLmxlbmd0aCA+IDEgPyBgJHt0aGlzLmVycm9ycy5sZW5ndGh9IGVycm9ycyBvY2N1cnJlZGAgOiB0aGlzLmVycm9yc1swXTtcbiAgfVxufVxuX1N5bWJvbCRoYXNJbnN0YW5jZSA9IFN5bWJvbC5oYXNJbnN0YW5jZTtcbl9TeW1ib2wkdG9TdHJpbmdUYWcyID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBzdGF0aWMgZm9ybWF0RXJyb3IobWVzc2FnZSwgcGFyYW1zKSB7XG4gICAgLy8gQXR0ZW1wdCB0byBtYWtlIHRoZSBwYXRoIG1vcmUgZnJpZW5kbHkgZm9yIGVycm9yIG1lc3NhZ2UgaW50ZXJwb2xhdGlvbi5cbiAgICBjb25zdCBwYXRoID0gcGFyYW1zLmxhYmVsIHx8IHBhcmFtcy5wYXRoIHx8ICd0aGlzJztcbiAgICAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgcGF0aCB1bmRlciBgb3JpZ2luYWxQYXRoYCBzbyBpdCBpc24ndCBsb3N0IHRvIGN1c3RvbVxuICAgIC8vIG1lc3NhZ2UgZnVuY3Rpb25zOyBlLmcuLCBvbmVzIHByb3ZpZGVkIGluIGBzZXRMb2NhbGUoKWAgY2FsbHMuXG4gICAgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLCB7XG4gICAgICBwYXRoLFxuICAgICAgb3JpZ2luYWxQYXRoOiBwYXJhbXMucGF0aFxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHJldHVybiBtZXNzYWdlLnJlcGxhY2Uoc3RyUmVnLCAoXywga2V5KSA9PiBwcmludFZhbHVlKHBhcmFtc1trZXldKSk7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnZnVuY3Rpb24nKSByZXR1cm4gbWVzc2FnZShwYXJhbXMpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIHN0YXRpYyBpc0Vycm9yKGVycikge1xuICAgIHJldHVybiBlcnIgJiYgZXJyLm5hbWUgPT09ICdWYWxpZGF0aW9uRXJyb3InO1xuICB9XG4gIGNvbnN0cnVjdG9yKGVycm9yT3JFcnJvcnMsIHZhbHVlLCBmaWVsZCwgdHlwZSwgZGlzYWJsZVN0YWNrKSB7XG4gICAgY29uc3QgZXJyb3JOb1N0YWNrID0gbmV3IFZhbGlkYXRpb25FcnJvck5vU3RhY2soZXJyb3JPckVycm9ycywgdmFsdWUsIGZpZWxkLCB0eXBlKTtcbiAgICBpZiAoZGlzYWJsZVN0YWNrKSB7XG4gICAgICByZXR1cm4gZXJyb3JOb1N0YWNrO1xuICAgIH1cbiAgICBzdXBlcigpO1xuICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXRoID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcmFtcyA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMuaW5uZXIgPSBbXTtcbiAgICB0aGlzW19TeW1ib2wkdG9TdHJpbmdUYWcyXSA9ICdFcnJvcic7XG4gICAgdGhpcy5uYW1lID0gZXJyb3JOb1N0YWNrLm5hbWU7XG4gICAgdGhpcy5tZXNzYWdlID0gZXJyb3JOb1N0YWNrLm1lc3NhZ2U7XG4gICAgdGhpcy50eXBlID0gZXJyb3JOb1N0YWNrLnR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IGVycm9yTm9TdGFjay52YWx1ZTtcbiAgICB0aGlzLnBhdGggPSBlcnJvck5vU3RhY2sucGF0aDtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9yTm9TdGFjay5lcnJvcnM7XG4gICAgdGhpcy5pbm5lciA9IGVycm9yTm9TdGFjay5pbm5lcjtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFZhbGlkYXRpb25FcnJvcik7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBbX1N5bWJvbCRoYXNJbnN0YW5jZV0oaW5zdCkge1xuICAgIHJldHVybiBWYWxpZGF0aW9uRXJyb3JOb1N0YWNrW1N5bWJvbC5oYXNJbnN0YW5jZV0oaW5zdCkgfHwgc3VwZXJbU3ltYm9sLmhhc0luc3RhbmNlXShpbnN0KTtcbiAgfVxufVxuXG5sZXQgbWl4ZWQgPSB7XG4gIGRlZmF1bHQ6ICcke3BhdGh9IGlzIGludmFsaWQnLFxuICByZXF1aXJlZDogJyR7cGF0aH0gaXMgYSByZXF1aXJlZCBmaWVsZCcsXG4gIGRlZmluZWQ6ICcke3BhdGh9IG11c3QgYmUgZGVmaW5lZCcsXG4gIG5vdE51bGw6ICcke3BhdGh9IGNhbm5vdCBiZSBudWxsJyxcbiAgb25lT2Y6ICcke3BhdGh9IG11c3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiAke3ZhbHVlc30nLFxuICBub3RPbmVPZjogJyR7cGF0aH0gbXVzdCBub3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiAke3ZhbHVlc30nLFxuICBub3RUeXBlOiAoe1xuICAgIHBhdGgsXG4gICAgdHlwZSxcbiAgICB2YWx1ZSxcbiAgICBvcmlnaW5hbFZhbHVlXG4gIH0pID0+IHtcbiAgICBjb25zdCBjYXN0TXNnID0gb3JpZ2luYWxWYWx1ZSAhPSBudWxsICYmIG9yaWdpbmFsVmFsdWUgIT09IHZhbHVlID8gYCAoY2FzdCBmcm9tIHRoZSB2YWx1ZSBcXGAke3ByaW50VmFsdWUob3JpZ2luYWxWYWx1ZSwgdHJ1ZSl9XFxgKS5gIDogJy4nO1xuICAgIHJldHVybiB0eXBlICE9PSAnbWl4ZWQnID8gYCR7cGF0aH0gbXVzdCBiZSBhIFxcYCR7dHlwZX1cXGAgdHlwZSwgYCArIGBidXQgdGhlIGZpbmFsIHZhbHVlIHdhczogXFxgJHtwcmludFZhbHVlKHZhbHVlLCB0cnVlKX1cXGBgICsgY2FzdE1zZyA6IGAke3BhdGh9IG11c3QgbWF0Y2ggdGhlIGNvbmZpZ3VyZWQgdHlwZS4gYCArIGBUaGUgdmFsaWRhdGVkIHZhbHVlIHdhczogXFxgJHtwcmludFZhbHVlKHZhbHVlLCB0cnVlKX1cXGBgICsgY2FzdE1zZztcbiAgfVxufTtcbmxldCBzdHJpbmcgPSB7XG4gIGxlbmd0aDogJyR7cGF0aH0gbXVzdCBiZSBleGFjdGx5ICR7bGVuZ3RofSBjaGFyYWN0ZXJzJyxcbiAgbWluOiAnJHtwYXRofSBtdXN0IGJlIGF0IGxlYXN0ICR7bWlufSBjaGFyYWN0ZXJzJyxcbiAgbWF4OiAnJHtwYXRofSBtdXN0IGJlIGF0IG1vc3QgJHttYXh9IGNoYXJhY3RlcnMnLFxuICBtYXRjaGVzOiAnJHtwYXRofSBtdXN0IG1hdGNoIHRoZSBmb2xsb3dpbmc6IFwiJHtyZWdleH1cIicsXG4gIGVtYWlsOiAnJHtwYXRofSBtdXN0IGJlIGEgdmFsaWQgZW1haWwnLFxuICB1cmw6ICcke3BhdGh9IG11c3QgYmUgYSB2YWxpZCBVUkwnLFxuICB1dWlkOiAnJHtwYXRofSBtdXN0IGJlIGEgdmFsaWQgVVVJRCcsXG4gIGRhdGV0aW1lOiAnJHtwYXRofSBtdXN0IGJlIGEgdmFsaWQgSVNPIGRhdGUtdGltZScsXG4gIGRhdGV0aW1lX3ByZWNpc2lvbjogJyR7cGF0aH0gbXVzdCBiZSBhIHZhbGlkIElTTyBkYXRlLXRpbWUgd2l0aCBhIHN1Yi1zZWNvbmQgcHJlY2lzaW9uIG9mIGV4YWN0bHkgJHtwcmVjaXNpb259IGRpZ2l0cycsXG4gIGRhdGV0aW1lX29mZnNldDogJyR7cGF0aH0gbXVzdCBiZSBhIHZhbGlkIElTTyBkYXRlLXRpbWUgd2l0aCBVVEMgXCJaXCIgdGltZXpvbmUnLFxuICB0cmltOiAnJHtwYXRofSBtdXN0IGJlIGEgdHJpbW1lZCBzdHJpbmcnLFxuICBsb3dlcmNhc2U6ICcke3BhdGh9IG11c3QgYmUgYSBsb3dlcmNhc2Ugc3RyaW5nJyxcbiAgdXBwZXJjYXNlOiAnJHtwYXRofSBtdXN0IGJlIGEgdXBwZXIgY2FzZSBzdHJpbmcnXG59O1xubGV0IG51bWJlciA9IHtcbiAgbWluOiAnJHtwYXRofSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke21pbn0nLFxuICBtYXg6ICcke3BhdGh9IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7bWF4fScsXG4gIGxlc3NUaGFuOiAnJHtwYXRofSBtdXN0IGJlIGxlc3MgdGhhbiAke2xlc3N9JyxcbiAgbW9yZVRoYW46ICcke3BhdGh9IG11c3QgYmUgZ3JlYXRlciB0aGFuICR7bW9yZX0nLFxuICBwb3NpdGl2ZTogJyR7cGF0aH0gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicsXG4gIG5lZ2F0aXZlOiAnJHtwYXRofSBtdXN0IGJlIGEgbmVnYXRpdmUgbnVtYmVyJyxcbiAgaW50ZWdlcjogJyR7cGF0aH0gbXVzdCBiZSBhbiBpbnRlZ2VyJ1xufTtcbmxldCBkYXRlID0ge1xuICBtaW46ICcke3BhdGh9IGZpZWxkIG11c3QgYmUgbGF0ZXIgdGhhbiAke21pbn0nLFxuICBtYXg6ICcke3BhdGh9IGZpZWxkIG11c3QgYmUgYXQgZWFybGllciB0aGFuICR7bWF4fSdcbn07XG5sZXQgYm9vbGVhbiA9IHtcbiAgaXNWYWx1ZTogJyR7cGF0aH0gZmllbGQgbXVzdCBiZSAke3ZhbHVlfSdcbn07XG5sZXQgb2JqZWN0ID0ge1xuICBub1Vua25vd246ICcke3BhdGh9IGZpZWxkIGhhcyB1bnNwZWNpZmllZCBrZXlzOiAke3Vua25vd259JyxcbiAgZXhhY3Q6ICcke3BhdGh9IG9iamVjdCBjb250YWlucyB1bmtub3duIHByb3BlcnRpZXM6ICR7cHJvcGVydGllc30nXG59O1xubGV0IGFycmF5ID0ge1xuICBtaW46ICcke3BhdGh9IGZpZWxkIG11c3QgaGF2ZSBhdCBsZWFzdCAke21pbn0gaXRlbXMnLFxuICBtYXg6ICcke3BhdGh9IGZpZWxkIG11c3QgaGF2ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJHttYXh9IGl0ZW1zJyxcbiAgbGVuZ3RoOiAnJHtwYXRofSBtdXN0IGhhdmUgJHtsZW5ndGh9IGl0ZW1zJ1xufTtcbmxldCB0dXBsZSA9IHtcbiAgbm90VHlwZTogcGFyYW1zID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBwYXRoLFxuICAgICAgdmFsdWUsXG4gICAgICBzcGVjXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlTGVuID0gc3BlYy50eXBlcy5sZW5ndGg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoIDwgdHlwZUxlbikgcmV0dXJuIGAke3BhdGh9IHR1cGxlIHZhbHVlIGhhcyB0b28gZmV3IGl0ZW1zLCBleHBlY3RlZCBhIGxlbmd0aCBvZiAke3R5cGVMZW59IGJ1dCBnb3QgJHt2YWx1ZS5sZW5ndGh9IGZvciB2YWx1ZTogXFxgJHtwcmludFZhbHVlKHZhbHVlLCB0cnVlKX1cXGBgO1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IHR5cGVMZW4pIHJldHVybiBgJHtwYXRofSB0dXBsZSB2YWx1ZSBoYXMgdG9vIG1hbnkgaXRlbXMsIGV4cGVjdGVkIGEgbGVuZ3RoIG9mICR7dHlwZUxlbn0gYnV0IGdvdCAke3ZhbHVlLmxlbmd0aH0gZm9yIHZhbHVlOiBcXGAke3ByaW50VmFsdWUodmFsdWUsIHRydWUpfVxcYGA7XG4gICAgfVxuICAgIHJldHVybiBWYWxpZGF0aW9uRXJyb3IuZm9ybWF0RXJyb3IobWl4ZWQubm90VHlwZSwgcGFyYW1zKTtcbiAgfVxufTtcbnZhciBsb2NhbGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgbWl4ZWQsXG4gIHN0cmluZyxcbiAgbnVtYmVyLFxuICBkYXRlLFxuICBvYmplY3QsXG4gIGFycmF5LFxuICBib29sZWFuLFxuICB0dXBsZVxufSk7XG5cbmNvbnN0IGlzU2NoZW1hID0gb2JqID0+IG9iaiAmJiBvYmouX19pc1l1cFNjaGVtYV9fO1xuXG5jbGFzcyBDb25kaXRpb24ge1xuICBzdGF0aWMgZnJvbU9wdGlvbnMocmVmcywgY29uZmlnKSB7XG4gICAgaWYgKCFjb25maWcudGhlbiAmJiAhY29uZmlnLm90aGVyd2lzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignZWl0aGVyIGB0aGVuOmAgb3IgYG90aGVyd2lzZTpgIGlzIHJlcXVpcmVkIGZvciBgd2hlbigpYCBjb25kaXRpb25zJyk7XG4gICAgbGV0IHtcbiAgICAgIGlzLFxuICAgICAgdGhlbixcbiAgICAgIG90aGVyd2lzZVxuICAgIH0gPSBjb25maWc7XG4gICAgbGV0IGNoZWNrID0gdHlwZW9mIGlzID09PSAnZnVuY3Rpb24nID8gaXMgOiAoLi4udmFsdWVzKSA9PiB2YWx1ZXMuZXZlcnkodmFsdWUgPT4gdmFsdWUgPT09IGlzKTtcbiAgICByZXR1cm4gbmV3IENvbmRpdGlvbihyZWZzLCAodmFsdWVzLCBzY2hlbWEpID0+IHtcbiAgICAgIHZhciBfYnJhbmNoO1xuICAgICAgbGV0IGJyYW5jaCA9IGNoZWNrKC4uLnZhbHVlcykgPyB0aGVuIDogb3RoZXJ3aXNlO1xuICAgICAgcmV0dXJuIChfYnJhbmNoID0gYnJhbmNoID09IG51bGwgPyB2b2lkIDAgOiBicmFuY2goc2NoZW1hKSkgIT0gbnVsbCA/IF9icmFuY2ggOiBzY2hlbWE7XG4gICAgfSk7XG4gIH1cbiAgY29uc3RydWN0b3IocmVmcywgYnVpbGRlcikge1xuICAgIHRoaXMuZm4gPSB2b2lkIDA7XG4gICAgdGhpcy5yZWZzID0gcmVmcztcbiAgICB0aGlzLnJlZnMgPSByZWZzO1xuICAgIHRoaXMuZm4gPSBidWlsZGVyO1xuICB9XG4gIHJlc29sdmUoYmFzZSwgb3B0aW9ucykge1xuICAgIGxldCB2YWx1ZXMgPSB0aGlzLnJlZnMubWFwKHJlZiA9PlxuICAgIC8vIFRPRE86ID8gb3BlcmF0b3IgaGVyZT9cbiAgICByZWYuZ2V0VmFsdWUob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy52YWx1ZSwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wYXJlbnQsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udGV4dCkpO1xuICAgIGxldCBzY2hlbWEgPSB0aGlzLmZuKHZhbHVlcywgYmFzZSwgb3B0aW9ucyk7XG4gICAgaWYgKHNjaGVtYSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgLy8gQHRzLWlnbm9yZSB0aGlzIGNhbiBiZSBiYXNlXG4gICAgc2NoZW1hID09PSBiYXNlKSB7XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gICAgaWYgKCFpc1NjaGVtYShzY2hlbWEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb25kaXRpb25zIG11c3QgcmV0dXJuIGEgc2NoZW1hIG9iamVjdCcpO1xuICAgIHJldHVybiBzY2hlbWEucmVzb2x2ZShvcHRpb25zKTtcbiAgfVxufVxuXG5jb25zdCBwcmVmaXhlcyA9IHtcbiAgY29udGV4dDogJyQnLFxuICB2YWx1ZTogJy4nXG59O1xuZnVuY3Rpb24gY3JlYXRlJDkoa2V5LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUmVmZXJlbmNlKGtleSwgb3B0aW9ucyk7XG59XG5jbGFzcyBSZWZlcmVuY2Uge1xuICBjb25zdHJ1Y3RvcihrZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuaXNDb250ZXh0ID0gdm9pZCAwO1xuICAgIHRoaXMuaXNWYWx1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmlzU2libGluZyA9IHZvaWQgMDtcbiAgICB0aGlzLnBhdGggPSB2b2lkIDA7XG4gICAgdGhpcy5nZXR0ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5tYXAgPSB2b2lkIDA7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWYgbXVzdCBiZSBhIHN0cmluZywgZ290OiAnICsga2V5KTtcbiAgICB0aGlzLmtleSA9IGtleS50cmltKCk7XG4gICAgaWYgKGtleSA9PT0gJycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIHRoaXMuaXNDb250ZXh0ID0gdGhpcy5rZXlbMF0gPT09IHByZWZpeGVzLmNvbnRleHQ7XG4gICAgdGhpcy5pc1ZhbHVlID0gdGhpcy5rZXlbMF0gPT09IHByZWZpeGVzLnZhbHVlO1xuICAgIHRoaXMuaXNTaWJsaW5nID0gIXRoaXMuaXNDb250ZXh0ICYmICF0aGlzLmlzVmFsdWU7XG4gICAgbGV0IHByZWZpeCA9IHRoaXMuaXNDb250ZXh0ID8gcHJlZml4ZXMuY29udGV4dCA6IHRoaXMuaXNWYWx1ZSA/IHByZWZpeGVzLnZhbHVlIDogJyc7XG4gICAgdGhpcy5wYXRoID0gdGhpcy5rZXkuc2xpY2UocHJlZml4Lmxlbmd0aCk7XG4gICAgdGhpcy5nZXR0ZXIgPSB0aGlzLnBhdGggJiYgZ2V0dGVyKHRoaXMucGF0aCwgdHJ1ZSk7XG4gICAgdGhpcy5tYXAgPSBvcHRpb25zLm1hcDtcbiAgfVxuICBnZXRWYWx1ZSh2YWx1ZSwgcGFyZW50LCBjb250ZXh0KSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuaXNDb250ZXh0ID8gY29udGV4dCA6IHRoaXMuaXNWYWx1ZSA/IHZhbHVlIDogcGFyZW50O1xuICAgIGlmICh0aGlzLmdldHRlcikgcmVzdWx0ID0gdGhpcy5nZXR0ZXIocmVzdWx0IHx8IHt9KTtcbiAgICBpZiAodGhpcy5tYXApIHJlc3VsdCA9IHRoaXMubWFwKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucy5jb250ZXh0XG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucy5wYXJlbnRcbiAgICovXG4gIGNhc3QodmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSh2YWx1ZSwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wYXJlbnQsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udGV4dCk7XG4gIH1cbiAgcmVzb2x2ZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZXNjcmliZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3JlZicsXG4gICAgICBrZXk6IHRoaXMua2V5XG4gICAgfTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFJlZigke3RoaXMua2V5fSlgO1xuICB9XG4gIHN0YXRpYyBpc1JlZih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5fX2lzWXVwUmVmO1xuICB9XG59XG5cbi8vIEB0cy1pZ25vcmVcblJlZmVyZW5jZS5wcm90b3R5cGUuX19pc1l1cFJlZiA9IHRydWU7XG5cbmNvbnN0IGlzQWJzZW50ID0gdmFsdWUgPT4gdmFsdWUgPT0gbnVsbDtcblxuZnVuY3Rpb24gY3JlYXRlVmFsaWRhdGlvbihjb25maWcpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUoe1xuICAgIHZhbHVlLFxuICAgIHBhdGggPSAnJyxcbiAgICBvcHRpb25zLFxuICAgIG9yaWdpbmFsVmFsdWUsXG4gICAgc2NoZW1hXG4gIH0sIHBhbmljLCBuZXh0KSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHRlc3QsXG4gICAgICBwYXJhbXMsXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2tpcEFic2VudFxuICAgIH0gPSBjb25maWc7XG4gICAgbGV0IHtcbiAgICAgIHBhcmVudCxcbiAgICAgIGNvbnRleHQsXG4gICAgICBhYm9ydEVhcmx5ID0gc2NoZW1hLnNwZWMuYWJvcnRFYXJseSxcbiAgICAgIGRpc2FibGVTdGFja1RyYWNlID0gc2NoZW1hLnNwZWMuZGlzYWJsZVN0YWNrVHJhY2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICBmdW5jdGlvbiByZXNvbHZlKGl0ZW0pIHtcbiAgICAgIHJldHVybiBSZWZlcmVuY2UuaXNSZWYoaXRlbSkgPyBpdGVtLmdldFZhbHVlKHZhbHVlLCBwYXJlbnQsIGNvbnRleHQpIDogaXRlbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRXJyb3Iob3ZlcnJpZGVzID0ge30pIHtcbiAgICAgIGNvbnN0IG5leHRQYXJhbXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG9yaWdpbmFsVmFsdWUsXG4gICAgICAgIGxhYmVsOiBzY2hlbWEuc3BlYy5sYWJlbCxcbiAgICAgICAgcGF0aDogb3ZlcnJpZGVzLnBhdGggfHwgcGF0aCxcbiAgICAgICAgc3BlYzogc2NoZW1hLnNwZWMsXG4gICAgICAgIGRpc2FibGVTdGFja1RyYWNlOiBvdmVycmlkZXMuZGlzYWJsZVN0YWNrVHJhY2UgfHwgZGlzYWJsZVN0YWNrVHJhY2VcbiAgICAgIH0sIHBhcmFtcywgb3ZlcnJpZGVzLnBhcmFtcyk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhuZXh0UGFyYW1zKSkgbmV4dFBhcmFtc1trZXldID0gcmVzb2x2ZShuZXh0UGFyYW1zW2tleV0pO1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgVmFsaWRhdGlvbkVycm9yKFZhbGlkYXRpb25FcnJvci5mb3JtYXRFcnJvcihvdmVycmlkZXMubWVzc2FnZSB8fCBtZXNzYWdlLCBuZXh0UGFyYW1zKSwgdmFsdWUsIG5leHRQYXJhbXMucGF0aCwgb3ZlcnJpZGVzLnR5cGUgfHwgbmFtZSwgbmV4dFBhcmFtcy5kaXNhYmxlU3RhY2tUcmFjZSk7XG4gICAgICBlcnJvci5wYXJhbXMgPSBuZXh0UGFyYW1zO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBpbnZhbGlkID0gYWJvcnRFYXJseSA/IHBhbmljIDogbmV4dDtcbiAgICBsZXQgY3R4ID0ge1xuICAgICAgcGF0aCxcbiAgICAgIHBhcmVudCxcbiAgICAgIHR5cGU6IG5hbWUsXG4gICAgICBmcm9tOiBvcHRpb25zLmZyb20sXG4gICAgICBjcmVhdGVFcnJvcixcbiAgICAgIHJlc29sdmUsXG4gICAgICBvcHRpb25zLFxuICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICAgIHNjaGVtYVxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlUmVzdWx0ID0gdmFsaWRPckVycm9yID0+IHtcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcih2YWxpZE9yRXJyb3IpKSBpbnZhbGlkKHZhbGlkT3JFcnJvcik7ZWxzZSBpZiAoIXZhbGlkT3JFcnJvcikgaW52YWxpZChjcmVhdGVFcnJvcigpKTtlbHNlIG5leHQobnVsbCk7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVFcnJvciA9IGVyciA9PiB7XG4gICAgICBpZiAoVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IoZXJyKSkgaW52YWxpZChlcnIpO2Vsc2UgcGFuaWMoZXJyKTtcbiAgICB9O1xuICAgIGNvbnN0IHNob3VsZFNraXAgPSBza2lwQWJzZW50ICYmIGlzQWJzZW50KHZhbHVlKTtcbiAgICBpZiAoc2hvdWxkU2tpcCkge1xuICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdCh0cnVlKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgdmFyIF9yZXN1bHQ7XG4gICAgICByZXN1bHQgPSB0ZXN0LmNhbGwoY3R4LCB2YWx1ZSwgY3R4KTtcbiAgICAgIGlmICh0eXBlb2YgKChfcmVzdWx0ID0gcmVzdWx0KSA9PSBudWxsID8gdm9pZCAwIDogX3Jlc3VsdC50aGVuKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAob3B0aW9ucy5zeW5jKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWxpZGF0aW9uIHRlc3Qgb2YgdHlwZTogXCIke2N0eC50eXBlfVwiIHJldHVybmVkIGEgUHJvbWlzZSBkdXJpbmcgYSBzeW5jaHJvbm91cyB2YWxpZGF0ZS4gYCArIGBUaGlzIHRlc3Qgd2lsbCBmaW5pc2ggYWZ0ZXIgdGhlIHZhbGlkYXRlIGNhbGwgaGFzIHJldHVybmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4oaGFuZGxlUmVzdWx0LCBoYW5kbGVFcnJvcik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYW5kbGVSZXN1bHQocmVzdWx0KTtcbiAgfVxuICB2YWxpZGF0ZS5PUFRJT05TID0gY29uZmlnO1xuICByZXR1cm4gdmFsaWRhdGU7XG59XG5cbmZ1bmN0aW9uIGdldEluKHNjaGVtYSwgcGF0aCwgdmFsdWUsIGNvbnRleHQgPSB2YWx1ZSkge1xuICBsZXQgcGFyZW50LCBsYXN0UGFydCwgbGFzdFBhcnREZWJ1ZztcblxuICAvLyByb290IHBhdGg6ICcnXG4gIGlmICghcGF0aCkgcmV0dXJuIHtcbiAgICBwYXJlbnQsXG4gICAgcGFyZW50UGF0aDogcGF0aCxcbiAgICBzY2hlbWFcbiAgfTtcbiAgZm9yRWFjaChwYXRoLCAoX3BhcnQsIGlzQnJhY2tldCwgaXNBcnJheSkgPT4ge1xuICAgIGxldCBwYXJ0ID0gaXNCcmFja2V0ID8gX3BhcnQuc2xpY2UoMSwgX3BhcnQubGVuZ3RoIC0gMSkgOiBfcGFydDtcbiAgICBzY2hlbWEgPSBzY2hlbWEucmVzb2x2ZSh7XG4gICAgICBjb250ZXh0LFxuICAgICAgcGFyZW50LFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICBsZXQgaXNUdXBsZSA9IHNjaGVtYS50eXBlID09PSAndHVwbGUnO1xuICAgIGxldCBpZHggPSBpc0FycmF5ID8gcGFyc2VJbnQocGFydCwgMTApIDogMDtcbiAgICBpZiAoc2NoZW1hLmlubmVyVHlwZSB8fCBpc1R1cGxlKSB7XG4gICAgICBpZiAoaXNUdXBsZSAmJiAhaXNBcnJheSkgdGhyb3cgbmV3IEVycm9yKGBZdXAucmVhY2ggY2Fubm90IGltcGxpY2l0bHkgaW5kZXggaW50byBhIHR1cGxlIHR5cGUuIHRoZSBwYXRoIHBhcnQgXCIke2xhc3RQYXJ0RGVidWd9XCIgbXVzdCBjb250YWluIGFuIGluZGV4IHRvIHRoZSB0dXBsZSBlbGVtZW50LCBlLmcuIFwiJHtsYXN0UGFydERlYnVnfVswXVwiYCk7XG4gICAgICBpZiAodmFsdWUgJiYgaWR4ID49IHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFl1cC5yZWFjaCBjYW5ub3QgcmVzb2x2ZSBhbiBhcnJheSBpdGVtIGF0IGluZGV4OiAke19wYXJ0fSwgaW4gdGhlIHBhdGg6ICR7cGF0aH0uIGAgKyBgYmVjYXVzZSB0aGVyZSBpcyBubyB2YWx1ZSBhdCB0aGF0IGluZGV4LiBgKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHZhbHVlO1xuICAgICAgdmFsdWUgPSB2YWx1ZSAmJiB2YWx1ZVtpZHhdO1xuICAgICAgc2NoZW1hID0gaXNUdXBsZSA/IHNjaGVtYS5zcGVjLnR5cGVzW2lkeF0gOiBzY2hlbWEuaW5uZXJUeXBlO1xuICAgIH1cblxuICAgIC8vIHNvbWV0aW1lcyB0aGUgYXJyYXkgaW5kZXggcGFydCBvZiBhIHBhdGggZG9lc24ndCBleGlzdDogXCJuZXN0ZWQuYXJyLmNoaWxkXCJcbiAgICAvLyBpbiB0aGVzZSBjYXNlcyB0aGUgY3VycmVudCBwYXJ0IGlzIHRoZSBuZXh0IHNjaGVtYSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZFxuICAgIC8vIGluIHRoaXMgaXRlcmF0aW9uLiBGb3IgY2FzZXMgd2hlcmUgdGhlIGluZGV4IHNpZ25hdHVyZSBpcyBpbmNsdWRlZCB0aGlzXG4gICAgLy8gY2hlY2sgd2lsbCBmYWlsIGFuZCB3ZSdsbCBoYW5kbGUgdGhlIGBjaGlsZGAgcGFydCBvbiB0aGUgbmV4dCBpdGVyYXRpb24gbGlrZSBub3JtYWxcbiAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgIGlmICghc2NoZW1hLmZpZWxkcyB8fCAhc2NoZW1hLmZpZWxkc1twYXJ0XSkgdGhyb3cgbmV3IEVycm9yKGBUaGUgc2NoZW1hIGRvZXMgbm90IGNvbnRhaW4gdGhlIHBhdGg6ICR7cGF0aH0uIGAgKyBgKGZhaWxlZCBhdDogJHtsYXN0UGFydERlYnVnfSB3aGljaCBpcyBhIHR5cGU6IFwiJHtzY2hlbWEudHlwZX1cIilgKTtcbiAgICAgIHBhcmVudCA9IHZhbHVlO1xuICAgICAgdmFsdWUgPSB2YWx1ZSAmJiB2YWx1ZVtwYXJ0XTtcbiAgICAgIHNjaGVtYSA9IHNjaGVtYS5maWVsZHNbcGFydF07XG4gICAgfVxuICAgIGxhc3RQYXJ0ID0gcGFydDtcbiAgICBsYXN0UGFydERlYnVnID0gaXNCcmFja2V0ID8gJ1snICsgX3BhcnQgKyAnXScgOiAnLicgKyBfcGFydDtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc2NoZW1hLFxuICAgIHBhcmVudCxcbiAgICBwYXJlbnRQYXRoOiBsYXN0UGFydFxuICB9O1xufVxuZnVuY3Rpb24gcmVhY2gob2JqLCBwYXRoLCB2YWx1ZSwgY29udGV4dCkge1xuICByZXR1cm4gZ2V0SW4ob2JqLCBwYXRoLCB2YWx1ZSwgY29udGV4dCkuc2NoZW1hO1xufVxuXG5jbGFzcyBSZWZlcmVuY2VTZXQgZXh0ZW5kcyBTZXQge1xuICBkZXNjcmliZSgpIHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLnZhbHVlcygpKSB7XG4gICAgICBkZXNjcmlwdGlvbi5wdXNoKFJlZmVyZW5jZS5pc1JlZihpdGVtKSA/IGl0ZW0uZGVzY3JpYmUoKSA6IGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gIH1cbiAgcmVzb2x2ZUFsbChyZXNvbHZlKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLnZhbHVlcygpKSB7XG4gICAgICByZXN1bHQucHVzaChyZXNvbHZlKGl0ZW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFJlZmVyZW5jZVNldCh0aGlzLnZhbHVlcygpKTtcbiAgfVxuICBtZXJnZShuZXdJdGVtcywgcmVtb3ZlSXRlbXMpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIG5ld0l0ZW1zLmZvckVhY2godmFsdWUgPT4gbmV4dC5hZGQodmFsdWUpKTtcbiAgICByZW1vdmVJdGVtcy5mb3JFYWNoKHZhbHVlID0+IG5leHQuZGVsZXRlKHZhbHVlKSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbn1cblxuLy8gdHdlYWtlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9LZWxpbjIwMjUvbmFub2Nsb25lL2Jsb2IvMGFiZWI3NjM1YmRhOWI2OGVmMjI3NzA5M2Y3NmRiZTNiZjM5NDhlMS9zcmMvaW5kZXguanNcbmZ1bmN0aW9uIGNsb25lKHNyYywgc2VlbiA9IG5ldyBNYXAoKSkge1xuICBpZiAoaXNTY2hlbWEoc3JjKSB8fCAhc3JjIHx8IHR5cGVvZiBzcmMgIT09ICdvYmplY3QnKSByZXR1cm4gc3JjO1xuICBpZiAoc2Vlbi5oYXMoc3JjKSkgcmV0dXJuIHNlZW4uZ2V0KHNyYyk7XG4gIGxldCBjb3B5O1xuICBpZiAoc3JjIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIC8vIERhdGVcbiAgICBjb3B5ID0gbmV3IERhdGUoc3JjLmdldFRpbWUoKSk7XG4gICAgc2Vlbi5zZXQoc3JjLCBjb3B5KTtcbiAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAvLyBSZWdFeHBcbiAgICBjb3B5ID0gbmV3IFJlZ0V4cChzcmMpO1xuICAgIHNlZW4uc2V0KHNyYywgY29weSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgLy8gQXJyYXlcbiAgICBjb3B5ID0gbmV3IEFycmF5KHNyYy5sZW5ndGgpO1xuICAgIHNlZW4uc2V0KHNyYywgY29weSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcmMubGVuZ3RoOyBpKyspIGNvcHlbaV0gPSBjbG9uZShzcmNbaV0sIHNlZW4pO1xuICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIE1hcCkge1xuICAgIC8vIE1hcFxuICAgIGNvcHkgPSBuZXcgTWFwKCk7XG4gICAgc2Vlbi5zZXQoc3JjLCBjb3B5KTtcbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBzcmMuZW50cmllcygpKSBjb3B5LnNldChrLCBjbG9uZSh2LCBzZWVuKSk7XG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgLy8gU2V0XG4gICAgY29weSA9IG5ldyBTZXQoKTtcbiAgICBzZWVuLnNldChzcmMsIGNvcHkpO1xuICAgIGZvciAoY29uc3QgdiBvZiBzcmMpIGNvcHkuYWRkKGNsb25lKHYsIHNlZW4pKTtcbiAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAvLyBPYmplY3RcbiAgICBjb3B5ID0ge307XG4gICAgc2Vlbi5zZXQoc3JjLCBjb3B5KTtcbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhzcmMpKSBjb3B5W2tdID0gY2xvbmUodiwgc2Vlbik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoYFVuYWJsZSB0byBjbG9uZSAke3NyY31gKTtcbiAgfVxuICByZXR1cm4gY29weTtcbn1cblxuLy8gSWYgYEN1c3RvbVNjaGVtYU1ldGFgIGlzbid0IGV4dGVuZGVkIHdpdGggYW55IGtleXMsIHdlJ2xsIGZhbGwgYmFjayB0byBhXG4vLyBsb29zZSBSZWNvcmQgZGVmaW5pdGlvbiBhbGxvd2luZyBmcmVlIGZvcm0gdXNhZ2UuXG5jbGFzcyBTY2hlbWEge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gdm9pZCAwO1xuICAgIHRoaXMuZGVwcyA9IFtdO1xuICAgIHRoaXMudGVzdHMgPSB2b2lkIDA7XG4gICAgdGhpcy50cmFuc2Zvcm1zID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZGl0aW9ucyA9IFtdO1xuICAgIHRoaXMuX211dGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmludGVybmFsVGVzdHMgPSB7fTtcbiAgICB0aGlzLl93aGl0ZWxpc3QgPSBuZXcgUmVmZXJlbmNlU2V0KCk7XG4gICAgdGhpcy5fYmxhY2tsaXN0ID0gbmV3IFJlZmVyZW5jZVNldCgpO1xuICAgIHRoaXMuZXhjbHVzaXZlVGVzdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX3R5cGVDaGVjayA9IHZvaWQgMDtcbiAgICB0aGlzLnNwZWMgPSB2b2lkIDA7XG4gICAgdGhpcy50ZXN0cyA9IFtdO1xuICAgIHRoaXMudHJhbnNmb3JtcyA9IFtdO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMudHlwZUVycm9yKG1peGVkLm5vdFR5cGUpO1xuICAgIH0pO1xuICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICB0aGlzLl90eXBlQ2hlY2sgPSBvcHRpb25zLmNoZWNrO1xuICAgIHRoaXMuc3BlYyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgc3RyaXA6IGZhbHNlLFxuICAgICAgc3RyaWN0OiBmYWxzZSxcbiAgICAgIGFib3J0RWFybHk6IHRydWUsXG4gICAgICByZWN1cnNpdmU6IHRydWUsXG4gICAgICBkaXNhYmxlU3RhY2tUcmFjZTogZmFsc2UsXG4gICAgICBudWxsYWJsZTogZmFsc2UsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIGNvZXJjZTogdHJ1ZVxuICAgIH0sIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc3BlYyk7XG4gICAgdGhpcy53aXRoTXV0YXRpb24ocyA9PiB7XG4gICAgICBzLm5vbk51bGxhYmxlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBUT0RPOiByZW1vdmVcbiAgZ2V0IF90eXBlKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG4gIH1cbiAgY2xvbmUoc3BlYykge1xuICAgIGlmICh0aGlzLl9tdXRhdGUpIHtcbiAgICAgIGlmIChzcGVjKSBPYmplY3QuYXNzaWduKHRoaXMuc3BlYywgc3BlYyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgbmVzdGVkIHZhbHVlIGlzIGEgc2NoZW1hIHdlIGNhbiBza2lwIGNsb25pbmcsIHNpbmNlXG4gICAgLy8gdGhleSBhcmUgYWxyZWFkeSBpbW11dGFibGVcbiAgICBjb25zdCBuZXh0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIGlzIHJlYWRvbmx5XG4gICAgbmV4dC50eXBlID0gdGhpcy50eXBlO1xuICAgIG5leHQuX3R5cGVDaGVjayA9IHRoaXMuX3R5cGVDaGVjaztcbiAgICBuZXh0Ll93aGl0ZWxpc3QgPSB0aGlzLl93aGl0ZWxpc3QuY2xvbmUoKTtcbiAgICBuZXh0Ll9ibGFja2xpc3QgPSB0aGlzLl9ibGFja2xpc3QuY2xvbmUoKTtcbiAgICBuZXh0LmludGVybmFsVGVzdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmludGVybmFsVGVzdHMpO1xuICAgIG5leHQuZXhjbHVzaXZlVGVzdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmV4Y2x1c2l2ZVRlc3RzKTtcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdGhpcyBpcyByZWFkb25seVxuICAgIG5leHQuZGVwcyA9IFsuLi50aGlzLmRlcHNdO1xuICAgIG5leHQuY29uZGl0aW9ucyA9IFsuLi50aGlzLmNvbmRpdGlvbnNdO1xuICAgIG5leHQudGVzdHMgPSBbLi4udGhpcy50ZXN0c107XG4gICAgbmV4dC50cmFuc2Zvcm1zID0gWy4uLnRoaXMudHJhbnNmb3Jtc107XG4gICAgbmV4dC5zcGVjID0gY2xvbmUoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zcGVjLCBzcGVjKSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgbGFiZWwobGFiZWwpIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXh0LnNwZWMubGFiZWwgPSBsYWJlbDtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBtZXRhKC4uLmFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLnNwZWMubWV0YTtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXh0LnNwZWMubWV0YSA9IE9iamVjdC5hc3NpZ24obmV4dC5zcGVjLm1ldGEgfHwge30sIGFyZ3NbMF0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIHdpdGhNdXRhdGlvbihmbikge1xuICAgIGxldCBiZWZvcmUgPSB0aGlzLl9tdXRhdGU7XG4gICAgdGhpcy5fbXV0YXRlID0gdHJ1ZTtcbiAgICBsZXQgcmVzdWx0ID0gZm4odGhpcyk7XG4gICAgdGhpcy5fbXV0YXRlID0gYmVmb3JlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uY2F0KHNjaGVtYSkge1xuICAgIGlmICghc2NoZW1hIHx8IHNjaGVtYSA9PT0gdGhpcykgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHNjaGVtYS50eXBlICE9PSB0aGlzLnR5cGUgJiYgdGhpcy50eXBlICE9PSAnbWl4ZWQnKSB0aHJvdyBuZXcgVHlwZUVycm9yKGBZb3UgY2Fubm90IFxcYGNvbmNhdCgpXFxgIHNjaGVtYSdzIG9mIGRpZmZlcmVudCB0eXBlczogJHt0aGlzLnR5cGV9IGFuZCAke3NjaGVtYS50eXBlfWApO1xuICAgIGxldCBiYXNlID0gdGhpcztcbiAgICBsZXQgY29tYmluZWQgPSBzY2hlbWEuY2xvbmUoKTtcbiAgICBjb25zdCBtZXJnZWRTcGVjID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZS5zcGVjLCBjb21iaW5lZC5zcGVjKTtcbiAgICBjb21iaW5lZC5zcGVjID0gbWVyZ2VkU3BlYztcbiAgICBjb21iaW5lZC5pbnRlcm5hbFRlc3RzID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZS5pbnRlcm5hbFRlc3RzLCBjb21iaW5lZC5pbnRlcm5hbFRlc3RzKTtcblxuICAgIC8vIG1hbnVhbGx5IG1lcmdlIHRoZSBibGFja2xpc3Qvd2hpdGVsaXN0ICh0aGUgb3RoZXIgYHNjaGVtYWAgdGFrZXNcbiAgICAvLyBwcmVjZWRlbmNlIGluIGNhc2Ugb2YgY29uZmxpY3RzKVxuICAgIGNvbWJpbmVkLl93aGl0ZWxpc3QgPSBiYXNlLl93aGl0ZWxpc3QubWVyZ2Uoc2NoZW1hLl93aGl0ZWxpc3QsIHNjaGVtYS5fYmxhY2tsaXN0KTtcbiAgICBjb21iaW5lZC5fYmxhY2tsaXN0ID0gYmFzZS5fYmxhY2tsaXN0Lm1lcmdlKHNjaGVtYS5fYmxhY2tsaXN0LCBzY2hlbWEuX3doaXRlbGlzdCk7XG5cbiAgICAvLyBzdGFydCB3aXRoIHRoZSBjdXJyZW50IHRlc3RzXG4gICAgY29tYmluZWQudGVzdHMgPSBiYXNlLnRlc3RzO1xuICAgIGNvbWJpbmVkLmV4Y2x1c2l2ZVRlc3RzID0gYmFzZS5leGNsdXNpdmVUZXN0cztcblxuICAgIC8vIG1hbnVhbGx5IGFkZCB0aGUgbmV3IHRlc3RzIHRvIGVuc3VyZVxuICAgIC8vIHRoZSBkZWR1cGluZyBsb2dpYyBpcyBjb25zaXN0ZW50XG4gICAgY29tYmluZWQud2l0aE11dGF0aW9uKG5leHQgPT4ge1xuICAgICAgc2NoZW1hLnRlc3RzLmZvckVhY2goZm4gPT4ge1xuICAgICAgICBuZXh0LnRlc3QoZm4uT1BUSU9OUyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb21iaW5lZC50cmFuc2Zvcm1zID0gWy4uLmJhc2UudHJhbnNmb3JtcywgLi4uY29tYmluZWQudHJhbnNmb3Jtc107XG4gICAgcmV0dXJuIGNvbWJpbmVkO1xuICB9XG4gIGlzVHlwZSh2KSB7XG4gICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuc3BlYy5udWxsYWJsZSAmJiB2ID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLnNwZWMub3B0aW9uYWwgJiYgdiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3R5cGVDaGVjayh2KTtcbiAgfVxuICByZXNvbHZlKG9wdGlvbnMpIHtcbiAgICBsZXQgc2NoZW1hID0gdGhpcztcbiAgICBpZiAoc2NoZW1hLmNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgICBsZXQgY29uZGl0aW9ucyA9IHNjaGVtYS5jb25kaXRpb25zO1xuICAgICAgc2NoZW1hID0gc2NoZW1hLmNsb25lKCk7XG4gICAgICBzY2hlbWEuY29uZGl0aW9ucyA9IFtdO1xuICAgICAgc2NoZW1hID0gY29uZGl0aW9ucy5yZWR1Y2UoKHByZXZTY2hlbWEsIGNvbmRpdGlvbikgPT4gY29uZGl0aW9uLnJlc29sdmUocHJldlNjaGVtYSwgb3B0aW9ucyksIHNjaGVtYSk7XG4gICAgICBzY2hlbWEgPSBzY2hlbWEucmVzb2x2ZShvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfVxuICByZXNvbHZlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zJHN0cmljdCwgX29wdGlvbnMkYWJvcnRFYXJseSwgX29wdGlvbnMkcmVjdXJzaXZlLCBfb3B0aW9ucyRkaXNhYmxlU3RhY2s7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIGZyb206IG9wdGlvbnMuZnJvbSB8fCBbXSxcbiAgICAgIHN0cmljdDogKF9vcHRpb25zJHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0KSAhPSBudWxsID8gX29wdGlvbnMkc3RyaWN0IDogdGhpcy5zcGVjLnN0cmljdCxcbiAgICAgIGFib3J0RWFybHk6IChfb3B0aW9ucyRhYm9ydEVhcmx5ID0gb3B0aW9ucy5hYm9ydEVhcmx5KSAhPSBudWxsID8gX29wdGlvbnMkYWJvcnRFYXJseSA6IHRoaXMuc3BlYy5hYm9ydEVhcmx5LFxuICAgICAgcmVjdXJzaXZlOiAoX29wdGlvbnMkcmVjdXJzaXZlID0gb3B0aW9ucy5yZWN1cnNpdmUpICE9IG51bGwgPyBfb3B0aW9ucyRyZWN1cnNpdmUgOiB0aGlzLnNwZWMucmVjdXJzaXZlLFxuICAgICAgZGlzYWJsZVN0YWNrVHJhY2U6IChfb3B0aW9ucyRkaXNhYmxlU3RhY2sgPSBvcHRpb25zLmRpc2FibGVTdGFja1RyYWNlKSAhPSBudWxsID8gX29wdGlvbnMkZGlzYWJsZVN0YWNrIDogdGhpcy5zcGVjLmRpc2FibGVTdGFja1RyYWNlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUnVuIHRoZSBjb25maWd1cmVkIHRyYW5zZm9ybSBwaXBlbGluZSBvdmVyIGFuIGlucHV0IHZhbHVlLlxuICAgKi9cblxuICBjYXN0KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgcmVzb2x2ZWRTY2hlbWEgPSB0aGlzLnJlc29sdmUoT2JqZWN0LmFzc2lnbih7XG4gICAgICB2YWx1ZVxuICAgIH0sIG9wdGlvbnMpKTtcbiAgICBsZXQgYWxsb3dPcHRpb25hbGl0eSA9IG9wdGlvbnMuYXNzZXJ0ID09PSAnaWdub3JlLW9wdGlvbmFsaXR5JztcbiAgICBsZXQgcmVzdWx0ID0gcmVzb2x2ZWRTY2hlbWEuX2Nhc3QodmFsdWUsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmFzc2VydCAhPT0gZmFsc2UgJiYgIXJlc29sdmVkU2NoZW1hLmlzVHlwZShyZXN1bHQpKSB7XG4gICAgICBpZiAoYWxsb3dPcHRpb25hbGl0eSAmJiBpc0Fic2VudChyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsZXQgZm9ybWF0dGVkVmFsdWUgPSBwcmludFZhbHVlKHZhbHVlKTtcbiAgICAgIGxldCBmb3JtYXR0ZWRSZXN1bHQgPSBwcmludFZhbHVlKHJlc3VsdCk7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgdmFsdWUgb2YgJHtvcHRpb25zLnBhdGggfHwgJ2ZpZWxkJ30gY291bGQgbm90IGJlIGNhc3QgdG8gYSB2YWx1ZSBgICsgYHRoYXQgc2F0aXNmaWVzIHRoZSBzY2hlbWEgdHlwZTogXCIke3Jlc29sdmVkU2NoZW1hLnR5cGV9XCIuIFxcblxcbmAgKyBgYXR0ZW1wdGVkIHZhbHVlOiAke2Zvcm1hdHRlZFZhbHVlfSBcXG5gICsgKGZvcm1hdHRlZFJlc3VsdCAhPT0gZm9ybWF0dGVkVmFsdWUgPyBgcmVzdWx0IG9mIGNhc3Q6ICR7Zm9ybWF0dGVkUmVzdWx0fWAgOiAnJykpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIF9jYXN0KHJhd1ZhbHVlLCBvcHRpb25zKSB7XG4gICAgbGV0IHZhbHVlID0gcmF3VmFsdWUgPT09IHVuZGVmaW5lZCA/IHJhd1ZhbHVlIDogdGhpcy50cmFuc2Zvcm1zLnJlZHVjZSgocHJldlZhbHVlLCBmbikgPT4gZm4uY2FsbCh0aGlzLCBwcmV2VmFsdWUsIHJhd1ZhbHVlLCB0aGlzKSwgcmF3VmFsdWUpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuZ2V0RGVmYXVsdChvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIF92YWxpZGF0ZShfdmFsdWUsIG9wdGlvbnMgPSB7fSwgcGFuaWMsIG5leHQpIHtcbiAgICBsZXQge1xuICAgICAgcGF0aCxcbiAgICAgIG9yaWdpbmFsVmFsdWUgPSBfdmFsdWUsXG4gICAgICBzdHJpY3QgPSB0aGlzLnNwZWMuc3RyaWN0XG4gICAgfSA9IG9wdGlvbnM7XG4gICAgbGV0IHZhbHVlID0gX3ZhbHVlO1xuICAgIGlmICghc3RyaWN0KSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuX2Nhc3QodmFsdWUsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBhc3NlcnQ6IGZhbHNlXG4gICAgICB9LCBvcHRpb25zKSk7XG4gICAgfVxuICAgIGxldCBpbml0aWFsVGVzdHMgPSBbXTtcbiAgICBmb3IgKGxldCB0ZXN0IG9mIE9iamVjdC52YWx1ZXModGhpcy5pbnRlcm5hbFRlc3RzKSkge1xuICAgICAgaWYgKHRlc3QpIGluaXRpYWxUZXN0cy5wdXNoKHRlc3QpO1xuICAgIH1cbiAgICB0aGlzLnJ1blRlc3RzKHtcbiAgICAgIHBhdGgsXG4gICAgICB2YWx1ZSxcbiAgICAgIG9yaWdpbmFsVmFsdWUsXG4gICAgICBvcHRpb25zLFxuICAgICAgdGVzdHM6IGluaXRpYWxUZXN0c1xuICAgIH0sIHBhbmljLCBpbml0aWFsRXJyb3JzID0+IHtcbiAgICAgIC8vIGV2ZW4gaWYgd2UgYXJlbid0IGVuZGluZyBlYXJseSB3ZSBjYW4ndCBwcm9jZWVkIGZ1cnRoZXIgaWYgdGhlIHR5cGVzIGFyZW4ndCBjb3JyZWN0XG4gICAgICBpZiAoaW5pdGlhbEVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5leHQoaW5pdGlhbEVycm9ycywgdmFsdWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5ydW5UZXN0cyh7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICB0ZXN0czogdGhpcy50ZXN0c1xuICAgICAgfSwgcGFuaWMsIG5leHQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgc2V0IG9mIHZhbGlkYXRpb25zLCBlaXRoZXIgc2NoZW1hLCBwcm9kdWNlZCBUZXN0cyBvciBhIG5lc3RlZFxuICAgKiBzY2hlbWEgdmFsaWRhdGUgcmVzdWx0LlxuICAgKi9cbiAgcnVuVGVzdHMocnVuT3B0aW9ucywgcGFuaWMsIG5leHQpIHtcbiAgICBsZXQgZmlyZWQgPSBmYWxzZTtcbiAgICBsZXQge1xuICAgICAgdGVzdHMsXG4gICAgICB2YWx1ZSxcbiAgICAgIG9yaWdpbmFsVmFsdWUsXG4gICAgICBwYXRoLFxuICAgICAgb3B0aW9uc1xuICAgIH0gPSBydW5PcHRpb25zO1xuICAgIGxldCBwYW5pY09uY2UgPSBhcmcgPT4ge1xuICAgICAgaWYgKGZpcmVkKSByZXR1cm47XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBwYW5pYyhhcmcsIHZhbHVlKTtcbiAgICB9O1xuICAgIGxldCBuZXh0T25jZSA9IGFyZyA9PiB7XG4gICAgICBpZiAoZmlyZWQpIHJldHVybjtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIG5leHQoYXJnLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBsZXQgY291bnQgPSB0ZXN0cy5sZW5ndGg7XG4gICAgbGV0IG5lc3RlZEVycm9ycyA9IFtdO1xuICAgIGlmICghY291bnQpIHJldHVybiBuZXh0T25jZShbXSk7XG4gICAgbGV0IGFyZ3MgPSB7XG4gICAgICB2YWx1ZSxcbiAgICAgIG9yaWdpbmFsVmFsdWUsXG4gICAgICBwYXRoLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHNjaGVtYTogdGhpc1xuICAgIH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGVzdCA9IHRlc3RzW2ldO1xuICAgICAgdGVzdChhcmdzLCBwYW5pY09uY2UsIGZ1bmN0aW9uIGZpbmlzaFRlc3RSdW4oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBBcnJheS5pc0FycmF5KGVycikgPyBuZXN0ZWRFcnJvcnMucHVzaCguLi5lcnIpIDogbmVzdGVkRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoLS1jb3VudCA8PSAwKSB7XG4gICAgICAgICAgbmV4dE9uY2UobmVzdGVkRXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGFzTmVzdGVkVGVzdCh7XG4gICAga2V5LFxuICAgIGluZGV4LFxuICAgIHBhcmVudCxcbiAgICBwYXJlbnRQYXRoLFxuICAgIG9yaWdpbmFsUGFyZW50LFxuICAgIG9wdGlvbnNcbiAgfSkge1xuICAgIGNvbnN0IGsgPSBrZXkgIT0gbnVsbCA/IGtleSA6IGluZGV4O1xuICAgIGlmIChrID09IG51bGwpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignTXVzdCBpbmNsdWRlIGBrZXlgIG9yIGBpbmRleGAgZm9yIG5lc3RlZCB2YWxpZGF0aW9ucycpO1xuICAgIH1cbiAgICBjb25zdCBpc0luZGV4ID0gdHlwZW9mIGsgPT09ICdudW1iZXInO1xuICAgIGxldCB2YWx1ZSA9IHBhcmVudFtrXTtcbiAgICBjb25zdCB0ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIC8vIE5lc3RlZCB2YWxpZGF0aW9ucyBmaWVsZHMgYXJlIGFsd2F5cyBzdHJpY3Q6XG4gICAgICAvLyAgICAxLiBwYXJlbnQgaXNuJ3Qgc3RyaWN0IHNvIHRoZSBjYXN0aW5nIHdpbGwgYWxzbyBoYXZlIGNhc3QgaW5uZXIgdmFsdWVzXG4gICAgICAvLyAgICAyLiBwYXJlbnQgaXMgc3RyaWN0IGluIHdoaWNoIGNhc2UgdGhlIG5lc3RlZCB2YWx1ZXMgd2VyZW4ndCBjYXN0IGVpdGhlclxuICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgcGFyZW50LFxuICAgICAgdmFsdWUsXG4gICAgICBvcmlnaW5hbFZhbHVlOiBvcmlnaW5hbFBhcmVudFtrXSxcbiAgICAgIC8vIEZJWE1FOiB0ZXN0cyBkZXBlbmQgb24gYGluZGV4YCBiZWluZyBwYXNzZWQgYXJvdW5kIGRlZXBseSxcbiAgICAgIC8vICAgd2Ugc2hvdWxkIG5vdCBsZXQgdGhlIG9wdGlvbnMua2V5L2luZGV4IGJsZWVkIHRocm91Z2hcbiAgICAgIGtleTogdW5kZWZpbmVkLFxuICAgICAgLy8gaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgIFtpc0luZGV4ID8gJ2luZGV4JyA6ICdrZXknXTogayxcbiAgICAgIHBhdGg6IGlzSW5kZXggfHwgay5pbmNsdWRlcygnLicpID8gYCR7cGFyZW50UGF0aCB8fCAnJ31bJHtpc0luZGV4ID8gayA6IGBcIiR7a31cImB9XWAgOiAocGFyZW50UGF0aCA/IGAke3BhcmVudFBhdGh9LmAgOiAnJykgKyBrZXlcbiAgICB9KTtcbiAgICByZXR1cm4gKF8sIHBhbmljLCBuZXh0KSA9PiB0aGlzLnJlc29sdmUodGVzdE9wdGlvbnMpLl92YWxpZGF0ZSh2YWx1ZSwgdGVzdE9wdGlvbnMsIHBhbmljLCBuZXh0KTtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucyRkaXNhYmxlU3RhY2syO1xuICAgIGxldCBzY2hlbWEgPSB0aGlzLnJlc29sdmUoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgdmFsdWVcbiAgICB9KSk7XG4gICAgbGV0IGRpc2FibGVTdGFja1RyYWNlID0gKF9vcHRpb25zJGRpc2FibGVTdGFjazIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRpc2FibGVTdGFja1RyYWNlKSAhPSBudWxsID8gX29wdGlvbnMkZGlzYWJsZVN0YWNrMiA6IHNjaGVtYS5zcGVjLmRpc2FibGVTdGFja1RyYWNlO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBzY2hlbWEuX3ZhbGlkYXRlKHZhbHVlLCBvcHRpb25zLCAoZXJyb3IsIHBhcnNlZCkgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycm9yKSkgZXJyb3IudmFsdWUgPSBwYXJzZWQ7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIH0sIChlcnJvcnMsIHZhbGlkYXRlZCkgPT4ge1xuICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHJlamVjdChuZXcgVmFsaWRhdGlvbkVycm9yKGVycm9ycywgdmFsaWRhdGVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGlzYWJsZVN0YWNrVHJhY2UpKTtlbHNlIHJlc29sdmUodmFsaWRhdGVkKTtcbiAgICB9KSk7XG4gIH1cbiAgdmFsaWRhdGVTeW5jKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdmFyIF9vcHRpb25zJGRpc2FibGVTdGFjazM7XG4gICAgbGV0IHNjaGVtYSA9IHRoaXMucmVzb2x2ZShPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICB2YWx1ZVxuICAgIH0pKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBkaXNhYmxlU3RhY2tUcmFjZSA9IChfb3B0aW9ucyRkaXNhYmxlU3RhY2szID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kaXNhYmxlU3RhY2tUcmFjZSkgIT0gbnVsbCA/IF9vcHRpb25zJGRpc2FibGVTdGFjazMgOiBzY2hlbWEuc3BlYy5kaXNhYmxlU3RhY2tUcmFjZTtcbiAgICBzY2hlbWEuX3ZhbGlkYXRlKHZhbHVlLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICBzeW5jOiB0cnVlXG4gICAgfSksIChlcnJvciwgcGFyc2VkKSA9PiB7XG4gICAgICBpZiAoVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IoZXJyb3IpKSBlcnJvci52YWx1ZSA9IHBhcnNlZDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0sIChlcnJvcnMsIHZhbGlkYXRlZCkgPT4ge1xuICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoZXJyb3JzLCB2YWx1ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRpc2FibGVTdGFja1RyYWNlKTtcbiAgICAgIHJlc3VsdCA9IHZhbGlkYXRlZDtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlzVmFsaWQodmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykudGhlbigoKSA9PiB0cnVlLCBlcnIgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycikpIHJldHVybiBmYWxzZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgfVxuICBpc1ZhbGlkU3luYyh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnZhbGlkYXRlU3luYyh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnIpKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIF9nZXREZWZhdWx0KG9wdGlvbnMpIHtcbiAgICBsZXQgZGVmYXVsdFZhbHVlID0gdGhpcy5zcGVjLmRlZmF1bHQ7XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IGRlZmF1bHRWYWx1ZS5jYWxsKHRoaXMsIG9wdGlvbnMpIDogY2xvbmUoZGVmYXVsdFZhbHVlKTtcbiAgfVxuICBnZXREZWZhdWx0KG9wdGlvbnNcbiAgLy8gSWYgc2NoZW1hIGlzIGRlZmF1bHRlZCB3ZSBrbm93IGl0J3MgYXQgbGVhc3Qgbm90IHVuZGVmaW5lZFxuICApIHtcbiAgICBsZXQgc2NoZW1hID0gdGhpcy5yZXNvbHZlKG9wdGlvbnMgfHwge30pO1xuICAgIHJldHVybiBzY2hlbWEuX2dldERlZmF1bHQob3B0aW9ucyk7XG4gIH1cbiAgZGVmYXVsdChkZWYpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldERlZmF1bHQoKTtcbiAgICB9XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKHtcbiAgICAgIGRlZmF1bHQ6IGRlZlxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIHN0cmljdChpc1N0cmljdCA9IHRydWUpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7XG4gICAgICBzdHJpY3Q6IGlzU3RyaWN0XG4gICAgfSk7XG4gIH1cbiAgbnVsbGFiaWxpdHkobnVsbGFibGUsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5jbG9uZSh7XG4gICAgICBudWxsYWJsZVxuICAgIH0pO1xuICAgIG5leHQuaW50ZXJuYWxUZXN0cy5udWxsYWJsZSA9IGNyZWF0ZVZhbGlkYXRpb24oe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdudWxsYWJsZScsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IHRoaXMuc2NoZW1hLnNwZWMubnVsbGFibGUgOiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG9wdGlvbmFsaXR5KG9wdGlvbmFsLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuY2xvbmUoe1xuICAgICAgb3B0aW9uYWxcbiAgICB9KTtcbiAgICBuZXh0LmludGVybmFsVGVzdHMub3B0aW9uYWxpdHkgPSBjcmVhdGVWYWxpZGF0aW9uKHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnb3B0aW9uYWxpdHknLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHRoaXMuc2NoZW1hLnNwZWMub3B0aW9uYWwgOiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG9wdGlvbmFsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsaXR5KHRydWUpO1xuICB9XG4gIGRlZmluZWQobWVzc2FnZSA9IG1peGVkLmRlZmluZWQpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25hbGl0eShmYWxzZSwgbWVzc2FnZSk7XG4gIH1cbiAgbnVsbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubnVsbGFiaWxpdHkodHJ1ZSk7XG4gIH1cbiAgbm9uTnVsbGFibGUobWVzc2FnZSA9IG1peGVkLm5vdE51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5udWxsYWJpbGl0eShmYWxzZSwgbWVzc2FnZSk7XG4gIH1cbiAgcmVxdWlyZWQobWVzc2FnZSA9IG1peGVkLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS53aXRoTXV0YXRpb24obmV4dCA9PiBuZXh0Lm5vbk51bGxhYmxlKG1lc3NhZ2UpLmRlZmluZWQobWVzc2FnZSkpO1xuICB9XG4gIG5vdFJlcXVpcmVkKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkud2l0aE11dGF0aW9uKG5leHQgPT4gbmV4dC5udWxsYWJsZSgpLm9wdGlvbmFsKCkpO1xuICB9XG4gIHRyYW5zZm9ybShmbikge1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIG5leHQudHJhbnNmb3Jtcy5wdXNoKGZuKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgdGVzdCBmdW5jdGlvbiB0byB0aGUgc2NoZW1hJ3MgcXVldWUgb2YgdGVzdHMuXG4gICAqIHRlc3RzIGNhbiBiZSBleGNsdXNpdmUgb3Igbm9uLWV4Y2x1c2l2ZS5cbiAgICpcbiAgICogLSBleGNsdXNpdmUgdGVzdHMsIHdpbGwgcmVwbGFjZSBhbnkgZXhpc3RpbmcgdGVzdHMgb2YgdGhlIHNhbWUgbmFtZS5cbiAgICogLSBub24tZXhjbHVzaXZlOiBjYW4gYmUgc3RhY2tlZFxuICAgKlxuICAgKiBJZiBhIG5vbi1leGNsdXNpdmUgdGVzdCBpcyBhZGRlZCB0byBhIHNjaGVtYSB3aXRoIGFuIGV4Y2x1c2l2ZSB0ZXN0IG9mIHRoZSBzYW1lIG5hbWVcbiAgICogdGhlIGV4Y2x1c2l2ZSB0ZXN0IGlzIHJlbW92ZWQgYW5kIGZ1cnRoZXIgdGVzdHMgb2YgdGhlIHNhbWUgbmFtZSB3aWxsIGJlIHN0YWNrZWQuXG4gICAqXG4gICAqIElmIGFuIGV4Y2x1c2l2ZSB0ZXN0IGlzIGFkZGVkIHRvIGEgc2NoZW1hIHdpdGggbm9uLWV4Y2x1c2l2ZSB0ZXN0cyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIHRoZSBwcmV2aW91cyB0ZXN0cyBhcmUgcmVtb3ZlZCBhbmQgZnVydGhlciB0ZXN0cyBvZiB0aGUgc2FtZSBuYW1lIHdpbGwgcmVwbGFjZSBlYWNoIG90aGVyLlxuICAgKi9cblxuICB0ZXN0KC4uLmFyZ3MpIHtcbiAgICBsZXQgb3B0cztcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvcHRzID0ge1xuICAgICAgICAgIHRlc3Q6IGFyZ3NbMF1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdHMgPSBhcmdzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIG9wdHMgPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMF0sXG4gICAgICAgIHRlc3Q6IGFyZ3NbMV1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMgPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMF0sXG4gICAgICAgIG1lc3NhZ2U6IGFyZ3NbMV0sXG4gICAgICAgIHRlc3Q6IGFyZ3NbMl1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcHRzLm1lc3NhZ2UgPT09IHVuZGVmaW5lZCkgb3B0cy5tZXNzYWdlID0gbWl4ZWQuZGVmYXVsdDtcbiAgICBpZiAodHlwZW9mIG9wdHMudGVzdCAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignYHRlc3RgIGlzIGEgcmVxdWlyZWQgcGFyYW1ldGVycycpO1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIGxldCB2YWxpZGF0ZSA9IGNyZWF0ZVZhbGlkYXRpb24ob3B0cyk7XG4gICAgbGV0IGlzRXhjbHVzaXZlID0gb3B0cy5leGNsdXNpdmUgfHwgb3B0cy5uYW1lICYmIG5leHQuZXhjbHVzaXZlVGVzdHNbb3B0cy5uYW1lXSA9PT0gdHJ1ZTtcbiAgICBpZiAob3B0cy5leGNsdXNpdmUpIHtcbiAgICAgIGlmICghb3B0cy5uYW1lKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeGNsdXNpdmUgdGVzdHMgbXVzdCBwcm92aWRlIGEgdW5pcXVlIGBuYW1lYCBpZGVudGlmeWluZyB0aGUgdGVzdCcpO1xuICAgIH1cbiAgICBpZiAob3B0cy5uYW1lKSBuZXh0LmV4Y2x1c2l2ZVRlc3RzW29wdHMubmFtZV0gPSAhIW9wdHMuZXhjbHVzaXZlO1xuICAgIG5leHQudGVzdHMgPSBuZXh0LnRlc3RzLmZpbHRlcihmbiA9PiB7XG4gICAgICBpZiAoZm4uT1BUSU9OUy5uYW1lID09PSBvcHRzLm5hbWUpIHtcbiAgICAgICAgaWYgKGlzRXhjbHVzaXZlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChmbi5PUFRJT05TLnRlc3QgPT09IHZhbGlkYXRlLk9QVElPTlMudGVzdCkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgbmV4dC50ZXN0cy5wdXNoKHZhbGlkYXRlKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICB3aGVuKGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykgJiYgdHlwZW9mIGtleXMgIT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zID0ga2V5cztcbiAgICAgIGtleXMgPSAnLic7XG4gICAgfVxuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIGxldCBkZXBzID0gdG9BcnJheShrZXlzKS5tYXAoa2V5ID0+IG5ldyBSZWZlcmVuY2Uoa2V5KSk7XG4gICAgZGVwcy5mb3JFYWNoKGRlcCA9PiB7XG4gICAgICAvLyBAdHMtaWdub3JlIHJlYWRvbmx5IGFycmF5XG4gICAgICBpZiAoZGVwLmlzU2libGluZykgbmV4dC5kZXBzLnB1c2goZGVwLmtleSk7XG4gICAgfSk7XG4gICAgbmV4dC5jb25kaXRpb25zLnB1c2godHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBuZXcgQ29uZGl0aW9uKGRlcHMsIG9wdGlvbnMpIDogQ29uZGl0aW9uLmZyb21PcHRpb25zKGRlcHMsIG9wdGlvbnMpKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICB0eXBlRXJyb3IobWVzc2FnZSkge1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIG5leHQuaW50ZXJuYWxUZXN0cy50eXBlRXJyb3IgPSBjcmVhdGVWYWxpZGF0aW9uKHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAndHlwZUVycm9yJyxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5zY2hlbWEuX3R5cGVDaGVjayh2YWx1ZSkpIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKHtcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuc2NoZW1hLnR5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBvbmVPZihlbnVtcywgbWVzc2FnZSA9IG1peGVkLm9uZU9mKSB7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgZW51bXMuZm9yRWFjaCh2YWwgPT4ge1xuICAgICAgbmV4dC5fd2hpdGVsaXN0LmFkZCh2YWwpO1xuICAgICAgbmV4dC5fYmxhY2tsaXN0LmRlbGV0ZSh2YWwpO1xuICAgIH0pO1xuICAgIG5leHQuaW50ZXJuYWxUZXN0cy53aGl0ZUxpc3QgPSBjcmVhdGVWYWxpZGF0aW9uKHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnb25lT2YnLFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbGlkcyA9IHRoaXMuc2NoZW1hLl93aGl0ZWxpc3Q7XG4gICAgICAgIGxldCByZXNvbHZlZCA9IHZhbGlkcy5yZXNvbHZlQWxsKHRoaXMucmVzb2x2ZSk7XG4gICAgICAgIHJldHVybiByZXNvbHZlZC5pbmNsdWRlcyh2YWx1ZSkgPyB0cnVlIDogdGhpcy5jcmVhdGVFcnJvcih7XG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICB2YWx1ZXM6IEFycmF5LmZyb20odmFsaWRzKS5qb2luKCcsICcpLFxuICAgICAgICAgICAgcmVzb2x2ZWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG5vdE9uZU9mKGVudW1zLCBtZXNzYWdlID0gbWl4ZWQubm90T25lT2YpIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBlbnVtcy5mb3JFYWNoKHZhbCA9PiB7XG4gICAgICBuZXh0Ll9ibGFja2xpc3QuYWRkKHZhbCk7XG4gICAgICBuZXh0Ll93aGl0ZWxpc3QuZGVsZXRlKHZhbCk7XG4gICAgfSk7XG4gICAgbmV4dC5pbnRlcm5hbFRlc3RzLmJsYWNrbGlzdCA9IGNyZWF0ZVZhbGlkYXRpb24oe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdub3RPbmVPZicsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIGxldCBpbnZhbGlkcyA9IHRoaXMuc2NoZW1hLl9ibGFja2xpc3Q7XG4gICAgICAgIGxldCByZXNvbHZlZCA9IGludmFsaWRzLnJlc29sdmVBbGwodGhpcy5yZXNvbHZlKTtcbiAgICAgICAgaWYgKHJlc29sdmVkLmluY2x1ZGVzKHZhbHVlKSkgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3Ioe1xuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgdmFsdWVzOiBBcnJheS5mcm9tKGludmFsaWRzKS5qb2luKCcsICcpLFxuICAgICAgICAgICAgcmVzb2x2ZWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBzdHJpcChzdHJpcCA9IHRydWUpIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXh0LnNwZWMuc3RyaXAgPSBzdHJpcDtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBzZXJpYWxpemVkIGRlc2NyaXB0aW9uIG9mIHRoZSBzY2hlbWEgaW5jbHVkaW5nIHZhbGlkYXRpb25zLCBmbGFncywgdHlwZXMgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBQcm92aWRlIGFueSBuZWVkZWQgY29udGV4dCBmb3IgcmVzb2x2aW5nIHJ1bnRpbWUgc2NoZW1hIGFsdGVyYXRpb25zIChsYXp5LCB3aGVuIGNvbmRpdGlvbnMsIGV0YykuXG4gICAqL1xuICBkZXNjcmliZShvcHRpb25zKSB7XG4gICAgY29uc3QgbmV4dCA9IChvcHRpb25zID8gdGhpcy5yZXNvbHZlKG9wdGlvbnMpIDogdGhpcykuY2xvbmUoKTtcbiAgICBjb25zdCB7XG4gICAgICBsYWJlbCxcbiAgICAgIG1ldGEsXG4gICAgICBvcHRpb25hbCxcbiAgICAgIG51bGxhYmxlXG4gICAgfSA9IG5leHQuc3BlYztcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHtcbiAgICAgIG1ldGEsXG4gICAgICBsYWJlbCxcbiAgICAgIG9wdGlvbmFsLFxuICAgICAgbnVsbGFibGUsXG4gICAgICBkZWZhdWx0OiBuZXh0LmdldERlZmF1bHQob3B0aW9ucyksXG4gICAgICB0eXBlOiBuZXh0LnR5cGUsXG4gICAgICBvbmVPZjogbmV4dC5fd2hpdGVsaXN0LmRlc2NyaWJlKCksXG4gICAgICBub3RPbmVPZjogbmV4dC5fYmxhY2tsaXN0LmRlc2NyaWJlKCksXG4gICAgICB0ZXN0czogbmV4dC50ZXN0cy5tYXAoZm4gPT4gKHtcbiAgICAgICAgbmFtZTogZm4uT1BUSU9OUy5uYW1lLFxuICAgICAgICBwYXJhbXM6IGZuLk9QVElPTlMucGFyYW1zXG4gICAgICB9KSkuZmlsdGVyKChuLCBpZHgsIGxpc3QpID0+IGxpc3QuZmluZEluZGV4KGMgPT4gYy5uYW1lID09PSBuLm5hbWUpID09PSBpZHgpXG4gICAgfTtcbiAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gIH1cbn1cbi8vIEB0cy1leHBlY3QtZXJyb3JcblNjaGVtYS5wcm90b3R5cGUuX19pc1l1cFNjaGVtYV9fID0gdHJ1ZTtcbmZvciAoY29uc3QgbWV0aG9kIG9mIFsndmFsaWRhdGUnLCAndmFsaWRhdGVTeW5jJ10pIFNjaGVtYS5wcm90b3R5cGVbYCR7bWV0aG9kfUF0YF0gPSBmdW5jdGlvbiAocGF0aCwgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcGFyZW50LFxuICAgIHBhcmVudFBhdGgsXG4gICAgc2NoZW1hXG4gIH0gPSBnZXRJbih0aGlzLCBwYXRoLCB2YWx1ZSwgb3B0aW9ucy5jb250ZXh0KTtcbiAgcmV0dXJuIHNjaGVtYVttZXRob2RdKHBhcmVudCAmJiBwYXJlbnRbcGFyZW50UGF0aF0sIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICBwYXJlbnQsXG4gICAgcGF0aFxuICB9KSk7XG59O1xuZm9yIChjb25zdCBhbGlhcyBvZiBbJ2VxdWFscycsICdpcyddKSBTY2hlbWEucHJvdG90eXBlW2FsaWFzXSA9IFNjaGVtYS5wcm90b3R5cGUub25lT2Y7XG5mb3IgKGNvbnN0IGFsaWFzIG9mIFsnbm90JywgJ25vcGUnXSkgU2NoZW1hLnByb3RvdHlwZVthbGlhc10gPSBTY2hlbWEucHJvdG90eXBlLm5vdE9uZU9mO1xuXG5jb25zdCByZXR1cm5zVHJ1ZSA9ICgpID0+IHRydWU7XG5mdW5jdGlvbiBjcmVhdGUkOChzcGVjKSB7XG4gIHJldHVybiBuZXcgTWl4ZWRTY2hlbWEoc3BlYyk7XG59XG5jbGFzcyBNaXhlZFNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICBzdXBlcih0eXBlb2Ygc3BlYyA9PT0gJ2Z1bmN0aW9uJyA/IHtcbiAgICAgIHR5cGU6ICdtaXhlZCcsXG4gICAgICBjaGVjazogc3BlY1xuICAgIH0gOiBPYmplY3QuYXNzaWduKHtcbiAgICAgIHR5cGU6ICdtaXhlZCcsXG4gICAgICBjaGVjazogcmV0dXJuc1RydWVcbiAgICB9LCBzcGVjKSk7XG4gIH1cbn1cbmNyZWF0ZSQ4LnByb3RvdHlwZSA9IE1peGVkU2NoZW1hLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gY3JlYXRlJDcoKSB7XG4gIHJldHVybiBuZXcgQm9vbGVhblNjaGVtYSgpO1xufVxuY2xhc3MgQm9vbGVhblNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGNoZWNrKHYpIHtcbiAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBCb29sZWFuKSB2ID0gdi52YWx1ZU9mKCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKCh2YWx1ZSwgX3JhdywgY3R4KSA9PiB7XG4gICAgICAgIGlmIChjdHguc3BlYy5jb2VyY2UgJiYgIWN0eC5pc1R5cGUodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKC9eKHRydWV8MSkkL2kudGVzdChTdHJpbmcodmFsdWUpKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgaWYgKC9eKGZhbHNlfDApJC9pLnRlc3QoU3RyaW5nKHZhbHVlKSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBpc1RydWUobWVzc2FnZSA9IGJvb2xlYW4uaXNWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdpcy12YWx1ZScsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgdmFsdWU6ICd0cnVlJ1xuICAgICAgfSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzQWJzZW50KHZhbHVlKSB8fCB2YWx1ZSA9PT0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpc0ZhbHNlKG1lc3NhZ2UgPSBib29sZWFuLmlzVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnaXMtdmFsdWUnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHZhbHVlOiAnZmFsc2UnXG4gICAgICB9LFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNBYnNlbnQodmFsdWUpIHx8IHZhbHVlID09PSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkZWZhdWx0KGRlZikge1xuICAgIHJldHVybiBzdXBlci5kZWZhdWx0KGRlZik7XG4gIH1cbiAgZGVmaW5lZChtc2cpIHtcbiAgICByZXR1cm4gc3VwZXIuZGVmaW5lZChtc2cpO1xuICB9XG4gIG9wdGlvbmFsKCkge1xuICAgIHJldHVybiBzdXBlci5vcHRpb25hbCgpO1xuICB9XG4gIHJlcXVpcmVkKG1zZykge1xuICAgIHJldHVybiBzdXBlci5yZXF1aXJlZChtc2cpO1xuICB9XG4gIG5vdFJlcXVpcmVkKCkge1xuICAgIHJldHVybiBzdXBlci5ub3RSZXF1aXJlZCgpO1xuICB9XG4gIG51bGxhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci5udWxsYWJsZSgpO1xuICB9XG4gIG5vbk51bGxhYmxlKG1zZykge1xuICAgIHJldHVybiBzdXBlci5ub25OdWxsYWJsZShtc2cpO1xuICB9XG4gIHN0cmlwKHYpIHtcbiAgICByZXR1cm4gc3VwZXIuc3RyaXAodik7XG4gIH1cbn1cbmNyZWF0ZSQ3LnByb3RvdHlwZSA9IEJvb2xlYW5TY2hlbWEucHJvdG90eXBlO1xuXG4vKipcbiAqIFRoaXMgZmlsZSBpcyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIGZpbGUgZnJvbSB0aGUgZm9sbG93aW5nIHJlcG9zaXRvcnk6XG4gKiBEYXRlLnBhcnNlIHdpdGggcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQgZm9yIElTTyA4NjAxIDxodHRwczovL2dpdGh1Yi5jb20vY3Nub3Zlci9qcy1pc284NjAxPlxuICogTk9OLUNPTkZPUk1BTlQgRURJVElPTi5cbiAqIMKpIDIwMTEgQ29saW4gU25vdmVyIDxodHRwOi8vemV0YWZsZWV0LmNvbT5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICovXG5cbi8vIHByZXR0aWVyLWlnbm9yZVxuLy8gICAgICAgICAgICAgICAgMSBZWVlZICAgICAgICAgICAgICAgIDIgTU0gICAgICAgIDMgREQgICAgICAgICAgICAgIDQgSEggICAgIDUgbW0gICAgICAgIDYgc3MgICAgICAgICAgIDcgbXNlYyAgICAgICAgIDggWiA5IMKxICAgMTAgdHpISCAgICAxMSB0em1tXG5jb25zdCBpc29SZWcgPSAvXihcXGR7NH18WystXVxcZHs2fSkoPzotPyhcXGR7Mn0pKD86LT8oXFxkezJ9KSk/KT8oPzpbIFRdPyhcXGR7Mn0pOj8oXFxkezJ9KSg/Ojo/KFxcZHsyfSkoPzpbLC5dKFxcZHsxLH0pKT8pPyg/OihaKXwoWystXSkoXFxkezJ9KSg/Ojo/KFxcZHsyfSkpPyk/KT8kLztcbmZ1bmN0aW9uIHBhcnNlSXNvRGF0ZShkYXRlKSB7XG4gIGNvbnN0IHN0cnVjdCA9IHBhcnNlRGF0ZVN0cnVjdChkYXRlKTtcbiAgaWYgKCFzdHJ1Y3QpIHJldHVybiBEYXRlLnBhcnNlID8gRGF0ZS5wYXJzZShkYXRlKSA6IE51bWJlci5OYU47XG5cbiAgLy8gdGltZXN0YW1wcyB3aXRob3V0IHRpbWV6b25lIGlkZW50aWZpZXJzIHNob3VsZCBiZSBjb25zaWRlcmVkIGxvY2FsIHRpbWVcbiAgaWYgKHN0cnVjdC56ID09PSB1bmRlZmluZWQgJiYgc3RydWN0LnBsdXNNaW51cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHN0cnVjdC55ZWFyLCBzdHJ1Y3QubW9udGgsIHN0cnVjdC5kYXksIHN0cnVjdC5ob3VyLCBzdHJ1Y3QubWludXRlLCBzdHJ1Y3Quc2Vjb25kLCBzdHJ1Y3QubWlsbGlzZWNvbmQpLnZhbHVlT2YoKTtcbiAgfVxuICBsZXQgdG90YWxNaW51dGVzT2Zmc2V0ID0gMDtcbiAgaWYgKHN0cnVjdC56ICE9PSAnWicgJiYgc3RydWN0LnBsdXNNaW51cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxNaW51dGVzT2Zmc2V0ID0gc3RydWN0LmhvdXJPZmZzZXQgKiA2MCArIHN0cnVjdC5taW51dGVPZmZzZXQ7XG4gICAgaWYgKHN0cnVjdC5wbHVzTWludXMgPT09ICcrJykgdG90YWxNaW51dGVzT2Zmc2V0ID0gMCAtIHRvdGFsTWludXRlc09mZnNldDtcbiAgfVxuICByZXR1cm4gRGF0ZS5VVEMoc3RydWN0LnllYXIsIHN0cnVjdC5tb250aCwgc3RydWN0LmRheSwgc3RydWN0LmhvdXIsIHN0cnVjdC5taW51dGUgKyB0b3RhbE1pbnV0ZXNPZmZzZXQsIHN0cnVjdC5zZWNvbmQsIHN0cnVjdC5taWxsaXNlY29uZCk7XG59XG5mdW5jdGlvbiBwYXJzZURhdGVTdHJ1Y3QoZGF0ZSkge1xuICB2YXIgX3JlZ2V4UmVzdWx0JDckbGVuZ3RoLCBfcmVnZXhSZXN1bHQkO1xuICBjb25zdCByZWdleFJlc3VsdCA9IGlzb1JlZy5leGVjKGRhdGUpO1xuICBpZiAoIXJlZ2V4UmVzdWx0KSByZXR1cm4gbnVsbDtcblxuICAvLyB1c2Ugb2YgdG9OdW1iZXIoKSBhdm9pZHMgTmFOIHRpbWVzdGFtcHMgY2F1c2VkIGJ5IOKAnHVuZGVmaW5lZOKAnVxuICAvLyB2YWx1ZXMgYmVpbmcgcGFzc2VkIHRvIERhdGUgY29uc3RydWN0b3JcbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiB0b051bWJlcihyZWdleFJlc3VsdFsxXSksXG4gICAgbW9udGg6IHRvTnVtYmVyKHJlZ2V4UmVzdWx0WzJdLCAxKSAtIDEsXG4gICAgZGF5OiB0b051bWJlcihyZWdleFJlc3VsdFszXSwgMSksXG4gICAgaG91cjogdG9OdW1iZXIocmVnZXhSZXN1bHRbNF0pLFxuICAgIG1pbnV0ZTogdG9OdW1iZXIocmVnZXhSZXN1bHRbNV0pLFxuICAgIHNlY29uZDogdG9OdW1iZXIocmVnZXhSZXN1bHRbNl0pLFxuICAgIG1pbGxpc2Vjb25kOiByZWdleFJlc3VsdFs3XSA/XG4gICAgLy8gYWxsb3cgYXJiaXRyYXJ5IHN1Yi1zZWNvbmQgcHJlY2lzaW9uIGJleW9uZCBtaWxsaXNlY29uZHNcbiAgICB0b051bWJlcihyZWdleFJlc3VsdFs3XS5zdWJzdHJpbmcoMCwgMykpIDogMCxcbiAgICBwcmVjaXNpb246IChfcmVnZXhSZXN1bHQkNyRsZW5ndGggPSAoX3JlZ2V4UmVzdWx0JCA9IHJlZ2V4UmVzdWx0WzddKSA9PSBudWxsID8gdm9pZCAwIDogX3JlZ2V4UmVzdWx0JC5sZW5ndGgpICE9IG51bGwgPyBfcmVnZXhSZXN1bHQkNyRsZW5ndGggOiB1bmRlZmluZWQsXG4gICAgejogcmVnZXhSZXN1bHRbOF0gfHwgdW5kZWZpbmVkLFxuICAgIHBsdXNNaW51czogcmVnZXhSZXN1bHRbOV0gfHwgdW5kZWZpbmVkLFxuICAgIGhvdXJPZmZzZXQ6IHRvTnVtYmVyKHJlZ2V4UmVzdWx0WzEwXSksXG4gICAgbWludXRlT2Zmc2V0OiB0b051bWJlcihyZWdleFJlc3VsdFsxMV0pXG4gIH07XG59XG5mdW5jdGlvbiB0b051bWJlcihzdHIsIGRlZmF1bHRWYWx1ZSA9IDApIHtcbiAgcmV0dXJuIE51bWJlcihzdHIpIHx8IGRlZmF1bHRWYWx1ZTtcbn1cblxuLy8gVGFrZW4gZnJvbSBIVE1MIHNwZWM6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2lucHV0Lmh0bWwjdmFsaWQtZS1tYWlsLWFkZHJlc3NcbmxldCByRW1haWwgPVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4vXlthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSokLztcbmxldCByVXJsID1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuL14oKGh0dHBzP3xmdHApOik/XFwvXFwvKCgoKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDopKkApPygoKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKSl8KCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuPykoOlxcZCopPykoXFwvKCgoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKSsoXFwvKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApKikqKT8pPyhcXD8oKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApfFtcXHVFMDAwLVxcdUY4RkZdfFxcL3xcXD8pKik/KFxcIygoKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCl8XFwvfFxcPykqKT8kL2k7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxubGV0IHJVVUlEID0gL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pO1xubGV0IHllYXJNb250aERheSA9ICdeXFxcXGR7NH0tXFxcXGR7Mn0tXFxcXGR7Mn0nO1xubGV0IGhvdXJNaW51dGVTZWNvbmQgPSAnXFxcXGR7Mn06XFxcXGR7Mn06XFxcXGR7Mn0nO1xubGV0IHpPck9mZnNldCA9ICcoKFsrLV1cXFxcZHsyfSg6P1xcXFxkezJ9KT8pfFopJztcbmxldCBySXNvRGF0ZVRpbWUgPSBuZXcgUmVnRXhwKGAke3llYXJNb250aERheX1UJHtob3VyTWludXRlU2Vjb25kfShcXFxcLlxcXFxkKyk/JHt6T3JPZmZzZXR9JGApO1xubGV0IGlzVHJpbW1lZCA9IHZhbHVlID0+IGlzQWJzZW50KHZhbHVlKSB8fCB2YWx1ZSA9PT0gdmFsdWUudHJpbSgpO1xubGV0IG9ialN0cmluZ1RhZyA9IHt9LnRvU3RyaW5nKCk7XG5mdW5jdGlvbiBjcmVhdGUkNigpIHtcbiAgcmV0dXJuIG5ldyBTdHJpbmdTY2hlbWEoKTtcbn1cbmNsYXNzIFN0cmluZ1NjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgY2hlY2sodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSB2YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy53aXRoTXV0YXRpb24oKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2Zvcm0oKHZhbHVlLCBfcmF3LCBjdHgpID0+IHtcbiAgICAgICAgaWYgKCFjdHguc3BlYy5jb2VyY2UgfHwgY3R4LmlzVHlwZSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICAvLyBkb24ndCBldmVyIGNvbnZlcnQgYXJyYXlzXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjb25zdCBzdHJWYWx1ZSA9IHZhbHVlICE9IG51bGwgJiYgdmFsdWUudG9TdHJpbmcgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWU7XG5cbiAgICAgICAgLy8gbm8gb25lIHdhbnRzIHBsYWluIG9iamVjdHMgY29udmVydGVkIHRvIFtPYmplY3Qgb2JqZWN0XVxuICAgICAgICBpZiAoc3RyVmFsdWUgPT09IG9ialN0cmluZ1RhZykgcmV0dXJuIHZhbHVlO1xuICAgICAgICByZXR1cm4gc3RyVmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXF1aXJlZChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnJlcXVpcmVkKG1lc3NhZ2UpLndpdGhNdXRhdGlvbihzY2hlbWEgPT4gc2NoZW1hLnRlc3Qoe1xuICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCBtaXhlZC5yZXF1aXJlZCxcbiAgICAgIG5hbWU6ICdyZXF1aXJlZCcsXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdDogdmFsdWUgPT4gISF2YWx1ZS5sZW5ndGhcbiAgICB9KSk7XG4gIH1cbiAgbm90UmVxdWlyZWQoKSB7XG4gICAgcmV0dXJuIHN1cGVyLm5vdFJlcXVpcmVkKCkud2l0aE11dGF0aW9uKHNjaGVtYSA9PiB7XG4gICAgICBzY2hlbWEudGVzdHMgPSBzY2hlbWEudGVzdHMuZmlsdGVyKHQgPT4gdC5PUFRJT05TLm5hbWUgIT09ICdyZXF1aXJlZCcpO1xuICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9KTtcbiAgfVxuICBsZW5ndGgobGVuZ3RoLCBtZXNzYWdlID0gc3RyaW5nLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdsZW5ndGgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGxlbmd0aFxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPT09IHRoaXMucmVzb2x2ZShsZW5ndGgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG1pbihtaW4sIG1lc3NhZ2UgPSBzdHJpbmcubWluKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21pbicsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWluXG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+PSB0aGlzLnJlc29sdmUobWluKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtYXgobWF4LCBtZXNzYWdlID0gc3RyaW5nLm1heCkge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbmFtZTogJ21heCcsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBtZXNzYWdlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1heFxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPD0gdGhpcy5yZXNvbHZlKG1heCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWF0Y2hlcyhyZWdleCwgb3B0aW9ucykge1xuICAgIGxldCBleGNsdWRlRW1wdHlTdHJpbmcgPSBmYWxzZTtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBsZXQgbmFtZTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAoe1xuICAgICAgICAgIGV4Y2x1ZGVFbXB0eVN0cmluZyA9IGZhbHNlLFxuICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgbmFtZVxuICAgICAgICB9ID0gb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlID0gb3B0aW9ucztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBuYW1lOiBuYW1lIHx8ICdtYXRjaGVzJyxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UgfHwgc3RyaW5nLm1hdGNoZXMsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgcmVnZXhcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdDogdmFsdWUgPT4gdmFsdWUgPT09ICcnICYmIGV4Y2x1ZGVFbXB0eVN0cmluZyB8fCB2YWx1ZS5zZWFyY2gocmVnZXgpICE9PSAtMVxuICAgIH0pO1xuICB9XG4gIGVtYWlsKG1lc3NhZ2UgPSBzdHJpbmcuZW1haWwpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHJFbWFpbCwge1xuICAgICAgbmFtZTogJ2VtYWlsJyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBleGNsdWRlRW1wdHlTdHJpbmc6IHRydWVcbiAgICB9KTtcbiAgfVxuICB1cmwobWVzc2FnZSA9IHN0cmluZy51cmwpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHJVcmwsIHtcbiAgICAgIG5hbWU6ICd1cmwnLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGV4Y2x1ZGVFbXB0eVN0cmluZzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHV1aWQobWVzc2FnZSA9IHN0cmluZy51dWlkKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhyVVVJRCwge1xuICAgICAgbmFtZTogJ3V1aWQnLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGV4Y2x1ZGVFbXB0eVN0cmluZzogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBkYXRldGltZShvcHRpb25zKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICBsZXQgYWxsb3dPZmZzZXQ7XG4gICAgbGV0IHByZWNpc2lvbjtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAoe1xuICAgICAgICAgIG1lc3NhZ2UgPSAnJyxcbiAgICAgICAgICBhbGxvd09mZnNldCA9IGZhbHNlLFxuICAgICAgICAgIHByZWNpc2lvbiA9IHVuZGVmaW5lZFxuICAgICAgICB9ID0gb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlID0gb3B0aW9ucztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhySXNvRGF0ZVRpbWUsIHtcbiAgICAgIG5hbWU6ICdkYXRldGltZScsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8IHN0cmluZy5kYXRldGltZSxcbiAgICAgIGV4Y2x1ZGVFbXB0eVN0cmluZzogdHJ1ZVxuICAgIH0pLnRlc3Qoe1xuICAgICAgbmFtZTogJ2RhdGV0aW1lX29mZnNldCcsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8IHN0cmluZy5kYXRldGltZV9vZmZzZXQsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgYWxsb3dPZmZzZXRcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdDogdmFsdWUgPT4ge1xuICAgICAgICBpZiAoIXZhbHVlIHx8IGFsbG93T2Zmc2V0KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc3RydWN0ID0gcGFyc2VEYXRlU3RydWN0KHZhbHVlKTtcbiAgICAgICAgaWYgKCFzdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuICEhc3RydWN0Lno7XG4gICAgICB9XG4gICAgfSkudGVzdCh7XG4gICAgICBuYW1lOiAnZGF0ZXRpbWVfcHJlY2lzaW9uJyxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UgfHwgc3RyaW5nLmRhdGV0aW1lX3ByZWNpc2lvbixcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBwcmVjaXNpb25cbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdDogdmFsdWUgPT4ge1xuICAgICAgICBpZiAoIXZhbHVlIHx8IHByZWNpc2lvbiA9PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBzdHJ1Y3QgPSBwYXJzZURhdGVTdHJ1Y3QodmFsdWUpO1xuICAgICAgICBpZiAoIXN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gc3RydWN0LnByZWNpc2lvbiA9PT0gcHJlY2lzaW9uO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8tLSB0cmFuc2Zvcm1zIC0tXG4gIGVuc3VyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0KCcnKS50cmFuc2Zvcm0odmFsID0+IHZhbCA9PT0gbnVsbCA/ICcnIDogdmFsKTtcbiAgfVxuICB0cmltKG1lc3NhZ2UgPSBzdHJpbmcudHJpbSkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2YWwgPT4gdmFsICE9IG51bGwgPyB2YWwudHJpbSgpIDogdmFsKS50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAndHJpbScsXG4gICAgICB0ZXN0OiBpc1RyaW1tZWRcbiAgICB9KTtcbiAgfVxuICBsb3dlcmNhc2UobWVzc2FnZSA9IHN0cmluZy5sb3dlcmNhc2UpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsdWUgPT4gIWlzQWJzZW50KHZhbHVlKSA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiB2YWx1ZSkudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ3N0cmluZ19jYXNlJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0OiB2YWx1ZSA9PiBpc0Fic2VudCh2YWx1ZSkgfHwgdmFsdWUgPT09IHZhbHVlLnRvTG93ZXJDYXNlKClcbiAgICB9KTtcbiAgfVxuICB1cHBlcmNhc2UobWVzc2FnZSA9IHN0cmluZy51cHBlcmNhc2UpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsdWUgPT4gIWlzQWJzZW50KHZhbHVlKSA/IHZhbHVlLnRvVXBwZXJDYXNlKCkgOiB2YWx1ZSkudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ3N0cmluZ19jYXNlJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0OiB2YWx1ZSA9PiBpc0Fic2VudCh2YWx1ZSkgfHwgdmFsdWUgPT09IHZhbHVlLnRvVXBwZXJDYXNlKClcbiAgICB9KTtcbiAgfVxufVxuY3JlYXRlJDYucHJvdG90eXBlID0gU3RyaW5nU2NoZW1hLnByb3RvdHlwZTtcblxuLy9cbi8vIFN0cmluZyBJbnRlcmZhY2VzXG4vL1xuXG5sZXQgaXNOYU4kMSA9IHZhbHVlID0+IHZhbHVlICE9ICt2YWx1ZTtcbmZ1bmN0aW9uIGNyZWF0ZSQ1KCkge1xuICByZXR1cm4gbmV3IE51bWJlclNjaGVtYSgpO1xufVxuY2xhc3MgTnVtYmVyU2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBjaGVjayh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4kMSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy53aXRoTXV0YXRpb24oKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2Zvcm0oKHZhbHVlLCBfcmF3LCBjdHgpID0+IHtcbiAgICAgICAgaWYgKCFjdHguc3BlYy5jb2VyY2UpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgbGV0IHBhcnNlZCA9IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHBhcnNlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBwYXJzZWQgPSBwYXJzZWQucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICAgICAgICBpZiAocGFyc2VkID09PSAnJykgcmV0dXJuIE5hTjtcbiAgICAgICAgICAvLyBkb24ndCB1c2UgcGFyc2VGbG9hdCB0byBhdm9pZCBwb3NpdGl2ZXMgb24gYWxwaGEtbnVtZXJpYyBzdHJpbmdzXG4gICAgICAgICAgcGFyc2VkID0gK3BhcnNlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG51bGwgLT4gTmFOIGlzbid0IHVzZWZ1bDsgdHJlYXQgYWxsIG51bGxzIGFzIG51bGwgYW5kIGxldCBpdCBmYWlsIG9uXG4gICAgICAgIC8vIG51bGxhYmlsaXR5IGNoZWNrIHZzIFR5cGVFcnJvcnNcbiAgICAgICAgaWYgKGN0eC5pc1R5cGUocGFyc2VkKSB8fCBwYXJzZWQgPT09IG51bGwpIHJldHVybiBwYXJzZWQ7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHBhcnNlZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBtaW4obWluLCBtZXNzYWdlID0gbnVtYmVyLm1pbikge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtaW4nLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1pblxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSB0aGlzLnJlc29sdmUobWluKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtYXgobWF4LCBtZXNzYWdlID0gbnVtYmVyLm1heCkge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtYXgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1heFxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8PSB0aGlzLnJlc29sdmUobWF4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsZXNzVGhhbihsZXNzLCBtZXNzYWdlID0gbnVtYmVyLmxlc3NUaGFuKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21heCcsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbGVzc1xuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8IHRoaXMucmVzb2x2ZShsZXNzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtb3JlVGhhbihtb3JlLCBtZXNzYWdlID0gbnVtYmVyLm1vcmVUaGFuKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21pbicsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbW9yZVxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+IHRoaXMucmVzb2x2ZShtb3JlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwb3NpdGl2ZShtc2cgPSBudW1iZXIucG9zaXRpdmUpIHtcbiAgICByZXR1cm4gdGhpcy5tb3JlVGhhbigwLCBtc2cpO1xuICB9XG4gIG5lZ2F0aXZlKG1zZyA9IG51bWJlci5uZWdhdGl2ZSkge1xuICAgIHJldHVybiB0aGlzLmxlc3NUaGFuKDAsIG1zZyk7XG4gIH1cbiAgaW50ZWdlcihtZXNzYWdlID0gbnVtYmVyLmludGVnZXIpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG5hbWU6ICdpbnRlZ2VyJyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdDogdmFsID0+IE51bWJlci5pc0ludGVnZXIodmFsKVxuICAgIH0pO1xuICB9XG4gIHRydW5jYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2YWx1ZSA9PiAhaXNBYnNlbnQodmFsdWUpID8gdmFsdWUgfCAwIDogdmFsdWUpO1xuICB9XG4gIHJvdW5kKG1ldGhvZCkge1xuICAgIHZhciBfbWV0aG9kO1xuICAgIGxldCBhdmFpbCA9IFsnY2VpbCcsICdmbG9vcicsICdyb3VuZCcsICd0cnVuYyddO1xuICAgIG1ldGhvZCA9ICgoX21ldGhvZCA9IG1ldGhvZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tZXRob2QudG9Mb3dlckNhc2UoKSkgfHwgJ3JvdW5kJztcblxuICAgIC8vIHRoaXMgZXhpc3RzIGZvciBzeW1lbXRyeSB3aXRoIHRoZSBuZXcgTWF0aC50cnVuY1xuICAgIGlmIChtZXRob2QgPT09ICd0cnVuYycpIHJldHVybiB0aGlzLnRydW5jYXRlKCk7XG4gICAgaWYgKGF2YWlsLmluZGV4T2YobWV0aG9kLnRvTG93ZXJDYXNlKCkpID09PSAtMSkgdGhyb3cgbmV3IFR5cGVFcnJvcignT25seSB2YWxpZCBvcHRpb25zIGZvciByb3VuZCgpIGFyZTogJyArIGF2YWlsLmpvaW4oJywgJykpO1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2YWx1ZSA9PiAhaXNBYnNlbnQodmFsdWUpID8gTWF0aFttZXRob2RdKHZhbHVlKSA6IHZhbHVlKTtcbiAgfVxufVxuY3JlYXRlJDUucHJvdG90eXBlID0gTnVtYmVyU2NoZW1hLnByb3RvdHlwZTtcblxuLy9cbi8vIE51bWJlciBJbnRlcmZhY2VzXG4vL1xuXG5sZXQgaW52YWxpZERhdGUgPSBuZXcgRGF0ZSgnJyk7XG5sZXQgaXNEYXRlID0gb2JqID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBEYXRlXSc7XG5mdW5jdGlvbiBjcmVhdGUkNCgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlU2NoZW1hKCk7XG59XG5jbGFzcyBEYXRlU2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogJ2RhdGUnLFxuICAgICAgY2hlY2sodikge1xuICAgICAgICByZXR1cm4gaXNEYXRlKHYpICYmICFpc05hTih2LmdldFRpbWUoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy53aXRoTXV0YXRpb24oKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2Zvcm0oKHZhbHVlLCBfcmF3LCBjdHgpID0+IHtcbiAgICAgICAgLy8gbnVsbCAtPiBJbnZhbGlkRGF0ZSBpc24ndCB1c2VmdWw7IHRyZWF0IGFsbCBudWxscyBhcyBudWxsIGFuZCBsZXQgaXQgZmFpbCBvblxuICAgICAgICAvLyBudWxsYWJpbGl0eSBjaGVjayB2cyBUeXBlRXJyb3JzXG4gICAgICAgIGlmICghY3R4LnNwZWMuY29lcmNlIHx8IGN0eC5pc1R5cGUodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gcGFyc2VJc29EYXRlKHZhbHVlKTtcblxuICAgICAgICAvLyAwIGlzIGEgdmFsaWQgdGltZXN0YW1wIGVxdWl2YWxlbnQgdG8gMTk3MC0wMS0wMVQwMDowMDowMFoodW5peCBlcG9jaCkgb3IgYmVmb3JlLlxuICAgICAgICByZXR1cm4gIWlzTmFOKHZhbHVlKSA/IG5ldyBEYXRlKHZhbHVlKSA6IERhdGVTY2hlbWEuSU5WQUxJRF9EQVRFO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcHJlcGFyZVBhcmFtKHJlZiwgbmFtZSkge1xuICAgIGxldCBwYXJhbTtcbiAgICBpZiAoIVJlZmVyZW5jZS5pc1JlZihyZWYpKSB7XG4gICAgICBsZXQgY2FzdCA9IHRoaXMuY2FzdChyZWYpO1xuICAgICAgaWYgKCF0aGlzLl90eXBlQ2hlY2soY2FzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoYFxcYCR7bmFtZX1cXGAgbXVzdCBiZSBhIERhdGUgb3IgYSB2YWx1ZSB0aGF0IGNhbiBiZSBcXGBjYXN0KClcXGAgdG8gYSBEYXRlYCk7XG4gICAgICBwYXJhbSA9IGNhc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtID0gcmVmO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW07XG4gIH1cbiAgbWluKG1pbiwgbWVzc2FnZSA9IGRhdGUubWluKSB7XG4gICAgbGV0IGxpbWl0ID0gdGhpcy5wcmVwYXJlUGFyYW0obWluLCAnbWluJyk7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21pbicsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWluXG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID49IHRoaXMucmVzb2x2ZShsaW1pdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWF4KG1heCwgbWVzc2FnZSA9IGRhdGUubWF4KSB7XG4gICAgbGV0IGxpbWl0ID0gdGhpcy5wcmVwYXJlUGFyYW0obWF4LCAnbWF4Jyk7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21heCcsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWF4XG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIDw9IHRoaXMucmVzb2x2ZShsaW1pdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbkRhdGVTY2hlbWEuSU5WQUxJRF9EQVRFID0gaW52YWxpZERhdGU7XG5jcmVhdGUkNC5wcm90b3R5cGUgPSBEYXRlU2NoZW1hLnByb3RvdHlwZTtcbmNyZWF0ZSQ0LklOVkFMSURfREFURSA9IGludmFsaWREYXRlO1xuXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5mdW5jdGlvbiBzb3J0RmllbGRzKGZpZWxkcywgZXhjbHVkZWRFZGdlcyA9IFtdKSB7XG4gIGxldCBlZGdlcyA9IFtdO1xuICBsZXQgbm9kZXMgPSBuZXcgU2V0KCk7XG4gIGxldCBleGNsdWRlcyA9IG5ldyBTZXQoZXhjbHVkZWRFZGdlcy5tYXAoKFthLCBiXSkgPT4gYCR7YX0tJHtifWApKTtcbiAgZnVuY3Rpb24gYWRkTm9kZShkZXBQYXRoLCBrZXkpIHtcbiAgICBsZXQgbm9kZSA9IHNwbGl0KGRlcFBhdGgpWzBdO1xuICAgIG5vZGVzLmFkZChub2RlKTtcbiAgICBpZiAoIWV4Y2x1ZGVzLmhhcyhgJHtrZXl9LSR7bm9kZX1gKSkgZWRnZXMucHVzaChba2V5LCBub2RlXSk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZmllbGRzKSkge1xuICAgIGxldCB2YWx1ZSA9IGZpZWxkc1trZXldO1xuICAgIG5vZGVzLmFkZChrZXkpO1xuICAgIGlmIChSZWZlcmVuY2UuaXNSZWYodmFsdWUpICYmIHZhbHVlLmlzU2libGluZykgYWRkTm9kZSh2YWx1ZS5wYXRoLCBrZXkpO2Vsc2UgaWYgKGlzU2NoZW1hKHZhbHVlKSAmJiAnZGVwcycgaW4gdmFsdWUpIHZhbHVlLmRlcHMuZm9yRWFjaChwYXRoID0+IGFkZE5vZGUocGF0aCwga2V5KSk7XG4gIH1cbiAgcmV0dXJuIHRvcG9zb3J0LmFycmF5KEFycmF5LmZyb20obm9kZXMpLCBlZGdlcykucmV2ZXJzZSgpO1xufVxuXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBlcnIpIHtcbiAgbGV0IGlkeCA9IEluZmluaXR5O1xuICBhcnIuc29tZSgoa2V5LCBpaSkgPT4ge1xuICAgIHZhciBfZXJyJHBhdGg7XG4gICAgaWYgKChfZXJyJHBhdGggPSBlcnIucGF0aCkgIT0gbnVsbCAmJiBfZXJyJHBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgaWR4ID0gaWk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaWR4O1xufVxuZnVuY3Rpb24gc29ydEJ5S2V5T3JkZXIoa2V5cykge1xuICByZXR1cm4gKGEsIGIpID0+IHtcbiAgICByZXR1cm4gZmluZEluZGV4KGtleXMsIGEpIC0gZmluZEluZGV4KGtleXMsIGIpO1xuICB9O1xufVxuXG5jb25zdCBwYXJzZUpzb24gPSAodmFsdWUsIF8sIGN0eCkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBsZXQgcGFyc2VkID0gdmFsdWU7XG4gIHRyeSB7XG4gICAgcGFyc2VkID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8qICovXG4gIH1cbiAgcmV0dXJuIGN0eC5pc1R5cGUocGFyc2VkKSA/IHBhcnNlZCA6IHZhbHVlO1xufTtcblxuLy8gQHRzLWlnbm9yZVxuZnVuY3Rpb24gZGVlcFBhcnRpYWwoc2NoZW1hKSB7XG4gIGlmICgnZmllbGRzJyBpbiBzY2hlbWEpIHtcbiAgICBjb25zdCBwYXJ0aWFsID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCBmaWVsZFNjaGVtYV0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLmZpZWxkcykpIHtcbiAgICAgIHBhcnRpYWxba2V5XSA9IGRlZXBQYXJ0aWFsKGZpZWxkU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYS5zZXRGaWVsZHMocGFydGlhbCk7XG4gIH1cbiAgaWYgKHNjaGVtYS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgY29uc3QgbmV4dEFycmF5ID0gc2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgaWYgKG5leHRBcnJheS5pbm5lclR5cGUpIG5leHRBcnJheS5pbm5lclR5cGUgPSBkZWVwUGFydGlhbChuZXh0QXJyYXkuaW5uZXJUeXBlKTtcbiAgICByZXR1cm4gbmV4dEFycmF5O1xuICB9XG4gIGlmIChzY2hlbWEudHlwZSA9PT0gJ3R1cGxlJykge1xuICAgIHJldHVybiBzY2hlbWEub3B0aW9uYWwoKS5jbG9uZSh7XG4gICAgICB0eXBlczogc2NoZW1hLnNwZWMudHlwZXMubWFwKGRlZXBQYXJ0aWFsKVxuICAgIH0pO1xuICB9XG4gIGlmICgnb3B0aW9uYWwnIGluIHNjaGVtYSkge1xuICAgIHJldHVybiBzY2hlbWEub3B0aW9uYWwoKTtcbiAgfVxuICByZXR1cm4gc2NoZW1hO1xufVxuY29uc3QgZGVlcEhhcyA9IChvYmosIHApID0+IHtcbiAgY29uc3QgcGF0aCA9IFsuLi5ub3JtYWxpemVQYXRoKHApXTtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSByZXR1cm4gcGF0aFswXSBpbiBvYmo7XG4gIGxldCBsYXN0ID0gcGF0aC5wb3AoKTtcbiAgbGV0IHBhcmVudCA9IGdldHRlcihqb2luKHBhdGgpLCB0cnVlKShvYmopO1xuICByZXR1cm4gISEocGFyZW50ICYmIGxhc3QgaW4gcGFyZW50KTtcbn07XG5sZXQgaXNPYmplY3QgPSBvYmogPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuZnVuY3Rpb24gdW5rbm93bihjdHgsIHZhbHVlKSB7XG4gIGxldCBrbm93biA9IE9iamVjdC5rZXlzKGN0eC5maWVsZHMpO1xuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihrZXkgPT4ga25vd24uaW5kZXhPZihrZXkpID09PSAtMSk7XG59XG5jb25zdCBkZWZhdWx0U29ydCA9IHNvcnRCeUtleU9yZGVyKFtdKTtcbmZ1bmN0aW9uIGNyZWF0ZSQzKHNwZWMpIHtcbiAgcmV0dXJuIG5ldyBPYmplY3RTY2hlbWEoc3BlYyk7XG59XG5jbGFzcyBPYmplY3RTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBjaGVjayh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmZpZWxkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fc29ydEVycm9ycyA9IGRlZmF1bHRTb3J0O1xuICAgIHRoaXMuX25vZGVzID0gW107XG4gICAgdGhpcy5fZXhjbHVkZWRFZGdlcyA9IFtdO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIGlmIChzcGVjKSB7XG4gICAgICAgIHRoaXMuc2hhcGUoc3BlYyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2Nhc3QoX3ZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX29wdGlvbnMkc3RyaXBVbmtub3duO1xuICAgIGxldCB2YWx1ZSA9IHN1cGVyLl9jYXN0KF92YWx1ZSwgb3B0aW9ucyk7XG5cbiAgICAvL3Nob3VsZCBpZ25vcmUgbnVsbHMgaGVyZVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5nZXREZWZhdWx0KG9wdGlvbnMpO1xuICAgIGlmICghdGhpcy5fdHlwZUNoZWNrKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIGxldCBmaWVsZHMgPSB0aGlzLmZpZWxkcztcbiAgICBsZXQgc3RyaXAgPSAoX29wdGlvbnMkc3RyaXBVbmtub3duID0gb3B0aW9ucy5zdHJpcFVua25vd24pICE9IG51bGwgPyBfb3B0aW9ucyRzdHJpcFVua25vd24gOiB0aGlzLnNwZWMubm9Vbmtub3duO1xuICAgIGxldCBwcm9wcyA9IFtdLmNvbmNhdCh0aGlzLl9ub2RlcywgT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcih2ID0+ICF0aGlzLl9ub2Rlcy5pbmNsdWRlcyh2KSkpO1xuICAgIGxldCBpbnRlcm1lZGlhdGVWYWx1ZSA9IHt9OyAvLyBpcyBmaWxsZWQgZHVyaW5nIHRoZSB0cmFuc2Zvcm0gYmVsb3dcbiAgICBsZXQgaW5uZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgcGFyZW50OiBpbnRlcm1lZGlhdGVWYWx1ZSxcbiAgICAgIF9fdmFsaWRhdGluZzogb3B0aW9ucy5fX3ZhbGlkYXRpbmcgfHwgZmFsc2VcbiAgICB9KTtcbiAgICBsZXQgaXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzKSB7XG4gICAgICBsZXQgZmllbGQgPSBmaWVsZHNbcHJvcF07XG4gICAgICBsZXQgZXhpc3RzID0gKHByb3AgaW4gdmFsdWUpO1xuICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgIGxldCBmaWVsZFZhbHVlO1xuICAgICAgICBsZXQgaW5wdXRWYWx1ZSA9IHZhbHVlW3Byb3BdO1xuXG4gICAgICAgIC8vIHNhZmUgdG8gbXV0YXRlIHNpbmNlIHRoaXMgaXMgZmlyZWQgaW4gc2VxdWVuY2VcbiAgICAgICAgaW5uZXJPcHRpb25zLnBhdGggPSAob3B0aW9ucy5wYXRoID8gYCR7b3B0aW9ucy5wYXRofS5gIDogJycpICsgcHJvcDtcbiAgICAgICAgZmllbGQgPSBmaWVsZC5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZSxcbiAgICAgICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQsXG4gICAgICAgICAgcGFyZW50OiBpbnRlcm1lZGlhdGVWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGZpZWxkU3BlYyA9IGZpZWxkIGluc3RhbmNlb2YgU2NoZW1hID8gZmllbGQuc3BlYyA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHN0cmljdCA9IGZpZWxkU3BlYyA9PSBudWxsID8gdm9pZCAwIDogZmllbGRTcGVjLnN0cmljdDtcbiAgICAgICAgaWYgKGZpZWxkU3BlYyAhPSBudWxsICYmIGZpZWxkU3BlYy5zdHJpcCkge1xuICAgICAgICAgIGlzQ2hhbmdlZCA9IGlzQ2hhbmdlZCB8fCBwcm9wIGluIHZhbHVlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkVmFsdWUgPSAhb3B0aW9ucy5fX3ZhbGlkYXRpbmcgfHwgIXN0cmljdCA/XG4gICAgICAgIC8vIFRPRE86IHVzZSBfY2FzdCwgdGhpcyBpcyBkb3VibGUgcmVzb2x2aW5nXG4gICAgICAgIGZpZWxkLmNhc3QodmFsdWVbcHJvcF0sIGlubmVyT3B0aW9ucykgOiB2YWx1ZVtwcm9wXTtcbiAgICAgICAgaWYgKGZpZWxkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGludGVybWVkaWF0ZVZhbHVlW3Byb3BdID0gZmllbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleGlzdHMgJiYgIXN0cmlwKSB7XG4gICAgICAgIGludGVybWVkaWF0ZVZhbHVlW3Byb3BdID0gdmFsdWVbcHJvcF07XG4gICAgICB9XG4gICAgICBpZiAoZXhpc3RzICE9PSBwcm9wIGluIGludGVybWVkaWF0ZVZhbHVlIHx8IGludGVybWVkaWF0ZVZhbHVlW3Byb3BdICE9PSB2YWx1ZVtwcm9wXSkge1xuICAgICAgICBpc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNDaGFuZ2VkID8gaW50ZXJtZWRpYXRlVmFsdWUgOiB2YWx1ZTtcbiAgfVxuICBfdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zID0ge30sIHBhbmljLCBuZXh0KSB7XG4gICAgbGV0IHtcbiAgICAgIGZyb20gPSBbXSxcbiAgICAgIG9yaWdpbmFsVmFsdWUgPSBfdmFsdWUsXG4gICAgICByZWN1cnNpdmUgPSB0aGlzLnNwZWMucmVjdXJzaXZlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucy5mcm9tID0gW3tcbiAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgIHZhbHVlOiBvcmlnaW5hbFZhbHVlXG4gICAgfSwgLi4uZnJvbV07XG4gICAgLy8gdGhpcyBmbGFnIGlzIG5lZWRlZCBmb3IgaGFuZGxpbmcgYHN0cmljdGAgY29ycmVjdGx5IGluIHRoZSBjb250ZXh0IG9mXG4gICAgLy8gdmFsaWRhdGlvbiB2cyBqdXN0IGNhc3RpbmcuIGUuZyBzdHJpY3QoKSBvbiBhIGZpZWxkIGlzIG9ubHkgdXNlZCB3aGVuIHZhbGlkYXRpbmdcbiAgICBvcHRpb25zLl9fdmFsaWRhdGluZyA9IHRydWU7XG4gICAgb3B0aW9ucy5vcmlnaW5hbFZhbHVlID0gb3JpZ2luYWxWYWx1ZTtcbiAgICBzdXBlci5fdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zLCBwYW5pYywgKG9iamVjdEVycm9ycywgdmFsdWUpID0+IHtcbiAgICAgIGlmICghcmVjdXJzaXZlIHx8ICFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgbmV4dChvYmplY3RFcnJvcnMsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb3JpZ2luYWxWYWx1ZSA9IG9yaWdpbmFsVmFsdWUgfHwgdmFsdWU7XG4gICAgICBsZXQgdGVzdHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGtleSBvZiB0aGlzLl9ub2Rlcykge1xuICAgICAgICBsZXQgZmllbGQgPSB0aGlzLmZpZWxkc1trZXldO1xuICAgICAgICBpZiAoIWZpZWxkIHx8IFJlZmVyZW5jZS5pc1JlZihmaWVsZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0ZXN0cy5wdXNoKGZpZWxkLmFzTmVzdGVkVGVzdCh7XG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgcGFyZW50OiB2YWx1ZSxcbiAgICAgICAgICBwYXJlbnRQYXRoOiBvcHRpb25zLnBhdGgsXG4gICAgICAgICAgb3JpZ2luYWxQYXJlbnQ6IG9yaWdpbmFsVmFsdWVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgdGhpcy5ydW5UZXN0cyh7XG4gICAgICAgIHRlc3RzLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSwgcGFuaWMsIGZpZWxkRXJyb3JzID0+IHtcbiAgICAgICAgbmV4dChmaWVsZEVycm9ycy5zb3J0KHRoaXMuX3NvcnRFcnJvcnMpLmNvbmNhdChvYmplY3RFcnJvcnMpLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBjbG9uZShzcGVjKSB7XG4gICAgY29uc3QgbmV4dCA9IHN1cGVyLmNsb25lKHNwZWMpO1xuICAgIG5leHQuZmllbGRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5maWVsZHMpO1xuICAgIG5leHQuX25vZGVzID0gdGhpcy5fbm9kZXM7XG4gICAgbmV4dC5fZXhjbHVkZWRFZGdlcyA9IHRoaXMuX2V4Y2x1ZGVkRWRnZXM7XG4gICAgbmV4dC5fc29ydEVycm9ycyA9IHRoaXMuX3NvcnRFcnJvcnM7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgY29uY2F0KHNjaGVtYSkge1xuICAgIGxldCBuZXh0ID0gc3VwZXIuY29uY2F0KHNjaGVtYSk7XG4gICAgbGV0IG5leHRGaWVsZHMgPSBuZXh0LmZpZWxkcztcbiAgICBmb3IgKGxldCBbZmllbGQsIHNjaGVtYU9yUmVmXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmZpZWxkcykpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IG5leHRGaWVsZHNbZmllbGRdO1xuICAgICAgbmV4dEZpZWxkc1tmaWVsZF0gPSB0YXJnZXQgPT09IHVuZGVmaW5lZCA/IHNjaGVtYU9yUmVmIDogdGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gbmV4dC53aXRoTXV0YXRpb24ocyA9PlxuICAgIC8vIFhYWDogZXhjbHVkZXMgaGVyZSBpcyB3cm9uZ1xuICAgIHMuc2V0RmllbGRzKG5leHRGaWVsZHMsIFsuLi50aGlzLl9leGNsdWRlZEVkZ2VzLCAuLi5zY2hlbWEuX2V4Y2x1ZGVkRWRnZXNdKSk7XG4gIH1cbiAgX2dldERlZmF1bHQob3B0aW9ucykge1xuICAgIGlmICgnZGVmYXVsdCcgaW4gdGhpcy5zcGVjKSB7XG4gICAgICByZXR1cm4gc3VwZXIuX2dldERlZmF1bHQob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gZGVmYXVsdCBzZXQgaW52ZW50IG9uZVxuICAgIGlmICghdGhpcy5fbm9kZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgZGZ0ID0ge307XG4gICAgdGhpcy5fbm9kZXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgdmFyIF9pbm5lck9wdGlvbnM7XG4gICAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGRzW2tleV07XG4gICAgICBsZXQgaW5uZXJPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIGlmICgoX2lubmVyT3B0aW9ucyA9IGlubmVyT3B0aW9ucykgIT0gbnVsbCAmJiBfaW5uZXJPcHRpb25zLnZhbHVlKSB7XG4gICAgICAgIGlubmVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGlubmVyT3B0aW9ucywge1xuICAgICAgICAgIHBhcmVudDogaW5uZXJPcHRpb25zLnZhbHVlLFxuICAgICAgICAgIHZhbHVlOiBpbm5lck9wdGlvbnMudmFsdWVba2V5XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRmdFtrZXldID0gZmllbGQgJiYgJ2dldERlZmF1bHQnIGluIGZpZWxkID8gZmllbGQuZ2V0RGVmYXVsdChpbm5lck9wdGlvbnMpIDogdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIHJldHVybiBkZnQ7XG4gIH1cbiAgc2V0RmllbGRzKHNoYXBlLCBleGNsdWRlZEVkZ2VzKSB7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbmV4dC5maWVsZHMgPSBzaGFwZTtcbiAgICBuZXh0Ll9ub2RlcyA9IHNvcnRGaWVsZHMoc2hhcGUsIGV4Y2x1ZGVkRWRnZXMpO1xuICAgIG5leHQuX3NvcnRFcnJvcnMgPSBzb3J0QnlLZXlPcmRlcihPYmplY3Qua2V5cyhzaGFwZSkpO1xuICAgIC8vIFhYWDogdGhpcyBjYXJyaWVzIG92ZXIgZWRnZXMgd2hpY2ggbWF5IG5vdCBiZSB3aGF0IHlvdSB3YW50XG4gICAgaWYgKGV4Y2x1ZGVkRWRnZXMpIG5leHQuX2V4Y2x1ZGVkRWRnZXMgPSBleGNsdWRlZEVkZ2VzO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIHNoYXBlKGFkZGl0aW9ucywgZXhjbHVkZXMgPSBbXSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkud2l0aE11dGF0aW9uKG5leHQgPT4ge1xuICAgICAgbGV0IGVkZ2VzID0gbmV4dC5fZXhjbHVkZWRFZGdlcztcbiAgICAgIGlmIChleGNsdWRlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGV4Y2x1ZGVzWzBdKSkgZXhjbHVkZXMgPSBbZXhjbHVkZXNdO1xuICAgICAgICBlZGdlcyA9IFsuLi5uZXh0Ll9leGNsdWRlZEVkZ2VzLCAuLi5leGNsdWRlc107XG4gICAgICB9XG5cbiAgICAgIC8vIFhYWDogZXhjbHVkZXMgaGVyZSBpcyB3cm9uZ1xuICAgICAgcmV0dXJuIG5leHQuc2V0RmllbGRzKE9iamVjdC5hc3NpZ24obmV4dC5maWVsZHMsIGFkZGl0aW9ucyksIGVkZ2VzKTtcbiAgICB9KTtcbiAgfVxuICBwYXJ0aWFsKCkge1xuICAgIGNvbnN0IHBhcnRpYWwgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHNjaGVtYV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5maWVsZHMpKSB7XG4gICAgICBwYXJ0aWFsW2tleV0gPSAnb3B0aW9uYWwnIGluIHNjaGVtYSAmJiBzY2hlbWEub3B0aW9uYWwgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IHNjaGVtYS5vcHRpb25hbCgpIDogc2NoZW1hO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zZXRGaWVsZHMocGFydGlhbCk7XG4gIH1cbiAgZGVlcFBhcnRpYWwoKSB7XG4gICAgY29uc3QgbmV4dCA9IGRlZXBQYXJ0aWFsKHRoaXMpO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIHBpY2soa2V5cykge1xuICAgIGNvbnN0IHBpY2tlZCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGlmICh0aGlzLmZpZWxkc1trZXldKSBwaWNrZWRba2V5XSA9IHRoaXMuZmllbGRzW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNldEZpZWxkcyhwaWNrZWQsIHRoaXMuX2V4Y2x1ZGVkRWRnZXMuZmlsdGVyKChbYSwgYl0pID0+IGtleXMuaW5jbHVkZXMoYSkgJiYga2V5cy5pbmNsdWRlcyhiKSkpO1xuICB9XG4gIG9taXQoa2V5cykge1xuICAgIGNvbnN0IHJlbWFpbmluZyA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuZmllbGRzKSkge1xuICAgICAgaWYgKGtleXMuaW5jbHVkZXMoa2V5KSkgY29udGludWU7XG4gICAgICByZW1haW5pbmcucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5waWNrKHJlbWFpbmluZyk7XG4gIH1cbiAgZnJvbShmcm9tLCB0bywgYWxpYXMpIHtcbiAgICBsZXQgZnJvbUdldHRlciA9IGdldHRlcihmcm9tLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ob2JqID0+IHtcbiAgICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuICAgICAgbGV0IG5ld09iaiA9IG9iajtcbiAgICAgIGlmIChkZWVwSGFzKG9iaiwgZnJvbSkpIHtcbiAgICAgICAgbmV3T2JqID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgICAgICAgaWYgKCFhbGlhcykgZGVsZXRlIG5ld09ialtmcm9tXTtcbiAgICAgICAgbmV3T2JqW3RvXSA9IGZyb21HZXR0ZXIob2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfSk7XG4gIH1cblxuICAvKiogUGFyc2UgYW4gaW5wdXQgSlNPTiBzdHJpbmcgdG8gYW4gb2JqZWN0ICovXG4gIGpzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHBhcnNlSnNvbik7XG4gIH1cblxuICAvKipcbiAgICogU2ltaWxhciB0byBgbm9Vbmtub3duYCBidXQgb25seSB2YWxpZGF0ZXMgdGhhdCBhbiBvYmplY3QgaXMgdGhlIHJpZ2h0IHNoYXBlIHdpdGhvdXQgc3RyaXBwaW5nIHRoZSB1bmtub3duIGtleXNcbiAgICovXG4gIGV4YWN0KG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG5hbWU6ICdleGFjdCcsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8IG9iamVjdC5leGFjdCxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IHVua25vd24odGhpcy5zY2hlbWEsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHVua25vd25LZXlzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLmNyZWF0ZUVycm9yKHtcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHVua25vd25LZXlzLmpvaW4oJywgJylcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0cmlwVW5rbm93bigpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSh7XG4gICAgICBub1Vua25vd246IHRydWVcbiAgICB9KTtcbiAgfVxuICBub1Vua25vd24obm9BbGxvdyA9IHRydWUsIG1lc3NhZ2UgPSBvYmplY3Qubm9Vbmtub3duKSB7XG4gICAgaWYgKHR5cGVvZiBub0FsbG93ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIG1lc3NhZ2UgPSBub0FsbG93O1xuICAgICAgbm9BbGxvdyA9IHRydWU7XG4gICAgfVxuICAgIGxldCBuZXh0ID0gdGhpcy50ZXN0KHtcbiAgICAgIG5hbWU6ICdub1Vua25vd24nLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IHVua25vd24odGhpcy5zY2hlbWEsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuICFub0FsbG93IHx8IHVua25vd25LZXlzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLmNyZWF0ZUVycm9yKHtcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHVua25vd246IHVua25vd25LZXlzLmpvaW4oJywgJylcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG5leHQuc3BlYy5ub1Vua25vd24gPSBub0FsbG93O1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIHVua25vd24oYWxsb3cgPSB0cnVlLCBtZXNzYWdlID0gb2JqZWN0Lm5vVW5rbm93bikge1xuICAgIHJldHVybiB0aGlzLm5vVW5rbm93bighYWxsb3csIG1lc3NhZ2UpO1xuICB9XG4gIHRyYW5zZm9ybUtleXMoZm4pIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ob2JqID0+IHtcbiAgICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSByZXN1bHRbZm4oa2V5KV0gPSBvYmpba2V5XTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH1cbiAgY2FtZWxDYXNlKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUtleXMoY2FtZWxDYXNlKTtcbiAgfVxuICBzbmFrZUNhc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtS2V5cyhzbmFrZUNhc2UpO1xuICB9XG4gIGNvbnN0YW50Q2FzZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1LZXlzKGtleSA9PiBzbmFrZUNhc2Uoa2V5KS50b1VwcGVyQ2FzZSgpKTtcbiAgfVxuICBkZXNjcmliZShvcHRpb25zKSB7XG4gICAgY29uc3QgbmV4dCA9IChvcHRpb25zID8gdGhpcy5yZXNvbHZlKG9wdGlvbnMpIDogdGhpcykuY2xvbmUoKTtcbiAgICBjb25zdCBiYXNlID0gc3VwZXIuZGVzY3JpYmUob3B0aW9ucyk7XG4gICAgYmFzZS5maWVsZHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhuZXh0LmZpZWxkcykpIHtcbiAgICAgIHZhciBfaW5uZXJPcHRpb25zMjtcbiAgICAgIGxldCBpbm5lck9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgaWYgKChfaW5uZXJPcHRpb25zMiA9IGlubmVyT3B0aW9ucykgIT0gbnVsbCAmJiBfaW5uZXJPcHRpb25zMi52YWx1ZSkge1xuICAgICAgICBpbm5lck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBpbm5lck9wdGlvbnMsIHtcbiAgICAgICAgICBwYXJlbnQ6IGlubmVyT3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICB2YWx1ZTogaW5uZXJPcHRpb25zLnZhbHVlW2tleV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBiYXNlLmZpZWxkc1trZXldID0gdmFsdWUuZGVzY3JpYmUoaW5uZXJPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbn1cbmNyZWF0ZSQzLnByb3RvdHlwZSA9IE9iamVjdFNjaGVtYS5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGNyZWF0ZSQyKHR5cGUpIHtcbiAgcmV0dXJuIG5ldyBBcnJheVNjaGVtYSh0eXBlKTtcbn1cbmNsYXNzIEFycmF5U2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBzcGVjOiB7XG4gICAgICAgIHR5cGVzOiB0eXBlXG4gICAgICB9LFxuICAgICAgY2hlY2sodikge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGB1bmRlZmluZWRgIHNwZWNpZmljYWxseSBtZWFucyB1bmluaXRpYWxpemVkLCBhcyBvcHBvc2VkIHRvIFwibm8gc3VidHlwZVwiXG4gICAgdGhpcy5pbm5lclR5cGUgPSB2b2lkIDA7XG4gICAgdGhpcy5pbm5lclR5cGUgPSB0eXBlO1xuICB9XG4gIF9jYXN0KF92YWx1ZSwgX29wdHMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN1cGVyLl9jYXN0KF92YWx1ZSwgX29wdHMpO1xuXG4gICAgLy8gc2hvdWxkIGlnbm9yZSBudWxscyBoZXJlXG4gICAgaWYgKCF0aGlzLl90eXBlQ2hlY2sodmFsdWUpIHx8ICF0aGlzLmlubmVyVHlwZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgaXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgY29uc3QgY2FzdEFycmF5ID0gdmFsdWUubWFwKCh2LCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IGNhc3RFbGVtZW50ID0gdGhpcy5pbm5lclR5cGUuY2FzdCh2LCBPYmplY3QuYXNzaWduKHt9LCBfb3B0cywge1xuICAgICAgICBwYXRoOiBgJHtfb3B0cy5wYXRoIHx8ICcnfVske2lkeH1dYFxuICAgICAgfSkpO1xuICAgICAgaWYgKGNhc3RFbGVtZW50ICE9PSB2KSB7XG4gICAgICAgIGlzQ2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FzdEVsZW1lbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzQ2hhbmdlZCA/IGNhc3RBcnJheSA6IHZhbHVlO1xuICB9XG4gIF92YWxpZGF0ZShfdmFsdWUsIG9wdGlvbnMgPSB7fSwgcGFuaWMsIG5leHQpIHtcbiAgICB2YXIgX29wdGlvbnMkcmVjdXJzaXZlO1xuICAgIC8vIGxldCBzeW5jID0gb3B0aW9ucy5zeW5jO1xuICAgIC8vIGxldCBwYXRoID0gb3B0aW9ucy5wYXRoO1xuICAgIGxldCBpbm5lclR5cGUgPSB0aGlzLmlubmVyVHlwZTtcbiAgICAvLyBsZXQgZW5kRWFybHkgPSBvcHRpb25zLmFib3J0RWFybHkgPz8gdGhpcy5zcGVjLmFib3J0RWFybHk7XG4gICAgbGV0IHJlY3Vyc2l2ZSA9IChfb3B0aW9ucyRyZWN1cnNpdmUgPSBvcHRpb25zLnJlY3Vyc2l2ZSkgIT0gbnVsbCA/IF9vcHRpb25zJHJlY3Vyc2l2ZSA6IHRoaXMuc3BlYy5yZWN1cnNpdmU7XG4gICAgb3B0aW9ucy5vcmlnaW5hbFZhbHVlICE9IG51bGwgPyBvcHRpb25zLm9yaWdpbmFsVmFsdWUgOiBfdmFsdWU7XG4gICAgc3VwZXIuX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucywgcGFuaWMsIChhcnJheUVycm9ycywgdmFsdWUpID0+IHtcbiAgICAgIHZhciBfb3B0aW9ucyRvcmlnaW5hbFZhbHUyO1xuICAgICAgaWYgKCFyZWN1cnNpdmUgfHwgIWlubmVyVHlwZSB8fCAhdGhpcy5fdHlwZUNoZWNrKHZhbHVlKSkge1xuICAgICAgICBuZXh0KGFycmF5RXJyb3JzLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gIzk1MCBFbnN1cmUgdGhhdCBzcGFyc2UgYXJyYXkgZW1wdHkgc2xvdHMgYXJlIHZhbGlkYXRlZFxuICAgICAgbGV0IHRlc3RzID0gbmV3IEFycmF5KHZhbHVlLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdmFsdWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBfb3B0aW9ucyRvcmlnaW5hbFZhbHU7XG4gICAgICAgIHRlc3RzW2luZGV4XSA9IGlubmVyVHlwZS5hc05lc3RlZFRlc3Qoe1xuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgcGFyZW50OiB2YWx1ZSxcbiAgICAgICAgICBwYXJlbnRQYXRoOiBvcHRpb25zLnBhdGgsXG4gICAgICAgICAgb3JpZ2luYWxQYXJlbnQ6IChfb3B0aW9ucyRvcmlnaW5hbFZhbHUgPSBvcHRpb25zLm9yaWdpbmFsVmFsdWUpICE9IG51bGwgPyBfb3B0aW9ucyRvcmlnaW5hbFZhbHUgOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJ1blRlc3RzKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHRlc3RzLFxuICAgICAgICBvcmlnaW5hbFZhbHVlOiAoX29wdGlvbnMkb3JpZ2luYWxWYWx1MiA9IG9wdGlvbnMub3JpZ2luYWxWYWx1ZSkgIT0gbnVsbCA/IF9vcHRpb25zJG9yaWdpbmFsVmFsdTIgOiBfdmFsdWUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0sIHBhbmljLCBpbm5lclR5cGVFcnJvcnMgPT4gbmV4dChpbm5lclR5cGVFcnJvcnMuY29uY2F0KGFycmF5RXJyb3JzKSwgdmFsdWUpKTtcbiAgICB9KTtcbiAgfVxuICBjbG9uZShzcGVjKSB7XG4gICAgY29uc3QgbmV4dCA9IHN1cGVyLmNsb25lKHNwZWMpO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcmVhZG9ubHlcbiAgICBuZXh0LmlubmVyVHlwZSA9IHRoaXMuaW5uZXJUeXBlO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLyoqIFBhcnNlIGFuIGlucHV0IEpTT04gc3RyaW5nIHRvIGFuIG9iamVjdCAqL1xuICBqc29uKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShwYXJzZUpzb24pO1xuICB9XG4gIGNvbmNhdChzY2hlbWEpIHtcbiAgICBsZXQgbmV4dCA9IHN1cGVyLmNvbmNhdChzY2hlbWEpO1xuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciByZWFkb25seVxuICAgIG5leHQuaW5uZXJUeXBlID0gdGhpcy5pbm5lclR5cGU7XG4gICAgaWYgKHNjaGVtYS5pbm5lclR5cGUpXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHJlYWRvbmx5XG4gICAgICBuZXh0LmlubmVyVHlwZSA9IG5leHQuaW5uZXJUeXBlID9cbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTGF6eSBkb2Vzbid0IGhhdmUgY29uY2F0IGFuZCB3aWxsIGJyZWFrXG4gICAgICBuZXh0LmlubmVyVHlwZS5jb25jYXQoc2NoZW1hLmlubmVyVHlwZSkgOiBzY2hlbWEuaW5uZXJUeXBlO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG9mKHNjaGVtYSkge1xuICAgIC8vIEZJWE1FOiB0aGlzIHNob3VsZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYXJyYXkgd2l0aG91dCB0aGUgZGVmYXVsdCB0byBiZVxuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIGlmICghaXNTY2hlbWEoc2NoZW1hKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYGFycmF5Lm9mKClgIHN1Yi1zY2hlbWEgbXVzdCBiZSBhIHZhbGlkIHl1cCBzY2hlbWEgbm90OiAnICsgcHJpbnRWYWx1ZShzY2hlbWEpKTtcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcmVhZG9ubHlcbiAgICBuZXh0LmlubmVyVHlwZSA9IHNjaGVtYTtcbiAgICBuZXh0LnNwZWMgPSBPYmplY3QuYXNzaWduKHt9LCBuZXh0LnNwZWMsIHtcbiAgICAgIHR5cGVzOiBzY2hlbWFcbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBsZW5ndGgobGVuZ3RoLCBtZXNzYWdlID0gYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ2xlbmd0aCcsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbGVuZ3RoXG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gdGhpcy5yZXNvbHZlKGxlbmd0aCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWluKG1pbiwgbWVzc2FnZSkge1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IGFycmF5Lm1pbjtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbWluJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtaW5cbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgLy8gRklYTUUodHMpOiBBcnJheTx0eXBlb2YgVD5cbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+PSB0aGlzLnJlc29sdmUobWluKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtYXgobWF4LCBtZXNzYWdlKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgYXJyYXkubWF4O1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtYXgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1heFxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPD0gdGhpcy5yZXNvbHZlKG1heCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZW5zdXJlKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHQoKCkgPT4gW10pLnRyYW5zZm9ybSgodmFsLCBvcmlnaW5hbCkgPT4ge1xuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZXR1cm4gYG51bGxgIGZvciBudWxsYWJsZSBzY2hlbWFcbiAgICAgIGlmICh0aGlzLl90eXBlQ2hlY2sodmFsKSkgcmV0dXJuIHZhbDtcbiAgICAgIHJldHVybiBvcmlnaW5hbCA9PSBudWxsID8gW10gOiBbXS5jb25jYXQob3JpZ2luYWwpO1xuICAgIH0pO1xuICB9XG4gIGNvbXBhY3QocmVqZWN0b3IpIHtcbiAgICBsZXQgcmVqZWN0ID0gIXJlamVjdG9yID8gdiA9PiAhIXYgOiAodiwgaSwgYSkgPT4gIXJlamVjdG9yKHYsIGksIGEpO1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh2YWx1ZXMgPT4gdmFsdWVzICE9IG51bGwgPyB2YWx1ZXMuZmlsdGVyKHJlamVjdCkgOiB2YWx1ZXMpO1xuICB9XG4gIGRlc2NyaWJlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBuZXh0ID0gKG9wdGlvbnMgPyB0aGlzLnJlc29sdmUob3B0aW9ucykgOiB0aGlzKS5jbG9uZSgpO1xuICAgIGNvbnN0IGJhc2UgPSBzdXBlci5kZXNjcmliZShvcHRpb25zKTtcbiAgICBpZiAobmV4dC5pbm5lclR5cGUpIHtcbiAgICAgIHZhciBfaW5uZXJPcHRpb25zO1xuICAgICAgbGV0IGlubmVyT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICBpZiAoKF9pbm5lck9wdGlvbnMgPSBpbm5lck9wdGlvbnMpICE9IG51bGwgJiYgX2lubmVyT3B0aW9ucy52YWx1ZSkge1xuICAgICAgICBpbm5lck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBpbm5lck9wdGlvbnMsIHtcbiAgICAgICAgICBwYXJlbnQ6IGlubmVyT3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICB2YWx1ZTogaW5uZXJPcHRpb25zLnZhbHVlWzBdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYmFzZS5pbm5lclR5cGUgPSBuZXh0LmlubmVyVHlwZS5kZXNjcmliZShpbm5lck9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxufVxuY3JlYXRlJDIucHJvdG90eXBlID0gQXJyYXlTY2hlbWEucHJvdG90eXBlO1xuXG4vLyBAdHMtaWdub3JlXG5mdW5jdGlvbiBjcmVhdGUkMShzY2hlbWFzKSB7XG4gIHJldHVybiBuZXcgVHVwbGVTY2hlbWEoc2NoZW1hcyk7XG59XG5jbGFzcyBUdXBsZVNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKHNjaGVtYXMpIHtcbiAgICBzdXBlcih7XG4gICAgICB0eXBlOiAndHVwbGUnLFxuICAgICAgc3BlYzoge1xuICAgICAgICB0eXBlczogc2NoZW1hc1xuICAgICAgfSxcbiAgICAgIGNoZWNrKHYpIHtcbiAgICAgICAgY29uc3QgdHlwZXMgPSB0aGlzLnNwZWMudHlwZXM7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYpICYmIHYubGVuZ3RoID09PSB0eXBlcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy53aXRoTXV0YXRpb24oKCkgPT4ge1xuICAgICAgdGhpcy50eXBlRXJyb3IodHVwbGUubm90VHlwZSk7XG4gICAgfSk7XG4gIH1cbiAgX2Nhc3QoaW5wdXRWYWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVzXG4gICAgfSA9IHRoaXMuc3BlYztcbiAgICBjb25zdCB2YWx1ZSA9IHN1cGVyLl9jYXN0KGlucHV0VmFsdWUsIG9wdGlvbnMpO1xuICAgIGlmICghdGhpcy5fdHlwZUNoZWNrKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgaXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgY29uc3QgY2FzdEFycmF5ID0gdHlwZXMubWFwKCh0eXBlLCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IGNhc3RFbGVtZW50ID0gdHlwZS5jYXN0KHZhbHVlW2lkeF0sIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgcGF0aDogYCR7b3B0aW9ucy5wYXRoIHx8ICcnfVske2lkeH1dYFxuICAgICAgfSkpO1xuICAgICAgaWYgKGNhc3RFbGVtZW50ICE9PSB2YWx1ZVtpZHhdKSBpc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGNhc3RFbGVtZW50O1xuICAgIH0pO1xuICAgIHJldHVybiBpc0NoYW5nZWQgPyBjYXN0QXJyYXkgOiB2YWx1ZTtcbiAgfVxuICBfdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zID0ge30sIHBhbmljLCBuZXh0KSB7XG4gICAgbGV0IGl0ZW1UeXBlcyA9IHRoaXMuc3BlYy50eXBlcztcbiAgICBzdXBlci5fdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zLCBwYW5pYywgKHR1cGxlRXJyb3JzLCB2YWx1ZSkgPT4ge1xuICAgICAgdmFyIF9vcHRpb25zJG9yaWdpbmFsVmFsdTI7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IG5vdCByZXNwZWN0aW5nIHJlY3Vyc2l2ZVxuICAgICAgaWYgKCF0aGlzLl90eXBlQ2hlY2sodmFsdWUpKSB7XG4gICAgICAgIG5leHQodHVwbGVFcnJvcnMsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHRlc3RzID0gW107XG4gICAgICBmb3IgKGxldCBbaW5kZXgsIGl0ZW1TY2hlbWFdIG9mIGl0ZW1UeXBlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgdmFyIF9vcHRpb25zJG9yaWdpbmFsVmFsdTtcbiAgICAgICAgdGVzdHNbaW5kZXhdID0gaXRlbVNjaGVtYS5hc05lc3RlZFRlc3Qoe1xuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgcGFyZW50OiB2YWx1ZSxcbiAgICAgICAgICBwYXJlbnRQYXRoOiBvcHRpb25zLnBhdGgsXG4gICAgICAgICAgb3JpZ2luYWxQYXJlbnQ6IChfb3B0aW9ucyRvcmlnaW5hbFZhbHUgPSBvcHRpb25zLm9yaWdpbmFsVmFsdWUpICE9IG51bGwgPyBfb3B0aW9ucyRvcmlnaW5hbFZhbHUgOiBfdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJ1blRlc3RzKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHRlc3RzLFxuICAgICAgICBvcmlnaW5hbFZhbHVlOiAoX29wdGlvbnMkb3JpZ2luYWxWYWx1MiA9IG9wdGlvbnMub3JpZ2luYWxWYWx1ZSkgIT0gbnVsbCA/IF9vcHRpb25zJG9yaWdpbmFsVmFsdTIgOiBfdmFsdWUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0sIHBhbmljLCBpbm5lclR5cGVFcnJvcnMgPT4gbmV4dChpbm5lclR5cGVFcnJvcnMuY29uY2F0KHR1cGxlRXJyb3JzKSwgdmFsdWUpKTtcbiAgICB9KTtcbiAgfVxuICBkZXNjcmliZShvcHRpb25zKSB7XG4gICAgY29uc3QgbmV4dCA9IChvcHRpb25zID8gdGhpcy5yZXNvbHZlKG9wdGlvbnMpIDogdGhpcykuY2xvbmUoKTtcbiAgICBjb25zdCBiYXNlID0gc3VwZXIuZGVzY3JpYmUob3B0aW9ucyk7XG4gICAgYmFzZS5pbm5lclR5cGUgPSBuZXh0LnNwZWMudHlwZXMubWFwKChzY2hlbWEsIGluZGV4KSA9PiB7XG4gICAgICB2YXIgX2lubmVyT3B0aW9ucztcbiAgICAgIGxldCBpbm5lck9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgaWYgKChfaW5uZXJPcHRpb25zID0gaW5uZXJPcHRpb25zKSAhPSBudWxsICYmIF9pbm5lck9wdGlvbnMudmFsdWUpIHtcbiAgICAgICAgaW5uZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgaW5uZXJPcHRpb25zLCB7XG4gICAgICAgICAgcGFyZW50OiBpbm5lck9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgdmFsdWU6IGlubmVyT3B0aW9ucy52YWx1ZVtpbmRleF1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hLmRlc2NyaWJlKGlubmVyT3B0aW9ucyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbn1cbmNyZWF0ZSQxLnByb3RvdHlwZSA9IFR1cGxlU2NoZW1hLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gY3JlYXRlKGJ1aWxkZXIpIHtcbiAgcmV0dXJuIG5ldyBMYXp5KGJ1aWxkZXIpO1xufVxuZnVuY3Rpb24gY2F0Y2hWYWxpZGF0aW9uRXJyb3IoZm4pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycikpIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuY2xhc3MgTGF6eSB7XG4gIGNvbnN0cnVjdG9yKGJ1aWxkZXIpIHtcbiAgICB0aGlzLnR5cGUgPSAnbGF6eSc7XG4gICAgdGhpcy5fX2lzWXVwU2NoZW1hX18gPSB0cnVlO1xuICAgIHRoaXMuc3BlYyA9IHZvaWQgMDtcbiAgICB0aGlzLl9yZXNvbHZlID0gKHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGxldCBzY2hlbWEgPSB0aGlzLmJ1aWxkZXIodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFpc1NjaGVtYShzY2hlbWEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdsYXp5KCkgZnVuY3Rpb25zIG11c3QgcmV0dXJuIGEgdmFsaWQgc2NoZW1hJyk7XG4gICAgICBpZiAodGhpcy5zcGVjLm9wdGlvbmFsKSBzY2hlbWEgPSBzY2hlbWEub3B0aW9uYWwoKTtcbiAgICAgIHJldHVybiBzY2hlbWEucmVzb2x2ZShvcHRpb25zKTtcbiAgICB9O1xuICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXI7XG4gICAgdGhpcy5zcGVjID0ge1xuICAgICAgbWV0YTogdW5kZWZpbmVkLFxuICAgICAgb3B0aW9uYWw6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjbG9uZShzcGVjKSB7XG4gICAgY29uc3QgbmV4dCA9IG5ldyBMYXp5KHRoaXMuYnVpbGRlcik7XG4gICAgbmV4dC5zcGVjID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zcGVjLCBzcGVjKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBvcHRpb25hbGl0eShvcHRpb25hbCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmNsb25lKHtcbiAgICAgIG9wdGlvbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgb3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uYWxpdHkodHJ1ZSk7XG4gIH1cbiAgcmVzb2x2ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUob3B0aW9ucy52YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgY2FzdCh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS5jYXN0KHZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBhc05lc3RlZFRlc3QoY29uZmlnKSB7XG4gICAgbGV0IHtcbiAgICAgIGtleSxcbiAgICAgIGluZGV4LFxuICAgICAgcGFyZW50LFxuICAgICAgb3B0aW9uc1xuICAgIH0gPSBjb25maWc7XG4gICAgbGV0IHZhbHVlID0gcGFyZW50W2luZGV4ICE9IG51bGwgPyBpbmRleCA6IGtleV07XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodmFsdWUsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIHZhbHVlLFxuICAgICAgcGFyZW50XG4gICAgfSkpLmFzTmVzdGVkVGVzdChjb25maWcpO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGNhdGNoVmFsaWRhdGlvbkVycm9yKCgpID0+IHRoaXMuX3Jlc29sdmUodmFsdWUsIG9wdGlvbnMpLnZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKSk7XG4gIH1cbiAgdmFsaWRhdGVTeW5jKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodmFsdWUsIG9wdGlvbnMpLnZhbGlkYXRlU3luYyh2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgdmFsaWRhdGVBdChwYXRoLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBjYXRjaFZhbGlkYXRpb25FcnJvcigoKSA9PiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS52YWxpZGF0ZUF0KHBhdGgsIHZhbHVlLCBvcHRpb25zKSk7XG4gIH1cbiAgdmFsaWRhdGVTeW5jQXQocGF0aCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykudmFsaWRhdGVTeW5jQXQocGF0aCwgdmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIGlzVmFsaWQodmFsdWUsIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodmFsdWUsIG9wdGlvbnMpLmlzVmFsaWQodmFsdWUsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycikpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIGlzVmFsaWRTeW5jKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodmFsdWUsIG9wdGlvbnMpLmlzVmFsaWRTeW5jKHZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBkZXNjcmliZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPyB0aGlzLnJlc29sdmUob3B0aW9ucykuZGVzY3JpYmUob3B0aW9ucykgOiB7XG4gICAgICB0eXBlOiAnbGF6eScsXG4gICAgICBtZXRhOiB0aGlzLnNwZWMubWV0YSxcbiAgICAgIGxhYmVsOiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG4gIG1ldGEoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuc3BlYy5tZXRhO1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIG5leHQuc3BlYy5tZXRhID0gT2JqZWN0LmFzc2lnbihuZXh0LnNwZWMubWV0YSB8fCB7fSwgYXJnc1swXSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0TG9jYWxlKGN1c3RvbSkge1xuICBPYmplY3Qua2V5cyhjdXN0b20pLmZvckVhY2godHlwZSA9PiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIE9iamVjdC5rZXlzKGN1c3RvbVt0eXBlXSkuZm9yRWFjaChtZXRob2QgPT4ge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbG9jYWxlW3R5cGVdW21ldGhvZF0gPSBjdXN0b21bdHlwZV1bbWV0aG9kXTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZE1ldGhvZChzY2hlbWFUeXBlLCBuYW1lLCBmbikge1xuICBpZiAoIXNjaGVtYVR5cGUgfHwgIWlzU2NoZW1hKHNjaGVtYVR5cGUucHJvdG90eXBlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcHJvdmlkZSBhIHl1cCBzY2hlbWEgY29uc3RydWN0b3IgZnVuY3Rpb24nKTtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBNZXRob2QgbmFtZSBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ01ldGhvZCBmdW5jdGlvbiBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gIHNjaGVtYVR5cGUucHJvdG90eXBlW25hbWVdID0gZm47XG59XG5cbmV4cG9ydCB7IEFycmF5U2NoZW1hLCBCb29sZWFuU2NoZW1hLCBEYXRlU2NoZW1hLCBMYXp5IGFzIExhenlTY2hlbWEsIE1peGVkU2NoZW1hLCBOdW1iZXJTY2hlbWEsIE9iamVjdFNjaGVtYSwgU2NoZW1hLCBTdHJpbmdTY2hlbWEsIFR1cGxlU2NoZW1hLCBWYWxpZGF0aW9uRXJyb3IsIGFkZE1ldGhvZCwgY3JlYXRlJDIgYXMgYXJyYXksIGNyZWF0ZSQ3IGFzIGJvb2wsIGNyZWF0ZSQ3IGFzIGJvb2xlYW4sIGNyZWF0ZSQ0IGFzIGRhdGUsIGxvY2FsZSBhcyBkZWZhdWx0TG9jYWxlLCBnZXRJbiwgaXNTY2hlbWEsIGNyZWF0ZSBhcyBsYXp5LCBjcmVhdGUkOCBhcyBtaXhlZCwgY3JlYXRlJDUgYXMgbnVtYmVyLCBjcmVhdGUkMyBhcyBvYmplY3QsIHByaW50VmFsdWUsIHJlYWNoLCBjcmVhdGUkOSBhcyByZWYsIHNldExvY2FsZSwgY3JlYXRlJDYgYXMgc3RyaW5nLCBjcmVhdGUkMSBhcyB0dXBsZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/yup/index.esm.js\n");

/***/ })

}]);